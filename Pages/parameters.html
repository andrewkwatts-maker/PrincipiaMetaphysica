<!DOCTYPE html>
<!--
    Copyright (c) 2025 Andrew Keith Watts. All rights reserved.

    This is the intellectual property of Andrew Keith Watts. Unauthorized
    reproduction, distribution, or modification of this code, in whole or in part,
    without the express written permission of Andrew Keith Watts is strictly prohibited.

    For inquiries, please contact AndrewKWatts@Gmail.com
-->
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Complete parameter reference for Principia Metaphysica - geometric, derived, calibrated, predicted, and experimental parameters" name="description"/>
    <title>Theory Parameters - Principia Metaphysica</title>
    <link href="../css/styles.css" rel="stylesheet"/>
    <link href="../css/pm-common.css" rel="stylesheet"/>
    <link rel="stylesheet" href="../css/auth.css">
    <link rel="stylesheet" href="../css/pm-header.css">
    <link rel="stylesheet" href="../css/pm-ux-consistency.css">
    <link rel="stylesheet" href="../css/mobile-responsive.css">

    <!-- MathJax for mathematical symbols -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                tags: 'ams'
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        /* Tooltip styles */
        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip-content {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            z-index: 1000;
            background: rgba(26, 31, 58, 0.98);
            border: 1px solid rgba(139, 127, 255, 0.4);
            border-radius: 8px;
            padding: 0.75rem;
            color: var(--text-primary);
            font-size: 0.85rem;
            line-height: 1.4;
            width: max-content;
            max-width: 300px;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%) translateY(5px);
            transition: all 0.2s ease;
            pointer-events: none;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        .tooltip-content::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(139, 127, 255, 0.4);
        }

        .tooltip:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .tooltip-label {
            font-weight: 600;
            color: var(--accent-primary);
            display: block;
            margin-bottom: 0.25rem;
        }

        .tooltip-value {
            display: block;
            color: var(--text-secondary);
        }

        /* Page-specific styles */
        .parameters-hero {
            background: linear-gradient(135deg, rgba(139, 127, 255, 0.15), rgba(81, 207, 102, 0.1));
            border: 2px solid rgba(139, 127, 255, 0.3);
            border-radius: 20px;
            padding: 3rem;
            margin-bottom: 2.5rem;
            text-align: center;
            position: relative;
        }

        .parameters-hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-primary), #51cf66);
            border-radius: 20px 20px 0 0;
        }

        .parameters-hero h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--accent-primary), #51cf66);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
        }

        .parameters-hero p {
            color: var(--text-secondary);
            font-size: 1.1rem;
            max-width: 800px;
            margin: 0 auto;
        }

        /* Filter controls */
        .filter-controls {
            background: rgba(26, 31, 58, 0.5);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .filter-group label {
            color: var(--text-primary);
            font-weight: 600;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-group input[type="text"],
        .filter-group select {
            padding: 0.875rem 1.25rem;
            border: 1px solid rgba(139, 127, 255, 0.3);
            border-radius: 12px;
            background: rgba(139, 127, 255, 0.15);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            color: #f8f9fa;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .filter-group input[type="text"]:focus,
        .filter-group select:focus {
            outline: none;
            background: rgba(139, 127, 255, 0.2);
            border-color: rgba(139, 127, 255, 0.6);
            box-shadow:
                0 0 0 3px rgba(139, 127, 255, 0.15),
                0 0 20px rgba(139, 127, 255, 0.2);
        }

        .filter-group input[type="text"]::placeholder {
            color: rgba(248, 249, 250, 0.5);
        }

        /* Select dropdown options - dark background for readability */
        .filter-group select {
            cursor: pointer;
        }

        /* Dropdown options - ensure dark background for all browsers */
        .filter-group select option {
            background-color: #1a1f3a !important;
            color: #f8f9fa !important;
            padding: 0.5rem;
        }

        .filter-group select option:hover,
        .filter-group select option:focus,
        .filter-group select option:checked {
            background-color: rgba(139, 127, 255, 0.5) !important;
            color: #ffffff !important;
        }

        /* Firefox-specific dropdown styling */
        @-moz-document url-prefix() {
            .filter-group select option {
                background-color: #1a1f3a;
                color: #f8f9fa;
            }
        }

        /* Webkit/Chrome-specific dropdown styling */
        @supports (-webkit-appearance: none) {
            .filter-group select {
                -webkit-appearance: none;
                appearance: none;
                background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23f8f9fa' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
                background-repeat: no-repeat;
                background-position: right 0.75rem center;
                background-size: 1em;
                padding-right: 2.5rem;
            }
        }

        /* Statistics bar */
        .stats-bar {
            background: rgba(26, 31, 58, 0.5);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 1.5rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            display: block;
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-primary);
        }

        .stat-label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 0.25rem;
        }

        /* Category sections */
        .category-section {
            background: rgba(26, 31, 58, 0.4);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid rgba(139, 127, 255, 0.2);
            position: relative;
        }

        .category-header::before {
            content: '';
            position: absolute;
            top: -1rem;
            left: -1rem;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(139, 127, 255, 0.15) 0%, transparent 70%);
            pointer-events: none;
        }

        .category-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: capitalize;
            text-shadow: 0 0 20px rgba(139, 127, 255, 0.3);
        }

        .category-count {
            background: rgba(139, 127, 255, 0.15);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(139, 127, 255, 0.3);
            color: var(--accent-primary);
            padding: 0.35rem 0.85rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        /* Parameter cards */
        .parameter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
        }

        .parameter-card {
            background: rgba(26, 31, 58, 0.5);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 1.5rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .parameter-card:hover {
            background: rgba(26, 31, 58, 0.7);
            border-color: rgba(139, 127, 255, 0.3);
            transform: translateY(-2px) scale(1.01);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .parameter-card.filtered-out {
            display: none;
        }

        .param-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }

        .param-name {
            font-family: 'Courier New', monospace;
            font-weight: 700;
            font-size: 1rem;
            color: var(--accent-primary);
        }

        .param-status-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            transition: all 0.2s ease;
        }

        .param-status-badge.tooltip:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .status-DERIVED {
            background: rgba(139, 127, 255, 0.15);
            border: 1px solid rgba(139, 127, 255, 0.3);
            color: #8b7fff;
        }
        .status-PREDICTED {
            background: rgba(255, 183, 77, 0.15);
            border: 1px solid rgba(255, 183, 77, 0.3);
            color: #ffb74d;
        }
        .status-INPUT {
            background: rgba(77, 182, 255, 0.15);
            border: 1px solid rgba(77, 182, 255, 0.3);
            color: #4db6ff;
        }
        .status-MEASURED {
            background: rgba(81, 207, 102, 0.15);
            border: 1px solid rgba(81, 207, 102, 0.3);
            color: #51cf66;
        }
        .status-GEOMETRIC {
            background: rgba(81, 207, 102, 0.15);
            border: 1px solid rgba(81, 207, 102, 0.3);
            color: #51cf66;
        }
        .status-PASS,
        .status-RESOLVED {
            background: rgba(81, 207, 102, 0.15);
            border: 1px solid rgba(81, 207, 102, 0.3);
            color: #51cf66;
        }
        .status-CHECK,
        .status-PENDING {
            background: rgba(255, 183, 77, 0.15);
            border: 1px solid rgba(255, 183, 77, 0.3);
            color: #ffb74d;
        }
        .status-SPECULATIVE {
            background: rgba(255, 126, 182, 0.15);
            border: 1px solid rgba(255, 126, 182, 0.3);
            color: var(--accent-secondary);
        }
        .status-FITTED {
            background: rgba(255, 165, 0, 0.15);
            border: 1px solid rgba(255, 165, 0, 0.4);
            color: #ffa500;
        }
        .status-RIGOROUS {
            background: rgba(0, 200, 83, 0.15);
            border: 1px solid rgba(0, 200, 83, 0.4);
            color: #00c853;
        }

        .param-symbol {
            font-size: 1.8rem;
            color: var(--text-primary);
            margin: 0.75rem 0;
            font-style: italic;
        }

        .param-value-display {
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(139, 127, 255, 0.15);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(139, 127, 255, 0.3);
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .param-value-display.tooltip:hover {
            background: rgba(139, 127, 255, 0.2);
            border-color: rgba(139, 127, 255, 0.5);
            box-shadow: 0 4px 12px rgba(139, 127, 255, 0.2);
        }

        .param-value {
            font-family: 'Source Code Pro', monospace;
            font-size: 1.3rem;
            font-weight: 600;
            color: #f8f9fa;
        }

        .param-units {
            color: rgba(248, 249, 250, 0.7);
            font-size: 0.9rem;
            font-style: italic;
            font-weight: 500;
        }

        .param-uncertainty {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-left: 0.5rem;
        }

        .param-description {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        .param-metadata {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-primary);
            font-size: 0.85rem;
        }

        .metadata-item {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            color: var(--text-muted);
        }

        .metadata-label {
            font-weight: 600;
            color: var(--text-secondary);
        }

        .param-comparison {
            background: rgba(81, 207, 102, 0.08);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(81, 207, 102, 0.3);
            border-radius: 8px;
            padding: 0.75rem;
            margin-top: 1rem;
        }

        .comparison-header {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }

        .comparison-values {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            font-size: 0.85rem;
        }

        .comparison-item {
            display: flex;
            flex-direction: column;
        }

        .comparison-label {
            color: var(--text-muted);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .comparison-value {
            color: var(--text-primary);
            font-family: 'Source Code Pro', monospace;
            font-weight: 600;
            margin-top: 0.25rem;
        }

        .deviation-indicator {
            margin-top: 0.5rem;
            font-size: 0.8rem;
            padding: 0.35rem 0.6rem;
            border-radius: 6px;
            text-align: center;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        .deviation-good {
            background: rgba(81, 207, 102, 0.15);
            border: 1px solid rgba(81, 207, 102, 0.3);
            color: #51cf66;
        }

        .deviation-moderate {
            background: rgba(255, 183, 77, 0.15);
            border: 1px solid rgba(255, 183, 77, 0.3);
            color: #ffb74d;
        }

        .deviation-high {
            background: rgba(255, 126, 182, 0.15);
            border: 1px solid rgba(255, 126, 182, 0.3);
            color: var(--accent-secondary);
        }

        /* Deriving formula section */
        .deriving-formula {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: linear-gradient(135deg, rgba(81, 207, 102, 0.1), rgba(139, 127, 255, 0.05));
            border: 1px solid rgba(81, 207, 102, 0.3);
            border-radius: 8px;
        }

        .deriving-formula .formula-link.deriving {
            background: rgba(81, 207, 102, 0.15);
            border-color: rgba(81, 207, 102, 0.4);
            color: #51cf66;
        }

        .deriving-formula .formula-link.deriving:hover {
            background: rgba(81, 207, 102, 0.25);
            border-color: rgba(81, 207, 102, 0.6);
        }

        .formula-links {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-primary);
        }

        .formula-links-header {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .formula-link-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .formula-link {
            display: inline-block;
            padding: 0.35rem 0.75rem;
            background: rgba(139, 127, 255, 0.1);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            border: 1px solid rgba(139, 127, 255, 0.3);
            border-radius: 8px;
            color: var(--accent-primary);
            text-decoration: none;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .formula-link:hover {
            background: rgba(139, 127, 255, 0.2);
            border-color: rgba(139, 127, 255, 0.5);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 127, 255, 0.2);
        }

        /* View Toggle */
        .view-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            justify-content: center;
        }

        .view-btn {
            padding: 0.75rem 1.5rem;
            background: rgba(26, 31, 58, 0.5);
            border: 1px solid rgba(139, 127, 255, 0.3);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .view-btn:hover {
            background: rgba(139, 127, 255, 0.15);
            color: var(--text-primary);
        }

        .view-btn.active {
            background: linear-gradient(135deg, rgba(139, 127, 255, 0.25), rgba(255, 126, 182, 0.15));
            border-color: rgba(139, 127, 255, 0.5);
            color: var(--text-primary);
        }

        /* OOM Gap Table */
        .oom-table-container {
            background: rgba(26, 31, 58, 0.4);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 1.5rem;
            overflow-x: auto;
            display: none;
        }

        .oom-table-container.active {
            display: block;
        }

        .oom-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .oom-table th {
            background: rgba(139, 127, 255, 0.15);
            color: var(--text-primary);
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid rgba(139, 127, 255, 0.3);
            cursor: pointer;
            white-space: nowrap;
            user-select: none;
        }

        .oom-table th:hover {
            background: rgba(139, 127, 255, 0.25);
        }

        .oom-table th.sort-asc::after {
            content: ' ▲';
            font-size: 0.7rem;
        }

        .oom-table th.sort-desc::after {
            content: ' ▼';
            font-size: 0.7rem;
        }

        .oom-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
        }

        .oom-table tr:hover td {
            background: rgba(139, 127, 255, 0.08);
        }

        .oom-table .param-name-cell {
            font-family: 'Courier New', monospace;
            color: var(--accent-primary);
            font-weight: 500;
        }

        .oom-table .sigma-cell {
            font-weight: 600;
        }

        .oom-table .sigma-good {
            color: #51cf66;
        }

        .oom-table .sigma-moderate {
            color: #ffb74d;
        }

        .oom-table .sigma-warning {
            color: var(--accent-secondary);
        }

        .oom-table .sigma-high {
            color: #f87171;
        }

        .table-info {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }

        /* Loading state */
        .loading-state {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
        }

        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(139, 127, 255, 0.2);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error-message {
            background: rgba(255, 126, 182, 0.1);
            border: 1px solid rgba(255, 126, 182, 0.3);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            color: var(--accent-secondary);
        }

        /* No results message */
        .no-results {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        /* Navigation links */
        .nav-links {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-primary);
        }

        .nav-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background: rgba(139, 127, 255, 0.1);
            border: 1px solid rgba(139, 127, 255, 0.3);
            border-radius: 10px;
            color: var(--text-primary);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            background: rgba(139, 127, 255, 0.2);
            transform: translateY(-2px);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .parameter-grid {
                grid-template-columns: 1fr;
            }

            .filter-controls {
                grid-template-columns: 1fr;
            }

            .stats-bar {
                flex-direction: column;
            }
        }
    </style>
    <script src="../js/pm-constants-loader.js"></script>
</head>
<body class="auth-loading">
    <div id="main-content" style="display: none;">
    <!-- Header injected by pm-header.js -->

    <main>
        <nav aria-label="Breadcrumb" class="breadcrumb">
            <a href="../index.html">Home</a>
            <span class="separator">/</span>
            <span class="current">Theory Parameters</span>
        </nav>

        <!-- Hero Section -->
        <div class="parameters-hero">
            <h1>Theory Parameters</h1>
            <p>
                Complete reference of all theoretical parameters from Principia Metaphysica.
                Dynamically loaded from <code>theory_output.json</code> - includes registry, simulations, and formulas.
                <br><strong>Use Table View to sort by σ deviation and identify the weakest predictions.</strong>
            </p>
        </div>

        <!-- Methodology: Gate Classification Legend -->
        <div class="category-section" id="methodology-legend">
            <div class="category-header">
                <h2 class="category-title">Methodology: Gate Classification</h2>
                <span class="category-count">Transparency Disclosure</span>
            </div>
            <p style="color: var(--text-secondary); margin-bottom: 1.5rem; line-height: 1.7;">
                Principia Metaphysica employs a rigorous classification system for its 72 validation gates.
                In the interest of scientific transparency, we explicitly categorize each gate by its epistemic status.
                Approximately <strong>11% of gates (8 gates)</strong> use fitted or calibrated parameters,
                which is standard practice in theoretical physics model building.
            </p>

            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem; margin-bottom: 1.5rem;">
                <!-- RIGOROUS -->
                <div style="background: rgba(0, 200, 83, 0.08); border: 1px solid rgba(0, 200, 83, 0.3); border-radius: 12px; padding: 1.25rem;">
                    <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem;">
                        <span class="param-status-badge status-RIGOROUS">RIGOROUS</span>
                        <span style="color: var(--text-primary); font-weight: 600;">~25 gates (35%)</span>
                    </div>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin: 0;">
                        Pure mathematical results requiring no experimental input. Includes topological constraints,
                        group theory identities, and geometric necessities (e.g., b3 = 24 from G2 holonomy).
                    </p>
                </div>

                <!-- DERIVED -->
                <div style="background: rgba(139, 127, 255, 0.08); border: 1px solid rgba(139, 127, 255, 0.3); border-radius: 12px; padding: 1.25rem;">
                    <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem;">
                        <span class="param-status-badge status-DERIVED">DERIVED</span>
                        <span style="color: var(--text-primary); font-weight: 600;">~35 gates (49%)</span>
                    </div>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin: 0;">
                        Derived from PM geometry using established formulas. These follow from the framework
                        but require geometric interpretation (e.g., n_gen = chi_eff/48 = 3 generations).
                    </p>
                </div>

                <!-- FITTED -->
                <div style="background: rgba(255, 165, 0, 0.08); border: 1px solid rgba(255, 165, 0, 0.3); border-radius: 12px; padding: 1.25rem;">
                    <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem;">
                        <span class="param-status-badge status-FITTED">FITTED</span>
                        <span style="color: var(--text-primary); font-weight: 600;">~8 gates (11%)</span>
                    </div>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin: 0;">
                        Parameters calibrated to experimental data. <strong>Honestly acknowledged:</strong>
                        G18 (quark masses), G19 (lepton masses), G20 (CKM matrix), G22 (Higgs VEV),
                        G25 (top mass), G31 (CP violation), G43 (Hubble constant).
                    </p>
                </div>

                <!-- INPUT -->
                <div style="background: rgba(77, 182, 255, 0.08); border: 1px solid rgba(77, 182, 255, 0.3); border-radius: 12px; padding: 1.25rem;">
                    <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem;">
                        <span class="param-status-badge status-INPUT">INPUT</span>
                        <span style="color: var(--text-primary); font-weight: 600;">~3 gates (4%)</span>
                    </div>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin: 0;">
                        Direct experimental values used as anchors (e.g., G_N for Planck mass, beta decay data).
                        These set the overall scale but are not adjustable free parameters.
                    </p>
                </div>
            </div>

            <div style="background: rgba(255, 255, 255, 0.03); border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 8px; padding: 1rem; margin-top: 1rem;">
                <p style="color: var(--text-muted); font-size: 0.85rem; margin: 0; font-style: italic;">
                    <strong>Note on standard practice:</strong> All effective field theories require some fitted parameters.
                    The Standard Model has 19+ free parameters; PM reduces this to ~8 calibrated gates while deriving
                    the remaining ~64 from topology. The key metric is predictive power per free parameter,
                    not the absence of any calibration.
                </p>
            </div>
        </div>

        <!-- v23.1 Geometric Corrections -->
        <div class="category-section" id="v23-1-corrections" style="border: 2px solid rgba(81, 207, 102, 0.4); background: linear-gradient(135deg, rgba(81, 207, 102, 0.08), rgba(79, 172, 254, 0.05));">
            <div class="category-header">
                <h2 class="category-title">v23.1 Geometric Corrections</h2>
                <span class="category-count" style="background: rgba(81, 207, 102, 0.2); color: #51cf66;">NEW</span>
            </div>
            <p style="color: var(--text-secondary); margin-bottom: 1.5rem; line-height: 1.7;">
                Version 23.1 introduces geometric correction terms derived from G\(_2\) manifold curvature and flux quantization.
                These corrections dramatically improve agreement with experimental values:
            </p>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem; margin-bottom: 1rem;">
                <div style="background: rgba(81, 207, 102, 0.1); border: 1px solid rgba(81, 207, 102, 0.3); border-radius: 12px; padding: 1.25rem;">
                    <h4 style="color: #51cf66; margin: 0 0 0.75rem 0;">Fine Structure Constant \(\alpha^{-1}\)</h4>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin: 0 0 0.5rem 0;">
                        \[\alpha^{-1} = \text{tree} - \frac{7}{9963}\]
                    </p>
                    <p style="color: var(--text-muted); font-size: 0.85rem; margin: 0;">
                        \(\sigma\): 33,461 \(\to\) <strong style="color: #51cf66;">4.39</strong>
                    </p>
                </div>
                <div style="background: rgba(81, 207, 102, 0.1); border: 1px solid rgba(81, 207, 102, 0.3); border-radius: 12px; padding: 1.25rem;">
                    <h4 style="color: #51cf66; margin: 0 0 0.75rem 0;">Higgs VEV \(v\)</h4>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin: 0 0 0.5rem 0;">
                        \[v = \text{tree} \times \left(1 - \frac{1}{1728}\right)\]
                    </p>
                    <p style="color: var(--text-muted); font-size: 0.85rem; margin: 0;">
                        \(\sigma\): 0.29 \(\to\) <strong style="color: #51cf66;">0.007</strong>
                    </p>
                </div>
                <div style="background: rgba(81, 207, 102, 0.1); border: 1px solid rgba(81, 207, 102, 0.3); border-radius: 12px; padding: 1.25rem;">
                    <h4 style="color: #51cf66; margin: 0 0 0.75rem 0;">Weak Mixing Angle \(\sin^2\theta_W\)</h4>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin: 0 0 0.5rem 0;">
                        \[\sin^2\theta_W = \text{tree} - \frac{7}{9963}\]
                    </p>
                    <p style="color: var(--text-muted); font-size: 0.85rem; margin: 0;">
                        \(\sigma\): 17.37 \(\to\) <strong style="color: #51cf66;">0.20</strong>
                    </p>
                </div>
                <div style="background: rgba(81, 207, 102, 0.1); border: 1px solid rgba(81, 207, 102, 0.3); border-radius: 12px; padding: 1.25rem;">
                    <h4 style="color: #51cf66; margin: 0 0 0.75rem 0;">CMB Temperature \(T_{\text{CMB}}\)</h4>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin: 0 0 0.5rem 0;">
                        \[T_{\text{CMB}} = \text{tree} - \frac{\varphi}{144}\]
                    </p>
                    <p style="color: var(--text-muted); font-size: 0.85rem; margin: 0;">
                        \(\sigma\): 18.56 \(\to\) <strong style="color: #51cf66;">0.16</strong>
                    </p>
                </div>
            </div>
            <p style="color: var(--text-muted); font-size: 0.85rem; font-style: italic;">
                The correction factors 7/9963 and 1/1728 emerge from G\(_2\) manifold flux quantization.
                \(\varphi = 1.618...\) is the golden ratio; 144 = \(\chi_{\text{eff}}\) is the effective Euler characteristic.
            </p>
        </div>

        <!-- Statistics Bar -->
        <div class="stats-bar">
            <div class="stat-item">
                <span class="stat-value" id="stat-total">0</span>
                <span class="stat-label">Total Parameters</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="stat-visible">0</span>
                <span class="stat-label">Visible</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="stat-categories">0</span>
                <span class="stat-label">Categories</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="stat-validated">0</span>
                <span class="stat-label">Validated</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="stat-within-1sigma">0</span>
                <span class="stat-label">Within 1σ</span>
            </div>
        </div>

        <!-- View Toggle -->
        <div class="view-toggle">
            <button id="card-view-btn" class="view-btn active">Card View</button>
            <button id="table-view-btn" class="view-btn">Table View (OOM Gap)</button>
        </div>

        <!-- Filter Controls -->
        <div class="filter-controls">
            <div class="filter-group">
                <label for="search-input">Search</label>
                <input type="text" id="search-input" placeholder="Filter by name or description...">
            </div>
            <div class="filter-group">
                <label for="category-filter">Category</label>
                <select id="category-filter">
                    <option value="">All Categories</option>
                    <!-- Dynamically populated -->
                </select>
            </div>
            <div class="filter-group">
                <label for="status-filter">Status</label>
                <select id="status-filter">
                    <option value="">All Statuses</option>
                    <option value="RIGOROUS">Rigorous (Pure Math)</option>
                    <option value="DERIVED">Derived (From PM)</option>
                    <option value="FITTED">Fitted (Calibrated)</option>
                    <option value="INPUT">Input (Experimental)</option>
                    <option value="PREDICTED">Predicted</option>
                    <option value="MEASURED">Measured</option>
                    <option value="GEOMETRIC">Geometric</option>
                </select>
            </div>
        </div>

        <!-- Loading State -->
        <div id="loading-indicator" class="loading-state">
            <div class="loading-spinner"></div>
            <p>Loading all parameters from theory_output.json...</p>
        </div>

        <!-- Error State -->
        <div id="error-indicator" class="error-message" style="display: none;">
            <h3>Failed to Load Parameters</h3>
            <p id="error-message"></p>
        </div>

        <!-- Parameters Container (Card View) -->
        <div id="parameters-container" style="display: none;">
            <!-- Dynamically populated category sections -->
        </div>

        <!-- OOM Gap Table Container -->
        <div id="oom-table-container" class="oom-table-container">
            <p class="table-info">
                Sortable table showing all parameters with their sigma (σ) deviation from experiment.
                <strong>Click column headers to sort.</strong> Higher sigma = weaker prediction.
            </p>
            <table class="oom-table">
                <thead>
                    <tr>
                        <th data-sort="name">Parameter</th>
                        <th data-sort="category">Category</th>
                        <th data-sort="status">Status</th>
                        <th data-sort="sigma" class="sort-desc">σ Deviation</th>
                        <th data-sort="pctdiff">% Diff</th>
                        <th data-sort="computed">Computed</th>
                        <th data-sort="experimental">Experimental</th>
                        <th data-sort="units">Units</th>
                    </tr>
                </thead>
                <tbody id="oom-table-body">
                    <!-- Dynamically populated -->
                </tbody>
            </table>
        </div>

        <!-- No Results -->
        <div id="no-results" class="no-results" style="display: none;">
            <p>No parameters match your filter criteria.</p>
        </div>

        <!-- Navigation -->
        <div class="nav-links">
            <a class="nav-link" href="../index.html">← Back to Home</a>
            <a class="nav-link" href="formulas.html">View Formulas →</a>
        </div>
    </main>

    <footer>
        <p>
            <strong>Principia Metaphysica v23.1</strong><br/>
            © 2025-2026 Andrew Keith Watts. All rights reserved.
        </p>
    </footer>
    </div>

    <script type="module">
        import { injectHeader } from '../js/pm-header.js';
        import { setupAuthGuard } from '../js/auth-guard.js';

        // Inject header first
        document.addEventListener('DOMContentLoaded', () => {
            injectHeader('parameters');
        });

        // Setup auth after header
        setupAuthGuard('parameters');
    </script>

    <script>
        // ====================================================================
        // PARAMETERS PAGE - Dynamic Loading from parameters.json
        // ====================================================================

        console.log('%c[PARAMETERS] Script loaded', 'color: cyan; font-weight: bold; font-size: 14px');
        console.log('[PARAMETERS] Starting parameters page initialization...');

        let allParameters = [];
        let parametersByCategory = {};
        let formulaDatabase = {};

        // Configuration for parameter metadata
        const CATEGORY_DISPLAY_NAMES = {
            // Core Categories
            'dimensions': 'Spacetime Dimensions',
            'topology': 'G₂ Topology',
            'dark_energy': 'Dark Energy',
            'gauge': 'Gauge Unification',
            'electroweak': 'Electroweak Parameters',
            'yukawa': 'Yukawa Couplings',
            'fermion': 'Fermion Parameters',
            'fermion_masses': 'Fermion Masses',
            'ckm': 'CKM Mixing Matrix',
            'pmns': 'PMNS Mixing Angles',
            'neutrino': 'Neutrino Physics',
            'higgs': 'Higgs Sector',

            // Extended Physics
            'proton_decay': 'Proton Decay',
            'kk_spectrum': 'Kaluza-Klein Spectrum',
            'pneuma': 'Pneuma Field',
            'xy_bosons': 'X/Y Gauge Bosons',
            'mirror_sector': 'Mirror Sector',
            'cosmology': 'Cosmology',
            'thermal': 'Thermal Dynamics',
            'chirality': 'Chiral Structure',

            // Data Sources & References
            'constants': 'Physical Constants',
            'pdg': 'PDG Reference Values',
            'nufit': 'NuFIT Neutrino Data',
            'desi': 'DESI Cosmology Data',
            'bounds': 'Experimental Bounds',

            // Computational
            'simulations': 'Simulation Results',
            'formulas': 'Formula Validations',
            'nested_validations': 'Detailed Validations',
            'monte_carlo': 'Monte Carlo Studies',
            'landscape': 'Landscape Scans',
            'methods': 'Computational Methods',
            'math': 'Mathematical Framework',

            // Theory Structure
            'moduli': 'Moduli Parameters',
            'derivations': 'Theoretical Derivations',
            'predictions': 'Theory Predictions',
            'validation': 'Validation Statistics',
            'summary': 'Summary Statistics',
            'tables': 'Reference Tables',
            'consciousness': 'Consciousness Parameters',
            'gw_dispersion': 'Gravitational Wave Dispersion',

            // Fallback
            'uncategorized': 'Other Parameters'
        };

        const PARAMETER_SYMBOLS = {
            // Dimensions
            'D_BULK': 'D_{\\text{bulk}}',
            'D_AFTER_SP2R': 'D_{\\text{shadow}}',
            'D_INTERNAL': 'D_{\\text{int}}',
            'D_EFFECTIVE': 'D_{\\text{eff}}',
            'D_COMMON': 'D_{\\text{common}}',
            'M_PLANCK': 'M_{\\text{Pl}}',
            'M_BULK': 'M_{\\text{bulk}}',

            // Topology
            'CHI_EFF': '\\chi_{\\text{eff}}',
            'B2': 'b_2',
            'B3': 'b_3',
            'n_flux': 'N_{\\text{flux}}',
            'HODGE_H11': 'h^{1,1}',
            'HODGE_H21': 'h^{2,1}',
            'HODGE_H31': 'h^{3,1}',
            'n_gen': 'n_{\\text{gen}}',
            'chi_eff_computed': '\\chi_{\\text{eff}}^{\\text{comp}}',

            // Dark Energy
            'w0': 'w_0',
            'wa': 'w_a',
            'd_eff': 'd_{\\text{eff}}',
            'alpha_T': '\\alpha_T',

            // Gauge
            'ALPHA_GUT': '\\alpha_{\\text{GUT}}',
            'ALPHA_GUT_INV': '\\alpha_{\\text{GUT}}^{-1}',
            'M_GUT': 'M_{\\text{GUT}}',
            'WEAK_MIXING_ANGLE': '\\sin^2\\theta_W',
            'alpha_s': '\\alpha_s',

            // Proton Decay
            'tau_p_years': '\\tau_p',
            'BR_epi0': 'BR(e^+\\pi^0)',

            // PMNS
            'theta_12': '\\theta_{12}',
            'theta_23': '\\theta_{23}',
            'theta_13': '\\theta_{13}',
            'delta_CP': '\\delta_{CP}',
            'delta_cp': '\\delta_{CP}',  // lowercase variant

            // Neutrino
            'delta_m21_sq': '\\Delta m_{21}^2',
            'delta_m31_sq': '\\Delta m_{31}^2',
            'm_nu_1': 'm_{\\nu_1}',
            'm_nu_2': 'm_{\\nu_2}',
            'm_nu_3': 'm_{\\nu_3}',
            'sum_m_nu': '\\sum m_\\nu',
            'm_rh_neutrino': 'M_{\\text{RH}}',

            // KK Spectrum
            'm1_TeV': 'm_{\\text{KK}}',

            // Pneuma
            'VEV': '\\langle\\Psi_P\\rangle',

            // XY Bosons
            'M_X': 'M_X',
            'M_Y': 'M_Y',

            // Mirror Sector
            'temperature_ratio': 'T\'/T',
            'dm_baryon_ratio': '\\Omega_{\\text{DM}}/\\Omega_b',
            'modulation_width': '\\Delta_{\\text{mod}}',
            'n_sectors': 'N_{\\text{sectors}}',
            'gravity_dilution': 'f_{\\text{grav}}',

            // Higgs
            'mu': '\\mu',
            'lambda_H': '\\lambda_H',

            // Proton decay additional
            'SUPER_K_BOUND': '\\tau_p^{\\text{SK}}',
            'ratio_to_bound': '\\tau_p / \\tau_p^{\\text{SK}}',
            'suppression': 'f_{\\text{supp}}',

            // Neutrino additional
            'm_nu_1': 'm_{\\nu_1}',
            'm_nu_2': 'm_{\\nu_2}',
            'm_nu_3': 'm_{\\nu_3}',
            'sum_m_nu': '\\sum m_\\nu',
            'hierarchy': 'H_{\\nu}',

            // KK additional
            'uncertainty_TeV': '\\sigma_{m_{\\text{KK}}}',
            'LHC_BOUND_TEV': 'm_{\\text{KK}}^{\\text{LHC}}',

            // Other
            'D_SHARED_EXTRAS': 'D_{\\text{shared}}',
            'average_deviation_sigma': '\\langle\\sigma\\rangle',
            'source_version': '\\text{Version}'
        };

        const PARAMETER_DESCRIPTIONS = {
            // Dimensions
            'D_BULK': 'Bulk spacetime dimensions from bosonic string theory',
            'D_AFTER_SP2R': 'Per-shadow dimension (12D) after OR reduction in v23.1 dual-shadow decomposition',
            'D_INTERNAL': 'Internal G₂ manifold dimensions',
            'D_EFFECTIVE': 'Effective dimensions after compactification',
            'D_COMMON': 'Common observable spacetime dimensions',
            'M_PLANCK': 'Planck mass scale',
            'M_BULK': 'Bulk Planck mass',

            // Topology
            'CHI_EFF': 'Effective Euler characteristic of G₂ manifold #187',
            'B2': 'Second Betti number (number of 2-cycles)',
            'B3': 'Third Betti number (number of 3-cycles)',
            'n_flux': 'Flux quantization number',
            'n_gen': 'Number of fermion generations',

            // Dark Energy
            'w0': 'Dark energy equation of state parameter at z=0',
            'wa': 'Dark energy evolution parameter',
            'd_eff': 'Effective dimension for dark energy',
            'alpha_T': 'Temperature coupling parameter',

            // Gauge
            'ALPHA_GUT': 'GUT coupling constant α_GUT',
            'ALPHA_GUT_INV': 'Inverse GUT coupling 1/α_GUT ≈ 23.54',
            'M_GUT': 'GUT unification scale',
            'WEAK_MIXING_ANGLE': 'Weinberg angle sin²θ_W',
            'alpha_s': 'Strong coupling at M_Z',

            // Proton Decay
            'tau_p_years': 'Predicted proton lifetime',
            'BR_epi0': 'Branching ratio for p → e⁺π⁰',

            // PMNS
            'theta_12': 'Solar neutrino mixing angle',
            'theta_23': 'Atmospheric neutrino mixing angle',
            'theta_13': 'Reactor neutrino mixing angle',
            'delta_CP': 'CP-violating phase',

            // Neutrino
            'delta_m21_sq': 'Solar mass-squared difference',
            'delta_m31_sq': 'Atmospheric mass-squared difference',
            'sum_m_nu': 'Sum of neutrino masses',
            'm_rh_neutrino': 'Right-handed Majorana neutrino mass (seesaw)',
            'm_nu_1': 'Lightest neutrino mass eigenstate',
            'm_nu_2': 'Second neutrino mass eigenstate',
            'm_nu_3': 'Heaviest neutrino mass eigenstate',
            'hierarchy': 'Neutrino mass hierarchy',

            // KK
            'm1_TeV': 'First Kaluza-Klein excitation mass',
            'uncertainty_TeV': 'KK mass uncertainty',
            'LHC_BOUND_TEV': 'LHC experimental bound',

            // Pneuma
            'VEV': 'Pneuma field vacuum expectation value',

            // XY
            'M_X': 'X gauge boson mass',
            'M_Y': 'Y gauge boson mass',

            // Mirror
            'temperature_ratio': 'Mirror sector temperature ratio',
            'dm_baryon_ratio': 'Dark matter to baryon density ratio',
            'modulation_width': 'Geometric width from G₂ cycle overlap',
            'n_sectors': 'Number of mirror sectors',
            'gravity_dilution': 'Gravitational interaction dilution factor',

            // Proton Decay
            'SUPER_K_BOUND': 'Super-Kamiokande experimental lower bound',
            'ratio_to_bound': 'Ratio of prediction to experimental bound',
            'suppression': 'Proton decay suppression factor',

            // Higgs
            'mu': 'Higgs mass parameter',
            'lambda_H': 'Higgs quartic coupling',

            // Other
            'D_SHARED_EXTRAS': 'Shared extra dimensions',
            'SIGNATURE_INITIAL': 'Initial spacetime signature',
            'SIGNATURE_BULK': 'Bulk spacetime signature',
            'chi_eff_computed': 'Computed effective Euler characteristic',
            'average_deviation_sigma': 'Average deviation from experiment',
            'source_version': 'Reference data version'
        };

        // Initialize the page
        async function initializePage() {
            console.log('[PARAMETERS] Starting initialization...');
            try {
                // Load ALL data from theory_output.json
                console.log('[PARAMETERS] Loading data...');
                const theoryData = await loadTheoryOutputJSON();
                console.log('[PARAMETERS] Data loaded successfully:', theoryData);

                // Load formulas for cross-referencing
                console.log('[PARAMETERS] Loading formulas...');
                await loadFormulasJSON();

                // Process and organize ALL parameters
                console.log('[PARAMETERS] Processing parameters...');
                processAllParameters(theoryData);
                console.log(`[PARAMETERS] Processed ${allParameters.length} parameters in ${Object.keys(parametersByCategory).length} categories`);

                // Populate category filter
                console.log('[PARAMETERS] Populating category filter...');
                populateCategoryFilter();

                // Render the parameters
                console.log('[PARAMETERS] Rendering parameters...');
                renderParameters();

                // Render the OOM table
                console.log('[PARAMETERS] Rendering OOM table...');
                renderOOMTable();

                // Setup event listeners
                console.log('[PARAMETERS] Setting up event listeners...');
                setupEventListeners();

                // Setup view toggle
                console.log('[PARAMETERS] Setting up view toggle...');
                setupViewToggle();

                // Setup table sorting
                console.log('[PARAMETERS] Setting up table sorting...');
                setupTableSorting();

                // Update statistics
                console.log('[PARAMETERS] Updating statistics...');
                updateStatistics();

                // Hide loading, show content
                console.log('[PARAMETERS] Hiding loading indicator...');
                hideLoading();

                console.log('[PARAMETERS] ✓ Initialization complete!');
            } catch (error) {
                console.error('[PARAMETERS] ❌ Error initializing parameters page:', error);
                console.error('[PARAMETERS] Stack trace:', error.stack);
                showError(error.message + '\n\nCheck browser console for details.');
            }
        }

        async function loadTheoryOutputJSON() {
            const paths = [
                '../AutoGenerated/parameters.json',  // Try parameters.json first (this page is in Pages/)
                'AutoGenerated/parameters.json',
                '../AutoGenerated/theory_output.json',  // Fallback to theory_output
                'AutoGenerated/theory_output.json',
                'theory_output.json',
                '../theory_output.json'
            ];

            console.log('[PARAMETERS] Attempting to load from paths:', paths);

            for (const path of paths) {
                try {
                    console.log(`[PARAMETERS] Trying: ${path}`);
                    const response = await fetch(path);
                    console.log(`[PARAMETERS] Response status for ${path}: ${response.status}`);

                    if (response.ok) {
                        const data = await response.json();
                        console.log(`[PARAMETERS] ✓ Loaded data from ${path}`);
                        console.log(`[PARAMETERS]   Version: ${data.version}`);

                        // Handle both parameters.json and theory_output.json formats
                        if (data.parameters && !data.simulations) {
                            // This is parameters.json format - wrap it
                            console.log(`[PARAMETERS]   Format: parameters.json`);
                            console.log(`[PARAMETERS]   Parameters keys: ${Object.keys(data.parameters).length}`);
                            console.log(`[PARAMETERS]   Sample keys:`, Object.keys(data.parameters).slice(0, 10));
                            return {
                                version: data.version,
                                parameters: data.parameters,
                                simulations: {},
                                formulas: { formulas: {}, count: 0 },
                                framework_statistics: data.framework_statistics || {}
                            };
                        } else {
                            // This is theory_output.json format
                            console.log(`[PARAMETERS]   Format: theory_output.json`);
                            console.log(`[PARAMETERS]   Simulations: ${Object.keys(data.simulations || {}).length}`);
                            console.log(`[PARAMETERS]   Parameters: ${Object.keys(data.parameters || {}).length}`);
                            console.log(`[PARAMETERS]   Framework Stats: ${data.framework_statistics ? 'YES' : 'NO'}`);
                            return data;
                        }
                    }
                } catch (e) {
                    console.debug(`[PARAMETERS]   ✗ Failed to load ${path}: ${e.message}`);
                    continue;
                }
            }

            console.error('[PARAMETERS] ❌ Could not load data from any path!');
            throw new Error('Could not load parameters.json or theory_output.json. Please run: python run_all_simulations.py');
        }

        // Extract ALL parameters from theory_output.json
        function processAllParameters(theoryData) {
            console.log('[PARAMETERS] processAllParameters called with data:', theoryData);
            allParameters = [];
            parametersByCategory = {};

            // 1. Extract from parameters (primary source for parameters.json)
            if (theoryData.parameters) {
                console.log(`[PARAMETERS] Processing ${Object.keys(theoryData.parameters).length} parameter entries...`);
                for (const [fullKey, param] of Object.entries(theoryData.parameters)) {
                    // Split key like "constants.M_PLANCK" into category and key
                    const parts = fullKey.split('.');
                    const category = parts.length > 1 ? parts[0] : 'uncategorized';
                    const shortKey = parts.length > 1 ? parts[1] : fullKey;

                    if (!parametersByCategory[category]) {
                        parametersByCategory[category] = [];
                    }

                    // Extract value - handle both direct values and nested objects
                    let computedValue = param.value ?? param.computed ?? param.predicted ?? null;
                    if (typeof computedValue === 'object' && computedValue !== null && 'value' in computedValue) {
                        computedValue = computedValue.value;
                    }

                    // Get experimental value if available
                    let experimentalValue = param.experimental_value ?? param.experimental ?? null;
                    if (typeof experimentalValue === 'object' && experimentalValue !== null && 'value' in experimentalValue) {
                        experimentalValue = experimentalValue.value;
                    }

                    // Get units from metadata or direct field
                    let units = param.metadata?.units || param.units || '';
                    if (typeof param.experimental === 'object' && param.experimental?.units) {
                        units = param.experimental.units;
                    }

                    // Get uncertainty
                    let uncertainty = param.uncertainty ?? param.experimental_uncertainty ?? null;
                    if (typeof param.experimental === 'object' && param.experimental?.uncertainty) {
                        uncertainty = param.experimental.uncertainty;
                    }

                    // Get description from metadata or direct field
                    const description = param.metadata?.description || param.description || PARAMETER_DESCRIPTIONS[fullKey] || PARAMETER_DESCRIPTIONS[shortKey] || '';

                    const paramObj = {
                        key: fullKey,
                        displayName: formatParameterName(shortKey),
                        category,
                        status: param.status || 'DERIVED',
                        sigma: param.sigma_deviation ?? param.sigma ?? null,
                        value: computedValue,
                        computed: computedValue,
                        experimental: experimentalValue,
                        displayValue: formatValue(computedValue),
                        units: units,
                        uncertainty: uncertainty,
                        symbol: PARAMETER_SYMBOLS[fullKey] || PARAMETER_SYMBOLS[shortKey] || '',
                        description: description,
                        source: param.source || 'parameters'
                    };
                    allParameters.push(paramObj);
                    parametersByCategory[category].push(paramObj);
                }
            }

            // 2. Extract from framework_statistics.registry.parameters (if available)
            if (theoryData.framework_statistics?.registry?.parameters) {
                const registry = theoryData.framework_statistics.registry.parameters;
                for (const [key, param] of Object.entries(registry)) {
                    // Skip if already added from parameters
                    if (allParameters.find(p => p.key === key)) continue;

                    const category = param.category || 'uncategorized';
                    if (!parametersByCategory[category]) {
                        parametersByCategory[category] = [];
                    }

                    // Extract value - handle both direct values and nested objects
                    let computedValue = param.value ?? param.computed ?? param.predicted ?? null;
                    if (typeof computedValue === 'object' && computedValue !== null && 'value' in computedValue) {
                        computedValue = computedValue.value;
                    }

                    // Get experimental value if available
                    let experimentalValue = param.experimental_value ?? param.experimental ?? null;
                    if (typeof experimentalValue === 'object' && experimentalValue !== null && 'value' in experimentalValue) {
                        experimentalValue = experimentalValue.value;
                    }

                    // Get units
                    let units = param.units || '';
                    if (typeof param.experimental === 'object' && param.experimental?.units) {
                        units = param.experimental.units;
                    }

                    // Get uncertainty
                    let uncertainty = param.uncertainty ?? param.experimental_uncertainty ?? null;
                    if (typeof param.experimental === 'object' && param.experimental?.uncertainty) {
                        uncertainty = param.experimental.uncertainty;
                    }

                    const paramObj = {
                        key,
                        displayName: param.name || formatParameterName(key),
                        category,
                        status: param.status || 'DERIVED',
                        sigma: param.sigma_deviation ?? param.sigma ?? null,
                        value: computedValue,
                        computed: computedValue,
                        experimental: experimentalValue,
                        displayValue: formatValue(computedValue),
                        units: units,
                        uncertainty: uncertainty,
                        symbol: PARAMETER_SYMBOLS[key] || '',
                        description: PARAMETER_DESCRIPTIONS[key] || param.name || '',
                        source: 'registry'
                    };
                    allParameters.push(paramObj);
                    parametersByCategory[category].push(paramObj);
                }
            }

            // 3. Extract from simulations (35 simulations with validation data)
            if (theoryData.simulations) {
                for (const [simKey, sim] of Object.entries(theoryData.simulations)) {
                    // Skip error entries
                    if (sim.error) continue;

                    if (sim.validation) {
                        const category = 'simulations';
                        if (!parametersByCategory[category]) {
                            parametersByCategory[category] = [];
                        }

                        // Extract computed and experimental values
                        let computedValue = sim.validation.computed;
                        let experimentalValue = sim.validation.experimental ?? sim.validation.bound;

                        // Handle nested value objects
                        if (typeof computedValue === 'object' && computedValue !== null && 'value' in computedValue) {
                            computedValue = computedValue.value;
                        }
                        if (typeof experimentalValue === 'object' && experimentalValue !== null && 'value' in experimentalValue) {
                            experimentalValue = experimentalValue.value;
                        }

                        const paramObj = {
                            key: simKey,
                            displayName: formatParameterName(simKey),
                            category,
                            status: sim.status || 'CHECK',
                            sigma: sim.validation.sigma ?? null,
                            value: computedValue,
                            computed: computedValue,
                            experimental: experimentalValue,
                            displayValue: formatValue(computedValue),
                            units: sim.validation.units || '',
                            symbol: '',
                            description: sim.mechanism || sim.formula?.plain_text || '',
                            source: 'simulations'
                        };
                        allParameters.push(paramObj);
                        parametersByCategory[category].push(paramObj);
                    }

                    // Extract nested validation data (like neutrino_masses.validation)
                    extractNestedValidations(sim, simKey);
                }
            }

            // 4. Extract from formulas (computed vs experimental values)
            if (theoryData.formulas) {
                for (const [fKey, formula] of Object.entries(theoryData.formulas)) {
                    if (formula.computedValue !== undefined && formula.experimentalValue !== undefined) {
                        const category = 'formulas';
                        if (!parametersByCategory[category]) {
                            parametersByCategory[category] = [];
                        }

                        const paramObj = {
                            key: fKey,
                            displayName: formula.label || formatParameterName(fKey),
                            category,
                            status: formula.status || 'DERIVED',
                            sigma: formula.sigmaDeviation ?? null,
                            computed: formula.computedValue,
                            experimental: formula.experimentalValue,
                            units: formula.units || '',
                            symbol: '',
                            description: formula.description || '',
                            source: 'formulas'
                        };
                        allParameters.push(paramObj);
                        parametersByCategory[category].push(paramObj);
                    }
                }
            }

            console.log(`[PARAMETERS] ✓ Processed ${allParameters.length} total parameters across ${Object.keys(parametersByCategory).length} categories`);
            console.log('[PARAMETERS] Categories:', Object.keys(parametersByCategory));
            console.log('[PARAMETERS] Category counts:', Object.fromEntries(
                Object.entries(parametersByCategory).map(([cat, params]) => [cat, params.length])
            ));
        }

        function extractNestedValidations(obj, parentKey, depth = 0) {
            if (depth > 3 || typeof obj !== 'object' || obj === null) return;

            for (const [key, value] of Object.entries(obj)) {
                if (key === 'validation' && typeof value === 'object') {
                    // Skip if already processed as main validation
                    if (parentKey.includes('.')) continue;

                    // Check for nested validations like solar_splitting, atmospheric_splitting
                    for (const [subKey, subVal] of Object.entries(value)) {
                        if (typeof subVal === 'object' && subVal !== null && subVal.computed !== undefined) {
                            const category = 'nested_validations';
                            if (!parametersByCategory[category]) {
                                parametersByCategory[category] = [];
                            }

                            // Extract computed and experimental values
                            let computedValue = subVal.computed;
                            let experimentalValue = subVal.experimental ?? subVal.bound;

                            // Handle nested value objects
                            if (typeof computedValue === 'object' && computedValue !== null && 'value' in computedValue) {
                                computedValue = computedValue.value;
                            }
                            if (typeof experimentalValue === 'object' && experimentalValue !== null && 'value' in experimentalValue) {
                                experimentalValue = experimentalValue.value;
                            }

                            const fullKey = `${parentKey}.${subKey}`;
                            const paramObj = {
                                key: fullKey,
                                displayName: formatParameterName(subKey),
                                category,
                                status: subVal.status?.includes('PASS') ? 'PASS' : 'CHECK',
                                sigma: subVal.sigma ?? null,
                                value: computedValue,
                                computed: computedValue,
                                experimental: experimentalValue,
                                displayValue: formatValue(computedValue),
                                units: subVal.units || '',
                                symbol: '',
                                description: `From ${parentKey}`,
                                source: 'nested'
                            };
                            allParameters.push(paramObj);
                            parametersByCategory[category].push(paramObj);
                        }
                    }
                } else if (typeof value === 'object') {
                    extractNestedValidations(value, `${parentKey}.${key}`, depth + 1);
                }
            }
        }

        async function loadParametersJSON() {
            // Load parameters.json from AutoGenerated
            const paths = [
                '/AutoGenerated/parameters.json',     // Absolute path (for live site)
                'AutoGenerated/parameters.json',      // Relative from root
                './AutoGenerated/parameters.json',    // Explicit relative
                '../AutoGenerated/parameters.json',   // From subdirectory
                '../../AutoGenerated/parameters.json' // From nested subdirectory
            ];

            for (const path of paths) {
                try {
                    console.log(`Trying to load parameters from: ${path}`);
                    const response = await fetch(path);
                    if (response.ok) {
                        const data = await response.json();
                        console.log(`Successfully loaded parameters from ${path}`);
                        console.log(`Version: ${data.version}`);
                        return data;
                    }
                } catch (e) {
                    continue;
                }
            }

            throw new Error('Could not load AutoGenerated/parameters.json. Please run: python run_all_simulations.py --export');
        }

        async function loadFormulasJSON() {
            // Load formulas from theory_output.json (already loaded in main data)
            // This function now serves as a placeholder - formulas are in theoryData
            console.log('Formulas loaded from theory_output.json');
        }

        function processParameters(data) {
            allParameters = [];
            parametersByCategory = {};

            // Iterate through all categories in the JSON
            for (const [category, params] of Object.entries(data)) {
                if (category === 'version') continue;

                parametersByCategory[category] = [];

                // Handle nested parameters
                processCategory(category, params);
            }

            console.log(`Processed ${allParameters.length} parameters across ${Object.keys(parametersByCategory).length} categories`);
        }

        function processCategory(category, params, parentKey = '') {
            // Internal metadata fields that should NOT be displayed as parameters
            const SKIP_KEYS = ['metadata', 'timestamp', 'render', 'hidden', 'version', 'config_source', 'description'];

            for (const [key, value] of Object.entries(params)) {
                // Skip internal metadata keys
                if (SKIP_KEYS.includes(key)) {
                    continue;
                }

                // Skip if this is a standalone description field at category level
                if (key === 'description' && typeof value === 'string') {
                    continue;
                }

                // Skip date-only strings that look like timestamps
                if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(value)) {
                    continue;
                }

                // Skip count strings like "2 parameters"
                if (typeof value === 'string' && /^\d+\s+(parameter|item|field)s?$/i.test(value)) {
                    continue;
                }

                // Skip if explicitly marked as hidden or not to render
                if (typeof value === 'object' && value !== null) {
                    if (value.hidden === true || value.render === false) {
                        continue;
                    }
                }

                const fullKey = parentKey ? `${parentKey}.${key}` : key;

                // If value is a simple parameter (number, string) or has standard fields
                if (isParameter(value)) {
                    const param = createParameter(category, fullKey, value);
                    allParameters.push(param);
                    parametersByCategory[category].push(param);
                } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                    // Recursively process nested objects
                    processCategory(category, value, fullKey);
                }
            }
        }

        function isParameter(value) {
            // A parameter is either a primitive value or an object with specific fields
            if (typeof value !== 'object' || value === null) {
                return typeof value === 'number' || typeof value === 'string';
            }

            // Arrays are always parameters (like SIGNATURE_INITIAL)
            if (Array.isArray(value)) {
                return true;
            }

            // Check for render: false or hidden: true flags
            if (value.render === false || value.hidden === true) {
                return false; // Skip this parameter
            }

            // Check for common parameter field patterns
            const paramFields = ['value', 'predicted', 'experimental', 'units', 'status', 'description', 'derivation', 'source'];
            const hasParamField = paramFields.some(field => field in value);

            // If it has parameter fields, it's a parameter
            if (hasParamField) {
                return true;
            }

            // Check if all children are primitive values (like mass_spectrum with m_nu_1, m_nu_2, etc.)
            const values = Object.values(value);
            if (values.length > 0) {
                const allPrimitive = values.every(v =>
                    typeof v === 'number' ||
                    typeof v === 'string' ||
                    typeof v === 'boolean'
                );
                // If it has a mix of primitive values and metadata fields, treat as parameter group
                if (allPrimitive || (values.some(v => typeof v === 'number') && hasParamField)) {
                    return false; // This is a container, not a parameter
                }
            }

            return false;
        }

        function createParameter(category, key, value) {
            const displayName = formatParameterName(key);

            // Try full key first, then just the last part after the dot
            const keyParts = key.split('.');
            const lastKey = keyParts[keyParts.length - 1];
            const symbol = PARAMETER_SYMBOLS[key] || PARAMETER_SYMBOLS[lastKey] || '';

            let paramValue, units, status, description, experimental, predicted, uncertainty, derivation, source;
            let observed, observedUncertainty, deviationPercent, sigmaAgreement;
            let derivingFormulas = [];
            let sigma = null;
            let computed = null;

            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                // Extract primary value in order of preference
                paramValue = value.value ?? value.predicted ?? value.experimental ?? value.observed ?? null;

                // If no explicit value field and object has numeric properties, it might be a composite
                if (paramValue === null) {
                    // Check if this is a pure container (shouldn't happen but just in case)
                    paramValue = value;
                }

                units = value.units || '';
                status = value.status || 'DERIVED';
                description = value.description || value.derivation || PARAMETER_DESCRIPTIONS[key] || PARAMETER_DESCRIPTIONS[lastKey] || '';
                experimental = value.experimental ?? value.experimental_value;
                predicted = value.predicted;
                observed = value.observed;
                observedUncertainty = value.observed_uncertainty || value.experimental_error || value.experimental_uncertainty;
                uncertainty = value.predicted_error || value.experimental_error || value.uncertainty;
                derivation = value.derivation;
                source = value.source;
                deviationPercent = value.deviation_percent;
                sigmaAgreement = value.sigma_agreement;
                sigma = value.sigma_deviation ?? value.sigma ?? null;
                computed = value.value ?? value.predicted ?? null;

                // Extract metadata including deriving formulas
                if (value.metadata) {
                    if (value.metadata.deriving_formulas) {
                        derivingFormulas = value.metadata.deriving_formulas;
                    }
                    if (value.metadata.description && !description) {
                        description = value.metadata.description;
                    }
                    if (value.metadata.units && !units) {
                        units = value.metadata.units;
                    }
                }
            } else {
                // Primitive value (number, string, or array)
                paramValue = value;
                units = inferUnits(key);
                status = 'GEOMETRIC';
                description = PARAMETER_DESCRIPTIONS[key] || PARAMETER_DESCRIPTIONS[lastKey] || '';
            }

            return {
                category,
                key,
                displayName,
                symbol,
                value: paramValue,
                displayValue: formatValue(paramValue),
                units,
                status,
                description,
                experimental,
                predicted,
                observed,
                observedUncertainty,
                uncertainty,
                derivation,
                source,
                deviationPercent,
                sigmaAgreement,
                sigma,
                computed,
                relatedFormulas: findRelatedFormulas(key),
                derivingFormulas: derivingFormulas
            };
        }

        function formatParameterName(key) {
            // Handle dot notation - show full path for nested parameters
            const parts = key.split('.');

            if (parts.length > 1) {
                // For nested parameters, show the full path in a readable way
                return parts.map(part =>
                    part
                        .replace(/_/g, ' ')
                        .replace(/([A-Z])/g, ' $1')
                        .trim()
                        .split(' ')
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                        .join(' ')
                ).join(' → ');
            }

            // For top-level parameters, just format the name
            return key
                .replace(/_/g, ' ')
                .replace(/([A-Z])/g, ' $1')
                .trim()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatValue(value) {
            if (value === null || value === undefined) return '—';
            if (typeof value === 'boolean') return value ? 'Yes' : 'No';
            if (Array.isArray(value)) return value.map(v => escapeHtml(String(v))).join(', ');

            if (typeof value === 'number') {
                const abs = Math.abs(value);
                if (abs === 0) return '0';
                if (!isFinite(value)) return value.toString();

                // Use scientific notation for very large or very small numbers
                if (abs >= 1e6 || (abs < 0.001 && abs > 0)) {
                    const exp = value.toExponential(3);
                    // Format with proper superscript - remove leading + from exponent
                    return exp.replace(/e\+?(-?\d+)/, ' × 10<sup>$1</sup>');
                } else if (abs >= 1000) {
                    // Format with commas for thousands
                    return value.toLocaleString(undefined, { maximumFractionDigits: 4 });
                } else if (Number.isInteger(value)) {
                    return value.toLocaleString();
                } else {
                    // Use fixed precision for decimals
                    return value.toPrecision(4);
                }
            }

            return escapeHtml(String(value));
        }

        function inferUnits(key) {
            const unitPatterns = {
                '_TeV': 'TeV',
                '_GeV': 'GeV',
                '_eV': 'eV',
                '_years': 'years',
                'theta_': 'degrees',
                'delta_CP': 'degrees',
                'alpha_': 'dimensionless',
                'm_': 'GeV',
                'M_': 'GeV',
                'tau_': 'years'
            };

            for (const [pattern, unit] of Object.entries(unitPatterns)) {
                if (key.includes(pattern)) return unit;
            }

            return '';
        }

        function findRelatedFormulas(paramKey) {
            const related = [];
            const keyParts = paramKey.split('.');
            const lastKey = keyParts[keyParts.length - 1];

            for (const [formulaId, formula] of Object.entries(formulaDatabase)) {
                // Check if parameter appears in formula terms
                // Try both full key and last part
                if (formula.terms && (paramKey in formula.terms || lastKey in formula.terms)) {
                    related.push({
                        id: formulaId,
                        label: formula.label || formulaId,
                        section: formula.section
                    });
                }
            }

            return related;
        }

        function populateCategoryFilter() {
            const select = document.getElementById('category-filter');

            // Sort categories alphabetically by display name
            const categories = Object.keys(parametersByCategory).sort((a, b) => {
                const nameA = CATEGORY_DISPLAY_NAMES[a] || a;
                const nameB = CATEGORY_DISPLAY_NAMES[b] || b;
                return nameA.localeCompare(nameB);
            });

            for (const category of categories) {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = CATEGORY_DISPLAY_NAMES[category] || formatParameterName(category);
                select.appendChild(option);
            }

            console.log(`Populated category filter with ${categories.length} categories`);
        }

        function renderParameters() {
            console.log('[PARAMETERS] renderParameters called');
            const container = document.getElementById('parameters-container');
            if (!container) {
                console.error('[PARAMETERS] ❌ parameters-container element not found!');
                return;
            }

            container.innerHTML = '';
            let totalRendered = 0;

            // Render each category
            for (const [category, params] of Object.entries(parametersByCategory)) {
                if (params.length === 0) continue;

                console.log(`[PARAMETERS] Rendering category: ${category} (${params.length} parameters)`);
                const section = renderCategorySection(category, params);
                container.appendChild(section);
                totalRendered += params.length;
            }

            console.log(`[PARAMETERS] ✓ Rendered ${totalRendered} parameters in ${Object.keys(parametersByCategory).length} categories`);

            // Trigger MathJax rendering (with proper check for async loading)
            if (window.MathJax && typeof window.MathJax.typesetPromise === 'function') {
                console.log('[PARAMETERS] Triggering MathJax typeset...');
                MathJax.typesetPromise().then(() => {
                    console.log('[PARAMETERS] ✓ MathJax typeset complete');
                }).catch(err => {
                    console.warn('[PARAMETERS] MathJax typeset error:', err);
                });
            } else if (window.MathJax) {
                // MathJax is loading but typesetPromise not ready - wait and retry
                console.log('[PARAMETERS] MathJax loading, waiting for typesetPromise...');
                const checkMathJax = setInterval(() => {
                    if (typeof window.MathJax.typesetPromise === 'function') {
                        clearInterval(checkMathJax);
                        window.MathJax.typesetPromise().then(() => {
                            console.log('[PARAMETERS] ✓ MathJax typeset complete (delayed)');
                        }).catch(err => {
                            console.warn('[PARAMETERS] MathJax typeset error:', err);
                        });
                    }
                }, 100);
                // Clear after 5 seconds to prevent infinite loop
                setTimeout(() => clearInterval(checkMathJax), 5000);
            }
        }

        function renderCategorySection(category, params) {
            const section = document.createElement('div');
            section.className = 'category-section';
            section.dataset.category = category;

            const header = document.createElement('div');
            header.className = 'category-header';
            header.innerHTML = `
                <h2 class="category-title">${CATEGORY_DISPLAY_NAMES[category] || category}</h2>
                <span class="category-count">${params.length} parameters</span>
            `;
            section.appendChild(header);

            const grid = document.createElement('div');
            grid.className = 'parameter-grid';

            params.forEach(param => {
                const card = renderParameterCard(param);
                grid.appendChild(card);
            });

            section.appendChild(grid);
            return section;
        }

        function renderParameterCard(param) {
            const card = document.createElement('div');
            card.className = 'parameter-card';
            card.dataset.category = param.category;
            card.dataset.status = param.status;
            card.dataset.key = param.key;

            let html = `
                <div class="param-header">
                    <div class="param-name">${param.key}</div>
                    <span class="param-status-badge status-${param.status} tooltip">
                        ${param.status}
                        <span class="tooltip-content">
                            <span class="tooltip-label">Status: ${param.status}</span>
                            <span class="tooltip-value">${getStatusDescription(param.status)}</span>
                        </span>
                    </span>
                </div>
            `;

            if (param.symbol) {
                html += `<div class="param-symbol">$${param.symbol}$</div>`;
            }

            // Value display with tooltip
            const hasUncertainty = param.uncertainty !== null && param.uncertainty !== undefined;
            // Format units with superscripts
            const formattedUnits = param.units ? param.units.replace(/\^(-?\d+)/g, '<sup>$1</sup>').replace(/\*\*/g, '') : '';
            const unitsText = formattedUnits ? ` ${formattedUnits}` : '';
            const uncertaintyText = hasUncertainty ? `±${formatValue(param.uncertainty)}${unitsText}` : '';

            html += `
                <div class="param-value-display tooltip">
                    <span class="param-value">${param.displayValue}</span>
                    ${formattedUnits ? `<span class="param-units">${formattedUnits}</span>` : ''}
                    ${hasUncertainty ? `<span class="param-uncertainty">± ${formatValue(param.uncertainty)}</span>` : ''}
                    <span class="tooltip-content">
                        <span class="tooltip-label">Value</span>
                        <span class="tooltip-value">
                            ${param.displayValue}${unitsText}
                            ${uncertaintyText ? `<br>Uncertainty: ${uncertaintyText}` : ''}
                            ${param.source ? `<br>Source: ${escapeHtml(param.source)}` : ''}
                        </span>
                    </span>
                </div>
            `;

            if (param.description) {
                html += `<div class="param-description">${param.description}</div>`;
            }

            // Show comparison if both computed and experimental exist
            if ((param.computed !== undefined && param.computed !== null) &&
                (param.experimental !== undefined && param.experimental !== null)) {

                // Use provided sigma if available, otherwise calculate
                let deviation, deviationText;
                if (param.sigma !== undefined && param.sigma !== null) {
                    deviation = param.sigma;
                    deviationText = `${deviation.toFixed(2)}σ`;
                } else if (param.sigmaAgreement !== undefined) {
                    deviation = param.sigmaAgreement;
                    deviationText = `${deviation.toFixed(2)}σ`;
                } else if (param.deviationPercent !== undefined) {
                    deviation = param.deviationPercent / 10; // Rough estimate
                    deviationText = `${param.deviationPercent.toFixed(1)}% deviation`;
                } else {
                    // Simple calculation if no sigma provided
                    const diff = Math.abs(param.computed - param.experimental);
                    const avg = (Math.abs(param.computed) + Math.abs(param.experimental)) / 2;
                    deviation = avg > 0 ? diff / avg : 0;
                    deviationText = `${(deviation * 100).toFixed(1)}% difference`;
                }

                const deviationClass = deviation < 1 ? 'deviation-good' : deviation < 3 ? 'deviation-moderate' : 'deviation-high';

                html += `
                    <div class="param-comparison">
                        <div class="comparison-header">PM Prediction vs Experimental</div>
                        <div class="comparison-values">
                            <div class="comparison-item">
                                <span class="comparison-label">PM Computed</span>
                                <span class="comparison-value">${formatValue(param.computed)} ${formattedUnits}</span>
                            </div>
                            <div class="comparison-item">
                                <span class="comparison-label">Experimental</span>
                                <span class="comparison-value">${formatValue(param.experimental)} ${formattedUnits}</span>
                            </div>
                        </div>
                        <div class="deviation-indicator ${deviationClass}">
                            ${deviation < 1 ? '✓ Excellent (< 1σ)' : deviation < 2 ? '✓ Good (< 2σ)' : deviation < 3 ? '~ Moderate (< 3σ)' : '⚠ Weak (≥ 3σ)'} - ${deviationText}
                        </div>
                    </div>
                `;
            } else if (param.predicted !== undefined && param.predicted !== null &&
                       (param.experimental !== undefined && param.experimental !== null)) {
                // Fallback for old data structure with 'predicted' field
                const deviation = param.sigma ?? 0;
                const deviationClass = deviation < 1 ? 'deviation-good' : deviation < 3 ? 'deviation-moderate' : 'deviation-high';

                html += `
                    <div class="param-comparison">
                        <div class="comparison-header">PM Prediction vs Experimental</div>
                        <div class="comparison-values">
                            <div class="comparison-item">
                                <span class="comparison-label">Predicted</span>
                                <span class="comparison-value">${formatValue(param.predicted)} ${formattedUnits}</span>
                            </div>
                            <div class="comparison-item">
                                <span class="comparison-label">Experimental</span>
                                <span class="comparison-value">${formatValue(param.experimental)} ${formattedUnits}</span>
                            </div>
                        </div>
                        <div class="deviation-indicator ${deviationClass}">
                            ${deviation < 1 ? '✓ Excellent' : deviation < 3 ? '~ Good' : '⚠ Moderate'} (${deviation.toFixed(2)}σ)
                        </div>
                    </div>
                `;
            }

            // Metadata
            const metadata = [];
            if (param.derivation) metadata.push(`<span class="metadata-item"><span class="metadata-label">Derivation:</span> ${param.derivation}</span>`);
            if (param.source) metadata.push(`<span class="metadata-item"><span class="metadata-label">Source:</span> ${param.source}</span>`);

            if (metadata.length > 0) {
                html += `<div class="param-metadata">${metadata.join('')}</div>`;
            }

            // Deriving formulas - shows what formula derives this parameter
            if (param.derivingFormulas && param.derivingFormulas.length > 0) {
                html += `
                    <div class="deriving-formula">
                        <div class="formula-links-header">📐 Derived by:</div>
                        <div class="formula-link-list">
                            ${param.derivingFormulas.map(f =>
                                `<a href="formulas.html#${f.id}" class="formula-link deriving tooltip">
                                    ${f.label}
                                    <span class="tooltip-content">
                                        <span class="tooltip-label">${escapeHtml(f.description || 'Formula')}</span>
                                        <span class="tooltip-value">$${f.latex || ''}$<br>Click to view derivation</span>
                                    </span>
                                </a>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }

            // Related formulas with tooltips
            if (param.relatedFormulas && param.relatedFormulas.length > 0) {
                html += `
                    <div class="formula-links">
                        <div class="formula-links-header">Used in formulas:</div>
                        <div class="formula-link-list">
                            ${param.relatedFormulas.map(f =>
                                `<a href="formulas.html#${f.id}" class="formula-link tooltip">
                                    ${f.label}
                                    <span class="tooltip-content">
                                        <span class="tooltip-label">Formula: ${f.label}</span>
                                        <span class="tooltip-value">Section ${f.section || 'N/A'}<br>Click to view formula details</span>
                                    </span>
                                </a>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }

            card.innerHTML = html;
            return card;
        }

        /**
         * Get human-readable description for status badges
         */
        function getStatusDescription(status) {
            const descriptions = {
                'ESTABLISHED': 'Experimentally measured value from PDG/CODATA',
                'DERIVED': 'Derived from theory without calibration',
                'PREDICTED': 'Theoretical prediction awaiting experimental verification',
                'INPUT': 'Input parameter used in calculations',
                'MEASURED': 'Experimentally measured',
                'GEOMETRIC': 'Pure geometric result from G2 topology',
                'CALIBRATED': 'Calibrated to match experimental data',
                'PASS': 'Validation passed',
                'RESOLVED': 'Issue resolved',
                'CHECK': 'Requires verification',
                'PENDING': 'Awaiting confirmation',
                'SPECULATIVE': 'Speculative prediction',
                'COMPUTATIONAL': 'Computed using numerical methods',
                'FOUNDATIONAL': 'Fundamental theoretical input',
                'VALIDATED': 'Validated against experiment',
                'TABULATED': 'Listed in reference tables',
                'PHENOMENOLOGICAL': 'Phenomenologically constrained',
                'SYSTEM': 'System metadata (not a scientific parameter)'
            };
            return descriptions[status] || status;
        }

        /**
         * Check if a parameter should be excluded from scientific counts
         */
        function isSystemParameter(param) {
            return param?.status === 'SYSTEM' ||
                   param?.metadata?.is_scientific === false ||
                   param?.metadata?.display_in_params === false;
        }

        function calculateDeviation(predicted, experimental) {
            // Simple sigma calculation (would need uncertainty for proper calculation)
            const diff = Math.abs(predicted - experimental);
            const avg = (Math.abs(predicted) + Math.abs(experimental)) / 2;
            return avg > 0 ? (diff / avg) * 10 : 0; // Rough estimate
        }

        function setupEventListeners() {
            // Search
            document.getElementById('search-input').addEventListener('input', applyFilters);

            // Filters
            document.getElementById('category-filter').addEventListener('change', applyFilters);
            document.getElementById('status-filter').addEventListener('change', applyFilters);
        }

        function applyFilters() {
            const searchText = document.getElementById('search-input').value.toLowerCase();
            const categoryFilter = document.getElementById('category-filter').value;
            const statusFilter = document.getElementById('status-filter').value;

            // Filter cards in card view
            const cards = document.querySelectorAll('.parameter-card');
            let visibleCount = 0;

            cards.forEach(card => {
                const category = card.dataset.category;
                const status = card.dataset.status;
                const key = card.dataset.key;
                const param = allParameters.find(p => p.key === key && p.category === category);

                let visible = true;

                // Search filter
                if (searchText) {
                    const matchKey = key.toLowerCase().includes(searchText);
                    const matchDesc = param?.description?.toLowerCase().includes(searchText) || false;
                    const matchCategory = category.toLowerCase().includes(searchText);
                    const matchName = param?.displayName?.toLowerCase().includes(searchText) || false;
                    visible = visible && (matchKey || matchDesc || matchCategory || matchName);
                }

                // Category filter
                if (categoryFilter && category !== categoryFilter) {
                    visible = false;
                }

                // Status filter
                if (statusFilter && status !== statusFilter) {
                    visible = false;
                }

                if (visible) {
                    card.classList.remove('filtered-out');
                    visibleCount++;
                } else {
                    card.classList.add('filtered-out');
                }
            });

            // Filter table rows in table view
            const rows = document.querySelectorAll('#oom-table-body tr');
            let visibleRows = 0;

            rows.forEach(row => {
                const category = row.dataset.category;
                const status = row.dataset.status;
                const key = row.dataset.key;
                const param = allParameters.find(p => p.key === key && p.category === category);

                let visible = true;

                // Search filter
                if (searchText) {
                    const matchKey = key.toLowerCase().includes(searchText);
                    const matchDesc = param?.description?.toLowerCase().includes(searchText) || false;
                    const matchCategory = category.toLowerCase().includes(searchText);
                    const matchName = param?.displayName?.toLowerCase().includes(searchText) || false;
                    visible = visible && (matchKey || matchDesc || matchCategory || matchName);
                }

                // Category filter
                if (categoryFilter && category !== categoryFilter) {
                    visible = false;
                }

                // Status filter
                if (statusFilter && status !== statusFilter) {
                    visible = false;
                }

                if (visible) {
                    row.style.display = '';
                    visibleRows++;
                } else {
                    row.style.display = 'none';
                }
            });

            // Hide empty category sections in card view
            document.querySelectorAll('.category-section').forEach(section => {
                const visibleCards = section.querySelectorAll('.parameter-card:not(.filtered-out)');
                section.style.display = visibleCards.length > 0 ? 'block' : 'none';
            });

            // Update visible count (use card count or row count depending on active view)
            const isTableView = document.getElementById('oom-table-container').classList.contains('active');
            const displayCount = isTableView ? visibleRows : visibleCount;
            document.getElementById('stat-visible').textContent = displayCount;

            // Show/hide no results
            document.getElementById('no-results').style.display = displayCount === 0 ? 'block' : 'none';
        }

        // Render OOM Gap Table
        function renderOOMTable() {
            const tbody = document.getElementById('oom-table-body');
            tbody.innerHTML = '';

            // Filter parameters with both computed and experimental values (or sigma)
            const validParams = allParameters.filter(p =>
                (p.computed !== undefined && p.computed !== null) ||
                (p.experimental !== undefined && p.experimental !== null) ||
                (p.sigma !== null && p.sigma !== undefined)
            );

            // Sort by sigma descending (highest deviation first = weakest predictions)
            const sortedParams = [...validParams].sort((a, b) => {
                const sigmaA = a.sigma ?? -1;
                const sigmaB = b.sigma ?? -1;
                return sigmaB - sigmaA;
            });

            sortedParams.forEach(param => {
                const tr = document.createElement('tr');
                tr.dataset.key = param.key;
                tr.dataset.category = param.category;
                tr.dataset.status = param.status;

                const sigmaClass = getSigmaClass(param.sigma);
                const sigmaDisplay = param.sigma !== null && param.sigma !== undefined ? param.sigma.toFixed(2) : '—';

                // Use computed or value field
                const computedValue = param.computed ?? param.value;
                const computedDisplay = formatValue(computedValue);
                const expDisplay = formatValue(param.experimental);

                // Calculate % difference
                let pctDiff = null;
                let pctDiffDisplay = '—';
                if (computedValue !== null && computedValue !== undefined &&
                    param.experimental !== null && param.experimental !== undefined &&
                    param.experimental !== 0) {
                    pctDiff = Math.abs((computedValue - param.experimental) / param.experimental) * 100;
                    pctDiffDisplay = pctDiff < 0.01 ? '<0.01%' : pctDiff.toFixed(2) + '%';
                }
                param.pctdiff = pctDiff; // Store for sorting

                // Format units display
                const unitsDisplay = param.units || '—';

                tr.innerHTML = `
                    <td class="param-name-cell tooltip">
                        ${param.displayName || param.key}
                        <span class="tooltip-content">
                            <span class="tooltip-label">${param.displayName || param.key}</span>
                            <span class="tooltip-value">${param.description || 'No description available'}</span>
                        </span>
                    </td>
                    <td>${CATEGORY_DISPLAY_NAMES[param.category] || param.category}</td>
                    <td>
                        <span class="param-status-badge status-${param.status} tooltip">
                            ${param.status}
                            <span class="tooltip-content">
                                <span class="tooltip-label">Status: ${param.status}</span>
                                <span class="tooltip-value">${getStatusDescription(param.status)}</span>
                            </span>
                        </span>
                    </td>
                    <td class="sigma-cell ${sigmaClass} tooltip">
                        ${sigmaDisplay}
                        ${param.sigma !== null && param.sigma !== undefined ? `
                            <span class="tooltip-content">
                                <span class="tooltip-label">Sigma Deviation</span>
                                <span class="tooltip-value">
                                    ${param.sigma.toFixed(3)}σ from experiment<br>
                                    ${param.sigma < 1 ? 'Excellent agreement (&lt;1σ)' :
                                      param.sigma < 2 ? 'Good agreement (&lt;2σ)' :
                                      param.sigma < 3 ? 'Moderate agreement (&lt;3σ)' :
                                      'Weak agreement (≥3σ)'}
                                </span>
                            </span>
                        ` : ''}
                    </td>
                    <td class="pctdiff-cell ${pctDiff !== null && pctDiff < 1 ? 'sigma-good' : pctDiff !== null && pctDiff < 5 ? 'sigma-moderate' : ''} tooltip">
                        ${pctDiffDisplay}
                        ${pctDiff !== null ? `
                            <span class="tooltip-content">
                                <span class="tooltip-label">Percentage Difference</span>
                                <span class="tooltip-value">
                                    ${pctDiff.toFixed(4)}% from experiment<br>
                                    ${pctDiff < 0.1 ? 'Excellent (&lt;0.1%)' :
                                      pctDiff < 1 ? 'Good (&lt;1%)' :
                                      pctDiff < 5 ? 'Moderate (&lt;5%)' :
                                      'Large (≥5%)'}
                                </span>
                            </span>
                        ` : ''}
                    </td>
                    <td class="tooltip">
                        ${computedDisplay}
                        ${computedValue !== null && computedValue !== undefined ? `
                            <span class="tooltip-content">
                                <span class="tooltip-label">Computed Value</span>
                                <span class="tooltip-value">${computedDisplay}${param.units ? ' ' + param.units : ''}</span>
                            </span>
                        ` : ''}
                    </td>
                    <td class="tooltip">
                        ${expDisplay}
                        ${param.experimental !== null && param.experimental !== undefined ? `
                            <span class="tooltip-content">
                                <span class="tooltip-label">Experimental Value</span>
                                <span class="tooltip-value">${expDisplay}${param.units ? ' ' + param.units : ''}</span>
                            </span>
                        ` : ''}
                    </td>
                    <td>${unitsDisplay}</td>
                `;
                tbody.appendChild(tr);
            });

            console.log(`Rendered OOM table with ${sortedParams.length} parameters (filtered from ${allParameters.length} total)`);
        }

        function getSigmaClass(sigma) {
            if (sigma === null || sigma === undefined) return '';
            if (sigma < 1) return 'sigma-good';
            if (sigma < 2) return 'sigma-moderate';
            if (sigma < 3) return 'sigma-warning';
            return 'sigma-high';
        }

        // View Toggle
        function setupViewToggle() {
            const cardViewBtn = document.getElementById('card-view-btn');
            const tableViewBtn = document.getElementById('table-view-btn');
            const cardContainer = document.getElementById('parameters-container');
            const tableContainer = document.getElementById('oom-table-container');

            cardViewBtn.addEventListener('click', () => {
                cardViewBtn.classList.add('active');
                tableViewBtn.classList.remove('active');
                cardContainer.style.display = 'block';
                tableContainer.classList.remove('active');
            });

            tableViewBtn.addEventListener('click', () => {
                tableViewBtn.classList.add('active');
                cardViewBtn.classList.remove('active');
                cardContainer.style.display = 'none';
                tableContainer.classList.add('active');
            });
        }

        // Table Sorting
        let currentSort = { column: 'sigma', direction: 'desc' };

        function setupTableSorting() {
            const headers = document.querySelectorAll('.oom-table th[data-sort]');
            headers.forEach(th => {
                th.addEventListener('click', () => {
                    const column = th.dataset.sort;

                    // Toggle direction if same column
                    if (currentSort.column === column) {
                        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentSort.column = column;
                        currentSort.direction = 'desc';
                    }

                    // Update header classes
                    headers.forEach(h => h.classList.remove('sort-asc', 'sort-desc'));
                    th.classList.add(`sort-${currentSort.direction}`);

                    // Sort the table
                    sortTable();
                });
            });
        }

        function parseNumericValue(text) {
            // Handle scientific notation like "1.234 × 10^16" or "1.234e16"
            const scientificMatch = text.match(/([-+]?\d+\.?\d*)\s*[×x]\s*10\s*(?:<sup>)?([-+]?\d+)(?:<\/sup>)?/i);
            if (scientificMatch) {
                const mantissa = parseFloat(scientificMatch[1]);
                const exponent = parseInt(scientificMatch[2]);
                return mantissa * Math.pow(10, exponent);
            }

            // Handle regular exponential notation
            const expMatch = text.match(/([-+]?\d+\.?\d*)\s*e\s*([-+]?\d+)/i);
            if (expMatch) {
                return parseFloat(text);
            }

            // Handle regular numbers with commas
            const cleanText = text.replace(/,/g, '');
            const num = parseFloat(cleanText);
            return isNaN(num) ? 0 : num;
        }

        function sortTable() {
            const tbody = document.getElementById('oom-table-body');
            const rows = Array.from(tbody.querySelectorAll('tr'));

            rows.sort((a, b) => {
                let valA, valB;

                switch (currentSort.column) {
                    case 'name':
                        valA = a.dataset.key.toLowerCase();
                        valB = b.dataset.key.toLowerCase();
                        break;
                    case 'category':
                        valA = a.dataset.category.toLowerCase();
                        valB = b.dataset.category.toLowerCase();
                        break;
                    case 'status':
                        valA = a.cells[2].textContent.trim().toLowerCase();
                        valB = b.cells[2].textContent.trim().toLowerCase();
                        break;
                    case 'sigma':
                        valA = parseNumericValue(a.cells[3].textContent);
                        if (valA === 0 && a.cells[3].textContent.includes('—')) valA = -1;
                        valB = parseNumericValue(b.cells[3].textContent);
                        if (valB === 0 && b.cells[3].textContent.includes('—')) valB = -1;
                        break;
                    case 'pctdiff':
                        valA = parseNumericValue(a.cells[4].textContent);
                        if (a.cells[4].textContent.includes('—')) valA = -1;
                        valB = parseNumericValue(b.cells[4].textContent);
                        if (b.cells[4].textContent.includes('—')) valB = -1;
                        break;
                    case 'computed':
                        valA = parseNumericValue(a.cells[5].textContent);
                        if (a.cells[5].textContent.includes('—')) valA = -Infinity;
                        valB = parseNumericValue(b.cells[5].textContent);
                        if (b.cells[5].textContent.includes('—')) valB = -Infinity;
                        break;
                    case 'experimental':
                        valA = parseNumericValue(a.cells[6].textContent);
                        if (a.cells[6].textContent.includes('—')) valA = -Infinity;
                        valB = parseNumericValue(b.cells[6].textContent);
                        if (b.cells[6].textContent.includes('—')) valB = -Infinity;
                        break;
                    default:
                        valA = a.cells[7] ? a.cells[7].textContent.trim() : '';
                        valB = b.cells[7] ? b.cells[7].textContent.trim() : '';
                }

                if (typeof valA === 'string') {
                    return currentSort.direction === 'asc'
                        ? valA.localeCompare(valB)
                        : valB.localeCompare(valA);
                } else {
                    return currentSort.direction === 'asc'
                        ? valA - valB
                        : valB - valA;
                }
            });

            rows.forEach(row => tbody.appendChild(row));
        }

        function updateStatistics() {
            const total = allParameters.length;
            const categories = Object.keys(parametersByCategory).length;
            const validated = allParameters.filter(p =>
                p.experimental !== undefined ||
                p.observed !== undefined ||
                p.sigma !== null ||
                p.status === 'MEASURED' ||
                p.status === 'INPUT'
            ).length;
            const within1sigma = allParameters.filter(p => p.sigma !== null && p.sigma < 1).length;

            console.log(`[PARAMETERS] Updating statistics: total=${total}, categories=${categories}, validated=${validated}, within1σ=${within1sigma}`);

            document.getElementById('stat-total').textContent = total;
            document.getElementById('stat-visible').textContent = total;
            document.getElementById('stat-categories').textContent = categories;
            document.getElementById('stat-validated').textContent = validated;
            document.getElementById('stat-within-1sigma').textContent = within1sigma;
        }

        function hideLoading() {
            console.log('[PARAMETERS] hideLoading called');
            const loadingIndicator = document.getElementById('loading-indicator');
            const parametersContainer = document.getElementById('parameters-container');

            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
                console.log('[PARAMETERS] ✓ Hidden loading indicator');
            } else {
                console.warn('[PARAMETERS] ⚠ loading-indicator element not found');
            }

            if (parametersContainer) {
                parametersContainer.style.display = 'block';
                console.log('[PARAMETERS] ✓ Shown parameters container');
            } else {
                console.warn('[PARAMETERS] ⚠ parameters-container element not found');
            }
        }

        function showError(message) {
            document.getElementById('loading-indicator').style.display = 'none';
            document.getElementById('error-indicator').style.display = 'block';
            document.getElementById('error-message').textContent = message;
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('[PARAMETERS] DOM loaded, starting initialization...');
                initializePage();
            });
        } else {
            console.log('[PARAMETERS] DOM already loaded, starting initialization immediately...');
            initializePage();
        }

        // Fallback: ensure main content is visible after 2 seconds if auth guard fails
        setTimeout(() => {
            const mainContent = document.getElementById('main-content');
            if (mainContent && mainContent.style.display === 'none') {
                console.warn('[PARAMETERS] Auth guard timeout - forcing content visible');
                mainContent.style.display = 'block';
                document.body.classList.remove('auth-loading');
            }
        }, 2000);
    </script>
</body>
</html>
