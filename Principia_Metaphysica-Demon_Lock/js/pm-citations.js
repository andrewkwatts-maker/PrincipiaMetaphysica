/**
 * pm-citations.js
 * Dynamic citation system for Principia Metaphysica
 * Loads references from AutoGenerated/references.json
 *
 * Usage: <cite data-ref="polchinski1998"></cite>
 *
 * Copyright (c) 2025 Andrew Keith Watts. All rights reserved.
 */

(function() {
    'use strict';

    let referencesData = null;
    let citationCounter = 1;
    const citationMap = new Map(); // Maps ref ID to citation number

    /**
     * Load references from JSON file
     */
    async function loadReferences() {
        try {
            const response = await fetch('/AutoGenerated/references.json');
            if (!response.ok) {
                throw new Error(`Failed to load references: ${response.status}`);
            }
            referencesData = await response.json();
            console.log('References loaded successfully:', Object.keys(referencesData).length, 'references');
            return referencesData;
        } catch (error) {
            console.error('Error loading references:', error);
            return null;
        }
    }

    /**
     * Format author names for citation
     * Examples: "Smith, J." -> "Smith"
     *           "Smith, J., Jones, K." -> "Smith et al."
     */
    function formatAuthors(authors) {
        if (!authors) return 'Unknown';

        const authorList = authors.split(',').map(a => a.trim());
        if (authorList.length === 0) return 'Unknown';

        // Get first author's last name
        const firstAuthor = authorList[0];
        const lastNameMatch = firstAuthor.match(/^([^,]+)/);
        const lastName = lastNameMatch ? lastNameMatch[1].trim() : firstAuthor;

        if (authorList.length === 1) {
            return lastName;
        } else if (authorList.length === 2) {
            const secondAuthor = authorList[1];
            const secondLastNameMatch = secondAuthor.match(/^([^,]+)/);
            const secondLastName = secondLastNameMatch ? secondLastNameMatch[1].trim() : secondAuthor;
            return `${lastName} & ${secondLastName}`;
        } else {
            return `${lastName} et al.`;
        }
    }

    /**
     * Create formatted citation text
     */
    function createCitationText(refId, ref, citationNum) {
        const authors = formatAuthors(ref.authors);
        return `[${citationNum}]`;
    }

    /**
     * Create tooltip content for citation
     */
    function createTooltipContent(ref) {
        let html = `<div class="citation-tooltip">`;
        html += `<div class="citation-title">${ref.title || 'No title'}</div>`;
        html += `<div class="citation-authors">${ref.authors || 'Unknown authors'}</div>`;

        if (ref.year) {
            html += `<div class="citation-year">${ref.year}</div>`;
        }

        if (ref.arxiv) {
            html += `<div class="citation-link">arXiv: ${ref.arxiv}</div>`;
        }

        if (ref.doi) {
            html += `<div class="citation-link">DOI: ${ref.doi}</div>`;
        }

        if (ref.description) {
            html += `<div class="citation-desc">${ref.description}</div>`;
        }

        html += `</div>`;
        return html;
    }

    /**
     * Process all citation elements on the page
     */
    function processCitations() {
        if (!referencesData) {
            console.warn('References not loaded yet');
            return;
        }

        const citeElements = document.querySelectorAll('cite[data-ref]');

        citeElements.forEach(cite => {
            const refId = cite.getAttribute('data-ref');

            if (!refId) {
                console.warn('Citation element missing data-ref attribute:', cite);
                return;
            }

            const ref = referencesData[refId];

            if (!ref) {
                console.warn(`Reference not found: ${refId}`);
                cite.textContent = `[?]`;
                cite.classList.add('citation-missing');
                cite.title = `Reference not found: ${refId}`;
                return;
            }

            // Assign citation number if not already assigned
            if (!citationMap.has(refId)) {
                citationMap.set(refId, citationCounter++);
            }

            const citationNum = citationMap.get(refId);

            // Create citation link
            const citationText = createCitationText(refId, ref, citationNum);
            cite.innerHTML = citationText;
            cite.classList.add('citation');
            cite.setAttribute('data-citation-num', citationNum);

            // Store reference data for tooltip
            cite._refData = ref;

            // Add hover listeners
            cite.addEventListener('mouseenter', (e) => showCitationTooltip(e, ref));
            cite.addEventListener('mouseleave', removeCitationTooltip);

            // Add click handler to scroll to references
            cite.style.cursor = 'pointer';
            cite.addEventListener('click', () => scrollToReferences(refId));
        });

        console.log(`Processed ${citeElements.length} citations`);
    }

    /**
     * Show citation tooltip
     */
    function showCitationTooltip(event, ref) {
        removeCitationTooltip();

        const tooltip = document.createElement('div');
        tooltip.className = 'pm-citation-tooltip';
        tooltip.innerHTML = createTooltipContent(ref);

        // Position tooltip near cursor
        const x = event.pageX || event.clientX + window.scrollX;
        const y = event.pageY || event.clientY + window.scrollY;

        tooltip.style.position = 'absolute';
        tooltip.style.left = (x + 10) + 'px';
        tooltip.style.top = (y + 10) + 'px';
        tooltip.style.zIndex = '10000';

        document.body.appendChild(tooltip);

        // Adjust position if tooltip goes off screen
        const rect = tooltip.getBoundingClientRect();
        if (rect.right > window.innerWidth) {
            tooltip.style.left = (x - rect.width - 10) + 'px';
        }
        if (rect.bottom > window.innerHeight) {
            tooltip.style.top = (y - rect.height - 10) + 'px';
        }
    }

    /**
     * Remove citation tooltip
     */
    function removeCitationTooltip() {
        const existing = document.querySelector('.pm-citation-tooltip');
        if (existing) {
            existing.remove();
        }
    }

    /**
     * Scroll to references section and highlight the reference
     */
    function scrollToReferences(refId) {
        // Try to find the reference element in the references section
        const refElement = document.getElementById(`ref-${refId}`);

        if (refElement) {
            refElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // Highlight effect
            refElement.classList.add('reference-highlight');
            setTimeout(() => {
                refElement.classList.remove('reference-highlight');
            }, 2000);
        } else {
            // If we're not on the references page, navigate to it
            window.location.href = `/references.html#ref-${refId}`;
        }
    }

    /**
     * Generate references list for the references page
     */
    function generateReferencesList(containerId = 'references-container') {
        if (!referencesData) {
            console.warn('References not loaded yet');
            return;
        }

        const container = document.getElementById(containerId);
        if (!container) {
            return; // Not on references page
        }

        // Sort references by citation number
        const sortedRefs = Array.from(citationMap.entries())
            .sort((a, b) => a[1] - b[1])
            .map(([refId, num]) => ({ refId, num, ref: referencesData[refId] }));

        let html = '<div class="references-list">';

        sortedRefs.forEach(({ refId, num, ref }) => {
            html += `<div class="ref-item" id="ref-${refId}">`;
            html += `<span class="ref-number">[${num}]</span>`;
            html += `<div class="ref-content">`;
            html += `<div class="ref-title">${ref.title || 'No title'}</div>`;
            html += `<div class="ref-authors">${ref.authors || 'Unknown authors'}</div>`;

            if (ref.year) {
                html += `<div class="ref-year">(${ref.year})</div>`;
            }

            if (ref.description) {
                html += `<div class="ref-description">${ref.description}</div>`;
            }

            html += `<div class="ref-links">`;
            if (ref.arxiv) {
                html += `<a href="https://arxiv.org/abs/${ref.arxiv}" target="_blank">arXiv:${ref.arxiv}</a>`;
            }
            if (ref.doi) {
                html += `<a href="https://doi.org/${ref.doi}" target="_blank">DOI:${ref.doi}</a>`;
            }
            html += `</div></div></div>`;
        });

        html += '</div>';
        container.innerHTML = html;
    }

    /**
     * Initialize citation system
     */
    async function initCitations() {
        await loadReferences();

        if (referencesData) {
            processCitations();

            // Generate references list if on references page
            generateReferencesList();
        }
    }

    /**
     * Re-process citations (useful for dynamically loaded content)
     */
    function refreshCitations() {
        processCitations();
    }

    // Auto-initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initCitations);
    } else {
        initCitations();
    }

    // Expose public API
    window.PMCitations = {
        init: initCitations,
        refresh: refreshCitations,
        loadReferences: loadReferences,
        getCitationMap: () => citationMap,
        getReferencesData: () => referencesData
    };

})();
