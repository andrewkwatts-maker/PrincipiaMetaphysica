#!/usr/bin/env python3
"""
PRINCIPIA METAPHYSICA - Simulations Index Generator
====================================================

Auto-generates simulations-index.json by scanning simulations directory.

For each Python script, extracts:
- Filename and path
- Version number (e.g., v15_0 -> 15.0)
- Docstring (first line as description)
- Status from docstring if available (CORE, PREDICTION, VALIDATED, etc.)
- Category from directory structure

Outputs to: AutoGenerated/simulations-index.json

Copyright (c) 2025 Andrew Keith Watts. All rights reserved.

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.

Dedicated To:
    My Wife: Elizabeth May Watts
    Our Messiah: Jesus Of Nazareth
"""

import os
import re
import json
import sys
from pathlib import Path
from datetime import datetime, timezone
from typing import Dict, List, Any, Optional

# Root directory
ROOT_DIR = Path(__file__).parent.parent.parent
SIMULATIONS_DIR = ROOT_DIR / "simulations"
OUTPUT_FILE = ROOT_DIR / "AutoGenerated" / "simulations-index.json"

# Ensure AutoGenerated directory exists
OUTPUT_FILE.parent.mkdir(exist_ok=True)

# Version from theory_output.json if available
VERSION = "16.2"
try:
    theory_output_path = ROOT_DIR / "AutoGenerated" / "theory_output.json"
    if theory_output_path.exists():
        with open(theory_output_path, 'r', encoding='utf-8') as f:
            theory_data = json.load(f)
            VERSION = theory_data.get("version", VERSION)
except Exception:
    pass


def extract_version_from_filename(filename: str) -> Optional[str]:
    """Extract version from filename like 'script_v15_0.py' -> '15.0'"""
    match = re.search(r'_v(\d+)_(\d+)\.py$', filename)
    if match:
        return f"{match.group(1)}.{match.group(2)}"

    match = re.search(r'_v(\d+)\.py$', filename)
    if match:
        return f"{match.group(1)}.0"

    return None


def extract_docstring_info(file_path: Path) -> Dict[str, Any]:
    """Extract description and status from Python docstring"""
    info = {
        "description": None,
        "status": None,
        "title": None
    }

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read(2000)  # Read first 2000 chars

            # Extract docstring
            docstring_match = re.search(r'"""(.+?)"""', content, re.DOTALL)
            if not docstring_match:
                docstring_match = re.search(r"'''(.+?)'''", content, re.DOTALL)

            if docstring_match:
                docstring = docstring_match.group(1).strip()
                lines = [line.strip() for line in docstring.split('\n') if line.strip()]

                # Extract title (first substantial line, often after "PRINCIPIA METAPHYSICA")
                for line in lines:
                    if line.startswith('PRINCIPIA METAPHYSICA'):
                        # Title is typically after the dash
                        if ' - ' in line:
                            info['title'] = line.split(' - ', 1)[1].strip()
                            break

                # Extract description (look for single-line summary)
                for line in lines:
                    # Skip header lines, separator lines, copyright
                    if any([
                        line.startswith('='),
                        line.startswith('-'),
                        line.startswith('PRINCIPIA'),
                        line.lower().startswith('copyright'),
                        line.lower().startswith('version'),
                        line.lower().startswith('v1'),
                        len(line) < 15  # Too short to be descriptive
                    ]):
                        continue

                    # First substantial line is the description
                    if not info['description'] and len(line) > 15:
                        info['description'] = line
                        break

                # Extract status keywords
                docstring_upper = docstring.upper()
                if 'STATUS: CORE' in docstring_upper or 'CORE VALIDATION' in docstring_upper:
                    info['status'] = 'CORE'
                elif 'STATUS: PREDICTION' in docstring_upper or 'TESTABLE PREDICTION' in docstring_upper:
                    info['status'] = 'PREDICTION'
                elif 'STATUS: VALIDATED' in docstring_upper or 'EXPERIMENTAL VALIDATION' in docstring_upper:
                    info['status'] = 'VALIDATED'
                elif 'STATUS: GEOMETRIC' in docstring_upper or 'GEOMETRIC DERIVATION' in docstring_upper:
                    info['status'] = 'GEOMETRIC'

    except Exception as e:
        print(f"Warning: Could not read {file_path}: {e}")

    return info


def categorize_by_path(rel_path: str) -> str:
    """Determine category from file path - uses folder structure directly"""
    parts = Path(rel_path).parts

    # Handle v16 structure - use folder name directly as category
    # (e.g., v16/gauge/gauge_unification_v16_0.py -> "v16/gauge")
    if len(parts) >= 2 and parts[0] == 'v16':
        subdir = parts[1].lower()
        # Return v16/subfolder as the category (folder structure defines category)
        return f"v16/{subdir}"

    if len(parts) > 1:
        subdir = parts[0].lower()

        # Map subdirectories to categories
        category_map = {
            'deprecated': 'Deprecated',
            'adhoc': 'Ad-Hoc / Experimental',
            'validation': 'Validation',
            'constants': 'Constants & Utilities',
            'core': 'Core Physics',
            'base': 'Constants & Utilities',
            'data': 'Constants & Utilities',
            'derivations': 'Constants & Utilities',
            'reports': 'Constants & Utilities',
            'tests': 'Validation',
            'ip': 'Constants & Utilities'
        }

        return category_map.get(subdir, 'Ad-Hoc / Experimental')

    # Check filename for category hints
    filename_lower = Path(rel_path).name.lower()

    if any(word in filename_lower for word in ['gauge', 'gut', 'alpha']):
        return 'Gauge Unification'
    elif any(word in filename_lower for word in ['neutrino', 'pmns']):
        return 'Neutrino Physics'
    elif any(word in filename_lower for word in ['g2', 'metric', 'ricci', 'geometry']):
        return 'G2 Geometry'
    elif any(word in filename_lower for word in ['microtubule', 'quantum', 'biological']):
        return 'Quantum Biology'
    elif any(word in filename_lower for word in ['cosmology', 'dark', 'wz']):
        return 'Cosmology'
    elif any(word in filename_lower for word in ['moduli', 'flux', 'stabilization']):
        return 'Moduli Stabilization'
    elif any(word in filename_lower for word in ['yukawa', 'fermion', 'higgs']):
        return 'Yukawa & Fermion Masses'
    elif any(word in filename_lower for word in ['proton', 'decay']):
        return 'Proton Decay'
    elif any(word in filename_lower for word in ['kk', 'kaluza']):
        return 'KK Spectrum'

    return 'Ad-Hoc / Experimental'


# Cache for folder info.json files
_folder_info_cache: Dict[str, Dict] = {}


def load_folder_info(folder_path: Path) -> Optional[Dict]:
    """Load info.json from a folder if it exists."""
    cache_key = str(folder_path)
    if cache_key in _folder_info_cache:
        return _folder_info_cache[cache_key]

    info_file = folder_path / "info.json"
    if info_file.exists():
        try:
            with open(info_file, 'r', encoding='utf-8') as f:
                info = json.load(f)
                _folder_info_cache[cache_key] = info
                return info
        except Exception as e:
            print(f"Warning: Could not load {info_file}: {e}")

    return None


def generate_category_title(category: str) -> str:
    """Generate human-readable title for category from info.json or fallback."""
    # Try to load from info.json for v16 categories
    if category.startswith('v16/'):
        folder_name = category.replace('v16/', '')
        folder_path = SIMULATIONS_DIR / 'v16' / folder_name
        info = load_folder_info(folder_path)
        if info and 'title' in info:
            return info['title']
        # Fallback: capitalize folder name
        return folder_name.replace('_', ' ').title()

    # For other categories, just return as-is
    return category


def get_category_description(category: str) -> str:
    """Get description for category from info.json or fallback."""
    # Try to load from info.json for v16 categories
    if category.startswith('v16/'):
        folder_name = category.replace('v16/', '')
        folder_path = SIMULATIONS_DIR / 'v16' / folder_name
        info = load_folder_info(folder_path)
        if info and 'description' in info:
            return info['description']
        return ''  # No fallback for v16 - description comes from info.json

    # Fallback descriptions for non-v16 categories
    fallback_descriptions = {
        'Ad-Hoc / Experimental': 'Experimental and ad-hoc simulation scripts',
        'Constants & Utilities': 'Configuration, constants, and utility modules',
        'Validation': 'Validation and testing scripts'
    }
    return fallback_descriptions.get(category, '')


def get_category_order(category: str) -> int:
    """Get sort order for category from info.json or fallback."""
    # Try to load from info.json for v16 categories
    if category.startswith('v16/'):
        folder_name = category.replace('v16/', '')
        folder_path = SIMULATIONS_DIR / 'v16' / folder_name
        info = load_folder_info(folder_path)
        if info and 'order' in info:
            return info['order']
        return 50  # Default order for v16 without info.json

    # Fallback order for non-v16 categories
    fallback_order = {
        'G2 Geometry': 10,
        'Neutrino Physics': 11,
        'Quantum Biology': 12,
        'Ad-Hoc / Experimental': 90,
        'Constants & Utilities': 91,
        'Validation': 92,
        'Deprecated': 99
    }
    return fallback_order.get(category, 50)


def get_category_section_id(category: str) -> Optional[str]:
    """Get paper section ID for category from info.json."""
    if category.startswith('v16/'):
        folder_name = category.replace('v16/', '')
        folder_path = SIMULATIONS_DIR / 'v16' / folder_name
        info = load_folder_info(folder_path)
        if info and 'sectionId' in info:
            return info['sectionId']
    return None


def scan_simulations_directory() -> Dict[str, Any]:
    """Scan simulations directory and build index"""

    index_data = {
        "version": VERSION,
        "generated": datetime.now(timezone.utc).isoformat().replace('+00:00', 'Z'),
        "total_scripts": 0,
        "categories": {}
    }

    # Find all Python files in simulations directory
    all_scripts = []

    for py_file in SIMULATIONS_DIR.rglob("*.py"):
        # Skip __init__.py and files in __pycache__
        if py_file.name.startswith('__') or '__pycache__' in str(py_file):
            continue

        rel_path = py_file.relative_to(SIMULATIONS_DIR)

        # Extract metadata
        version = extract_version_from_filename(py_file.name)
        docstring_info = extract_docstring_info(py_file)
        category = categorize_by_path(str(rel_path))

        script_info = {
            "file": py_file.name,
            "path": f"simulations/{rel_path}".replace('\\', '/'),
            "version": version,
            "title": docstring_info.get('title'),
            "description": docstring_info.get('description') or "Physics simulation module",
            "status": docstring_info.get('status'),
            "category": category
        }

        all_scripts.append(script_info)

    # Group by category
    categories = {}
    for script in all_scripts:
        cat = script['category']
        if cat not in categories:
            # Determine folder path based on category
            if cat.startswith('v16/'):
                folder_path = f"simulations/{cat}"
            else:
                folder_path = "simulations/"

            categories[cat] = {
                "title": generate_category_title(cat),
                "path": folder_path,
                "folderName": cat.replace('v16/', '') if cat.startswith('v16/') else cat,
                "description": get_category_description(cat),
                "isV16": cat.startswith('v16/'),
                "order": get_category_order(cat),
                "sectionId": get_category_section_id(cat),
                "scripts": [],
                "count": 0
            }

        categories[cat]['scripts'].append({
            "file": script['file'],
            "path": script['path'],
            "version": script['version'],
            "title": script['title'],
            "description": script['description'],
            "status": script['status']
        })
        categories[cat]['count'] += 1

    # Sort scripts within each category by version (descending)
    for cat_data in categories.values():
        cat_data['scripts'].sort(
            key=lambda s: (
                -float(s['version']) if s['version'] else 0,
                s['file']
            )
        )

    index_data['categories'] = categories
    index_data['total_scripts'] = len(all_scripts)

    return index_data


def main():
    """Main entry point"""
    print("=" * 60)
    print("PRINCIPIA METAPHYSICA - Simulations Index Generator")
    print("=" * 60)
    print(f"\nScanning directory: {SIMULATIONS_DIR}")
    print(f"Output file: {OUTPUT_FILE}\n")

    # Generate index
    index_data = scan_simulations_directory()

    # Write to file
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        json.dump(index_data, f, indent=2, ensure_ascii=False)

    # Print summary
    print(f"[OK] Generated index with {index_data['total_scripts']} scripts")
    print(f"[OK] Organized into {len(index_data['categories'])} categories:\n")

    for cat_name, cat_data in sorted(index_data['categories'].items()):
        print(f"  - {cat_data['title']}: {cat_data['count']} scripts")

    print(f"\n[OK] Saved to: {OUTPUT_FILE}")
    print("\nDone!")


if __name__ == "__main__":
    main()
