#!/usr/bin/env python3
"""
Principia Metaphysica - Theory Output Validator
================================================

Validates theory_output.json for:
1. Unique IDs (formulas, parameters, references)
2. Bi-directional reference integrity
3. Required metadata completeness
4. Input/output parameter linkage
5. Reference citation completeness
6. Section-formula-parameter linkage

Generates detailed reports for automated fixing.

Copyright (c) 2025 Andrew Keith Watts. All rights reserved.

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.

Dedicated To:
    My Wife: Elizabeth May Watts
    Our Messiah: Jesus Of Nazareth
"""

import json
import os
from dataclasses import dataclass, field, asdict
from typing import Dict, List, Set, Optional, Any
from collections import defaultdict
from pathlib import Path

# Output directories
AUTO_GEN_DIR = Path("AutoGenerated")
REPORTS_DIR = AUTO_GEN_DIR / "reports"
JSON_DIR = AUTO_GEN_DIR


@dataclass
class ValidationIssue:
    """Single validation issue."""
    severity: str  # ERROR, WARNING, INFO
    category: str  # unique_ids, bi_directional, metadata, linkage
    entity_type: str  # formula, parameter, reference, section
    entity_id: str
    message: str
    suggested_fix: str = ""
    auto_fixable: bool = False


@dataclass
class ValidationReport:
    """Complete validation report."""
    timestamp: str = ""
    total_formulas: int = 0
    total_parameters: int = 0
    total_references: int = 0
    total_sections: int = 0

    errors: List[ValidationIssue] = field(default_factory=list)
    warnings: List[ValidationIssue] = field(default_factory=list)
    info: List[ValidationIssue] = field(default_factory=list)

    passed: bool = True
    summary: Dict[str, int] = field(default_factory=dict)


class TheoryValidator:
    """Validates theory_output.json for completeness and consistency."""

    REQUIRED_FORMULA_FIELDS = [
        'id', 'label', 'html', 'category', 'description'
    ]

    RECOMMENDED_FORMULA_FIELDS = [
        'latex', 'plainText', 'section', 'status', 'terms',
        'computedValue', 'units', 'simulationFile'
    ]

    REQUIRED_PARAM_FIELDS = [
        'id', 'value', 'units', 'symbol'
    ]

    RECOMMENDED_PARAM_FIELDS = [
        'title', 'description', 'oom', 'status',
        'experimentalValue', 'experimentalError', 'sigmaDeviation'
    ]

    def __init__(self, theory_file: str = "theory_output.json"):
        self.theory_file = theory_file
        self.data: Dict[str, Any] = {}
        self.report = ValidationReport()

        # Index structures for validation
        self.formula_ids: Set[str] = set()
        self.param_ids: Set[str] = set()
        self.reference_ids: Set[str] = set()
        self.section_ids: Set[str] = set()

        # Track references
        self.formula_to_params: Dict[str, Set[str]] = defaultdict(set)
        self.param_to_formulas: Dict[str, Set[str]] = defaultdict(set)
        self.formula_to_refs: Dict[str, Set[str]] = defaultdict(set)
        self.ref_to_formulas: Dict[str, Set[str]] = defaultdict(set)

    def load(self) -> bool:
        """Load theory_output.json."""
        try:
            with open(self.theory_file, 'r', encoding='utf-8') as f:
                self.data = json.load(f)
            return True
        except Exception as e:
            self.report.errors.append(ValidationIssue(
                severity="ERROR",
                category="file",
                entity_type="file",
                entity_id=self.theory_file,
                message=f"Failed to load: {e}"
            ))
            return False

    def validate_all(self) -> ValidationReport:
        """Run all validations."""
        from datetime import datetime
        self.report.timestamp = datetime.now().isoformat()

        if not self.load():
            self.report.passed = False
            return self.report

        # Index all entities
        self._index_formulas()
        self._index_parameters()
        self._index_references()
        self._index_sections()

        # Run validations
        self._validate_unique_ids()
        self._validate_formula_metadata()
        self._validate_param_metadata()
        self._validate_bi_directional_refs()
        self._validate_orphan_references()
        self._validate_orphan_params()
        self._validate_formula_param_linkage()
        self._validate_simulation_files()

        # Compute summary
        self.report.total_formulas = len(self.formula_ids)
        self.report.total_parameters = len(self.param_ids)
        self.report.total_references = len(self.reference_ids)
        self.report.total_sections = len(self.section_ids)

        self.report.summary = {
            "errors": len(self.report.errors),
            "warnings": len(self.report.warnings),
            "info": len(self.report.info)
        }

        self.report.passed = len(self.report.errors) == 0

        return self.report

    def _index_formulas(self):
        """Index all formula IDs."""
        formulas = self.data.get('formulas', {}).get('formulas', {})
        for fid, formula in formulas.items():
            self.formula_ids.add(fid)

            # Track param references in formulas
            if 'terms' in formula:
                for term_key in formula['terms']:
                    # Term keys are often param symbols
                    self.formula_to_params[fid].add(term_key)

            # Track input/output params if present
            for param_id in formula.get('inputParams', []):
                self.formula_to_params[fid].add(param_id)
                self.param_to_formulas[param_id].add(fid)
            for param_id in formula.get('outputParams', []):
                self.formula_to_params[fid].add(param_id)
                self.param_to_formulas[param_id].add(fid)

            # Track references
            for ref in formula.get('references', []):
                ref_id = ref.get('id', '')
                if ref_id:
                    self.formula_to_refs[fid].add(ref_id)
                    self.ref_to_formulas[ref_id].add(fid)
                    self.reference_ids.add(ref_id)

    def _index_parameters(self):
        """Index all parameter IDs."""
        params = self.data.get('parameters', {})
        for category, category_params in params.items():
            if isinstance(category_params, dict):
                for pid, param in category_params.items():
                    if isinstance(param, dict):
                        self.param_ids.add(pid)

        # Also check simulations for output params
        simulations = self.data.get('simulations', {})
        for sim_name, sim_data in simulations.items():
            if isinstance(sim_data, dict):
                for key in sim_data.keys():
                    # These are effectively output parameters
                    param_id = f"{sim_name}.{key}"
                    self.param_ids.add(param_id)

    def _index_references(self):
        """Index all reference IDs from formulas."""
        # References are embedded in formulas, already indexed above
        pass

    def _index_sections(self):
        """Index all section IDs."""
        sections = self.data.get('sections', {})
        for sid in sections:
            self.section_ids.add(sid)

    def _is_valid_param_path(self, param_id: str) -> bool:
        """Check if param_id is a valid dotted path in parameters or simulations."""
        if '.' not in param_id:
            return False
        parts = param_id.split('.')

        # First check parameters section (category.param_name format)
        parameters = self.data.get('parameters', {})
        if len(parts) >= 2:
            category = parts[0]
            param_name = parts[1]
            if category in parameters:
                cat_params = parameters[category]
                if isinstance(cat_params, dict) and param_name in cat_params:
                    return True

        # Then check simulations section
        simulations = self.data.get('simulations', {})
        current = simulations
        for part in parts:
            if isinstance(current, dict) and part in current:
                current = current[part]
            else:
                return False
        return True

    def _validate_unique_ids(self):
        """Check for duplicate IDs."""
        # Check formula ID duplicates
        formulas = self.data.get('formulas', {}).get('formulas', {})
        seen_ids = set()
        for fid in formulas:
            if fid in seen_ids:
                self.report.errors.append(ValidationIssue(
                    severity="ERROR",
                    category="unique_ids",
                    entity_type="formula",
                    entity_id=fid,
                    message=f"Duplicate formula ID: {fid}",
                    suggested_fix=f"Rename one of the formulas with ID '{fid}'",
                    auto_fixable=False
                ))
            seen_ids.add(fid)

    def _validate_formula_metadata(self):
        """Check formula metadata completeness."""
        formulas = self.data.get('formulas', {}).get('formulas', {})

        for fid, formula in formulas.items():
            # Check required fields
            for field in self.REQUIRED_FORMULA_FIELDS:
                if field not in formula or not formula[field]:
                    self.report.errors.append(ValidationIssue(
                        severity="ERROR",
                        category="metadata",
                        entity_type="formula",
                        entity_id=fid,
                        message=f"Missing required field: {field}",
                        suggested_fix=f"Add '{field}' to formula '{fid}' in config.py",
                        auto_fixable=False
                    ))

            # Check recommended fields
            for field in self.RECOMMENDED_FORMULA_FIELDS:
                if field not in formula or formula[field] is None:
                    self.report.warnings.append(ValidationIssue(
                        severity="WARNING",
                        category="metadata",
                        entity_type="formula",
                        entity_id=fid,
                        message=f"Missing recommended field: {field}",
                        suggested_fix=f"Consider adding '{field}' to formula '{fid}'"
                    ))

            # Check for experimental validation data
            if formula.get('category') in ['PREDICTIONS', 'DERIVED']:
                if 'experimentalValue' not in formula and 'sigmaDeviation' not in formula:
                    self.report.info.append(ValidationIssue(
                        severity="INFO",
                        category="metadata",
                        entity_type="formula",
                        entity_id=fid,
                        message="No experimental validation data",
                        suggested_fix="Add experimentalValue and sigmaDeviation if available"
                    ))

            # Check input/output params are present and valid
            input_params = formula.get('inputParams', [])
            output_params = formula.get('outputParams', [])

            if not input_params and not output_params:
                self.report.warnings.append(ValidationIssue(
                    severity="WARNING",
                    category="linkage",
                    entity_type="formula",
                    entity_id=fid,
                    message="Missing both inputParams and outputParams",
                    suggested_fix="Run extract_and_link.py to populate param links",
                    auto_fixable=True
                ))

            # Validate input params reference valid entities
            for param_id in input_params:
                if param_id not in self.param_ids and not self._is_valid_param_path(param_id):
                    self.report.warnings.append(ValidationIssue(
                        severity="WARNING",
                        category="linkage",
                        entity_type="formula",
                        entity_id=fid,
                        message=f"inputParam '{param_id}' not found in parameters",
                        suggested_fix=f"Add parameter '{param_id}' or remove from inputParams"
                    ))

            # Validate output params reference valid entities
            for param_id in output_params:
                if param_id not in self.param_ids and param_id != fid and not self._is_valid_param_path(param_id):
                    self.report.warnings.append(ValidationIssue(
                        severity="WARNING",
                        category="linkage",
                        entity_type="formula",
                        entity_id=fid,
                        message=f"outputParam '{param_id}' not found in parameters",
                        suggested_fix=f"Add parameter '{param_id}' or remove from outputParams"
                    ))

    def _validate_param_metadata(self):
        """Check parameter metadata completeness."""
        params = self.data.get('parameters', {})

        for category, category_params in params.items():
            if not isinstance(category_params, dict):
                continue
            for pid, param in category_params.items():
                if not isinstance(param, dict):
                    continue

                # Check for OOM (order of magnitude)
                if 'oom' not in param:
                    value = param.get('value', 0)
                    if isinstance(value, (int, float)) and value != 0:
                        import math
                        suggested_oom = int(math.log10(abs(value)))
                        self.report.warnings.append(ValidationIssue(
                            severity="WARNING",
                            category="metadata",
                            entity_type="parameter",
                            entity_id=pid,
                            message="Missing OOM (order of magnitude)",
                            suggested_fix=f"Add oom={suggested_oom} to parameter '{pid}'",
                            auto_fixable=True
                        ))

    def _validate_bi_directional_refs(self):
        """Check bi-directional reference integrity."""
        formulas = self.data.get('formulas', {}).get('formulas', {})

        for fid, formula in formulas.items():
            # Check related_formulas
            for related_id in formula.get('relatedFormulas', []):
                if related_id not in self.formula_ids:
                    self.report.warnings.append(ValidationIssue(
                        severity="WARNING",
                        category="bi_directional",
                        entity_type="formula",
                        entity_id=fid,
                        message=f"Related formula '{related_id}' not found",
                        suggested_fix=f"Remove '{related_id}' from relatedFormulas or add the formula"
                    ))
                else:
                    # Check reverse reference
                    related_formula = formulas.get(related_id, {})
                    related_refs = related_formula.get('relatedFormulas', [])
                    if fid not in related_refs:
                        self.report.info.append(ValidationIssue(
                            severity="INFO",
                            category="bi_directional",
                            entity_type="formula",
                            entity_id=fid,
                            message=f"One-way relation: '{fid}' -> '{related_id}'",
                            suggested_fix=f"Add '{fid}' to relatedFormulas of '{related_id}'",
                            auto_fixable=True
                        ))

    def _validate_orphan_references(self):
        """Check for references not cited by any formula."""
        # All references should be cited somewhere
        for ref_id in self.reference_ids:
            if ref_id not in self.ref_to_formulas or len(self.ref_to_formulas[ref_id]) == 0:
                self.report.warnings.append(ValidationIssue(
                    severity="WARNING",
                    category="linkage",
                    entity_type="reference",
                    entity_id=ref_id,
                    message="Reference not cited by any formula",
                    suggested_fix="Remove orphan reference or add citation"
                ))

    def _validate_orphan_params(self):
        """Check for parameters not used by any formula."""
        # Build set of params actually used in formulas
        used_params = set()
        for formula_params in self.formula_to_params.values():
            used_params.update(formula_params)

        # This is informational - many params are computed outputs
        # We'll just track the count
        orphan_count = 0
        for pid in self.param_ids:
            if pid not in used_params and '.' not in pid:  # Skip simulation outputs
                orphan_count += 1

        if orphan_count > 0:
            self.report.info.append(ValidationIssue(
                severity="INFO",
                category="linkage",
                entity_type="parameter",
                entity_id="SUMMARY",
                message=f"{orphan_count} parameters not referenced in formula terms"
            ))

    def _validate_formula_param_linkage(self):
        """Check that formulas have input/output param lists."""
        formulas = self.data.get('formulas', {}).get('formulas', {})

        missing_input_params = 0
        missing_output_params = 0

        for fid, formula in formulas.items():
            if 'inputParams' not in formula:
                missing_input_params += 1
            if 'outputParams' not in formula:
                missing_output_params += 1

        if missing_input_params > 0:
            self.report.warnings.append(ValidationIssue(
                severity="WARNING",
                category="linkage",
                entity_type="formula",
                entity_id="SUMMARY",
                message=f"{missing_input_params} formulas missing inputParams",
                suggested_fix="Run extract_formula_params.py to auto-populate",
                auto_fixable=True
            ))

        if missing_output_params > 0:
            self.report.warnings.append(ValidationIssue(
                severity="WARNING",
                category="linkage",
                entity_type="formula",
                entity_id="SUMMARY",
                message=f"{missing_output_params} formulas missing outputParams",
                suggested_fix="Run extract_formula_params.py to auto-populate",
                auto_fixable=True
            ))

    def _validate_simulation_files(self):
        """Check that simulation files exist."""
        formulas = self.data.get('formulas', {}).get('formulas', {})

        for fid, formula in formulas.items():
            sim_file = formula.get('simulationFile', '')
            if sim_file:
                if not os.path.exists(sim_file):
                    self.report.errors.append(ValidationIssue(
                        severity="ERROR",
                        category="linkage",
                        entity_type="formula",
                        entity_id=fid,
                        message=f"Simulation file not found: {sim_file}",
                        suggested_fix=f"Create file or update simulationFile path"
                    ))

    def save_reports(self):
        """Save validation reports to AutoGenerated/reports/."""
        REPORTS_DIR.mkdir(parents=True, exist_ok=True)

        # Main validation summary
        summary_file = REPORTS_DIR / "validation_summary.json"
        with open(summary_file, 'w', encoding='utf-8') as f:
            json.dump({
                "timestamp": self.report.timestamp,
                "passed": self.report.passed,
                "totals": {
                    "formulas": self.report.total_formulas,
                    "parameters": self.report.total_parameters,
                    "references": self.report.total_references,
                    "sections": self.report.total_sections
                },
                "issues": self.report.summary,
                "errors": [asdict(e) for e in self.report.errors],
                "warnings": [asdict(w) for w in self.report.warnings],
                "info": [asdict(i) for i in self.report.info]
            }, f, indent=2)

        # Separate reports by category
        categories = defaultdict(list)
        for issue in self.report.errors + self.report.warnings:
            categories[issue.category].append(asdict(issue))

        for category, issues in categories.items():
            cat_file = REPORTS_DIR / f"{category}_issues.json"
            with open(cat_file, 'w', encoding='utf-8') as f:
                json.dump(issues, f, indent=2)

        # Auto-fixable issues
        auto_fixable = [
            asdict(i) for i in self.report.errors + self.report.warnings + self.report.info
            if i.auto_fixable
        ]
        if auto_fixable:
            fix_file = REPORTS_DIR / "auto_fixable.json"
            with open(fix_file, 'w', encoding='utf-8') as f:
                json.dump(auto_fixable, f, indent=2)

        print(f"\nReports saved to {REPORTS_DIR}/")
        print(f"  - validation_summary.json")
        for category in categories:
            print(f"  - {category}_issues.json")
        if auto_fixable:
            print(f"  - auto_fixable.json ({len(auto_fixable)} items)")


def main():
    print("=" * 70)
    print("PRINCIPIA METAPHYSICA - THEORY OUTPUT VALIDATOR")
    print("=" * 70)

    validator = TheoryValidator()
    report = validator.validate_all()

    print(f"\nValidation {'PASSED' if report.passed else 'FAILED'}")
    print(f"\nTotals:")
    print(f"  Formulas:   {report.total_formulas}")
    print(f"  Parameters: {report.total_parameters}")
    print(f"  References: {report.total_references}")
    print(f"  Sections:   {report.total_sections}")

    print(f"\nIssues Found:")
    print(f"  Errors:   {len(report.errors)}")
    print(f"  Warnings: {len(report.warnings)}")
    print(f"  Info:     {len(report.info)}")

    if report.errors:
        print("\n--- ERRORS ---")
        for e in report.errors[:10]:  # Show first 10
            print(f"  [{e.entity_type}:{e.entity_id}] {e.message}")
        if len(report.errors) > 10:
            print(f"  ... and {len(report.errors) - 10} more")

    validator.save_reports()

    print("\n" + "=" * 70)
    return 0 if report.passed else 1


if __name__ == '__main__':
    exit(main())
