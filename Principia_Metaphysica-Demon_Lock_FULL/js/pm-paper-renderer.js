/**
 * PM Paper Renderer
 * =================
 *
 * Dynamically renders the complete Principia Metaphysica paper from theory_output.json.
 * Loads sections, renders formulas, populates parameters, and triggers MathJax.
 *
 * Features:
 * - Loads all sections from theory_output.json
 * - Renders title, abstract, and sections dynamically
 * - Replaces inline formulas with data-formula-id references
 * - Uses PM.get() for parameter values
 * - Coordinates MathJax typesetting
 * - Supports loading section HTML files
 *
 * Usage:
 *   import { renderPaper } from './pm-paper-renderer.js';
 *   await renderPaper('paper-container');
 *
 * Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
 * Version: 1.1.0 - Enhanced error handling, loading states, and memory management
 */

(function() {
    'use strict';

    // ========================================================================
    // STATE MANAGEMENT
    // ========================================================================

    const PaperRenderer = {
        _data: null,
        _loaded: false,
        _loading: null,
        _sectionsCache: new Map(),
        _formulaCache: new Map(),
        _eventListeners: new WeakMap(), // Track event listeners for cleanup
        _tooltipCache: new WeakMap(), // Track tooltips for memory-safe cleanup
        _debug: false,
        _abortControllers: new Set() // Track fetch requests for cleanup
    };

    // ========================================================================
    // MAIN RENDERING FUNCTIONS
    // ========================================================================

    /**
     * Render the complete paper into a container
     * @param {string} containerId - ID of the container element
     * @param {Object} options - Rendering options
     * @param {boolean} [options.loadSections=true] - Load and render sections
     * @param {boolean} [options.loadFormulas=true] - Load and render formulas
     * @param {boolean} [options.loadParameters=true] - Load and render parameters
     * @param {boolean} [options.renderAbstract=true] - Render abstract section
     * @param {boolean} [options.renderTOC=true] - Render table of contents
     * @param {boolean} [options.debug=false] - Enable debug logging
     * @returns {Promise<boolean>} - True if rendered successfully
     */
    async function renderPaper(containerId, options = {}) {
        const {
            loadSections = true,
            loadFormulas = true,
            loadParameters = true,
            renderAbstract = true,
            renderTOC = true,
            debug = false
        } = options;

        PaperRenderer._debug = debug;

        // 1. Get container first
        const container = document.getElementById(containerId);
        if (!container) {
            console.error(`PMPaperRenderer: Container not found: ${containerId}`);
            return false;
        }

        // 2. Show loading state
        container.innerHTML = `
            <div style="
                padding: 3rem;
                text-align: center;
                background: rgba(96, 165, 250, 0.1);
                border: 1px solid rgba(96, 165, 250, 0.3);
                border-radius: 8px;
                color: #60a5fa;
                animation: pulse 1.5s ease-in-out infinite;
            ">
                <div style="font-size: 2rem; margin-bottom: 1rem;">⏳</div>
                <div style="font-size: 1.2rem; font-weight: 600;">Loading Principia Metaphysica...</div>
                <div style="margin-top: 0.5rem; font-size: 0.9rem; opacity: 0.8;">Loading theory data from AutoGenerated/</div>
            </div>
        `;

        // 3. Load theory_output.json
        const loaded = await loadTheoryData();
        if (!loaded) {
            container.innerHTML = `
                <div style="
                    padding: 2rem;
                    background: rgba(244, 67, 54, 0.1);
                    border: 1px solid rgba(244, 67, 54, 0.3);
                    border-left: 4px solid #f44336;
                    border-radius: 8px;
                    color: #f44336;
                ">
                    <div style="font-weight: 600; margin-bottom: 1rem; font-size: 1.1rem;">⚠️ Failed to Load Theory Data</div>
                    <div style="color: #d32f2f; margin-bottom: 1rem;">Could not load theory_output.json or component files from AutoGenerated/</div>
                    <div style="border-top: 1px solid rgba(244, 67, 54, 0.2); padding-top: 1rem; color: #666; font-size: 0.9rem;">
                        <strong>Troubleshooting:</strong>
                        <ul style="margin: 0.5rem 0 0 1.5rem; padding: 0;">
                            <li>Ensure <code>pm-constants-loader.js</code> is loaded before this script</li>
                            <li>Check that <code>AutoGenerated/theory_output.json</code> exists</li>
                            <li>Run: <code>python run_all_simulations.py --export</code></li>
                            <li>Check browser console for more details</li>
                        </ul>
                    </div>
                </div>
            `;
            return false;
        }

        // 4. Clear container and add class
        container.innerHTML = '';
        container.classList.add('pm-paper-container');

        // 4. Render paper components
        try {
            // Title and metadata
            if (PaperRenderer._data.metadata) {
                renderTitle(container, PaperRenderer._data.metadata);
            }

            // Abstract
            if (renderAbstract && PaperRenderer._data.sections?.['1']?.abstract) {
                renderAbstractSection(container, PaperRenderer._data.sections['1'].abstract);
            }

            // Table of Contents
            if (renderTOC) {
                renderTableOfContents(container, PaperRenderer._data.sections);
            }

            // Main sections
            if (loadSections && PaperRenderer._data.sections) {
                await renderAllSections(container, PaperRenderer._data.sections, { loadFormulas, loadParameters });
            }

            // Trigger MathJax
            if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                console.log('PMPaperRenderer: Triggering MathJax...');
                await MathJax.typesetPromise([container]);
            }

            console.log('%cPMPaperRenderer: Paper rendered successfully', 'color: green; font-weight: bold');
            return true;

        } catch (error) {
            console.error('PMPaperRenderer: Error during rendering:', error);
            return false;
        }
    }

    /**
     * Load theory_output.json data
     * @private
     */
    async function loadTheoryData() {
        if (PaperRenderer._loaded) return true;
        if (PaperRenderer._loading) return PaperRenderer._loading;

        PaperRenderer._loading = (async () => {
            const pathPrefixes = [
                '/AutoGenerated/',          // Absolute path (for live site)
                'AutoGenerated/',
                './AutoGenerated/',
                '../AutoGenerated/',
                '../../AutoGenerated/'
            ];

            // Strategy 1: Try theory_output.json (full unified file)
            for (const prefix of pathPrefixes) {
                try {
                    const path = prefix + 'theory_output.json';
                    const response = await fetch(path);
                    if (response.ok) {
                        PaperRenderer._data = await response.json();
                        PaperRenderer._loaded = true;
                        PaperRenderer._basePath = prefix;
                        console.log(`PMPaperRenderer: Loaded theory_output.json from ${path}`);
                        return true;
                    }
                } catch (e) {
                    if (PaperRenderer._debug) {
                        console.debug(`PMPaperRenderer: Failed to load from ${prefix}theory_output.json`);
                    }
                }
            }

            // Strategy 2: Try loading split component files
            for (const prefix of pathPrefixes) {
                try {
                    const sectionsPath = prefix + 'sections.json';
                    const sectionsResponse = await fetch(sectionsPath);
                    if (sectionsResponse.ok) {
                        const sectionsData = await sectionsResponse.json();
                        PaperRenderer._data = {
                            sections: sectionsData.sections || sectionsData,
                            formulas: {},
                            parameters: {}
                        };

                        // Try to load formulas and parameters too
                        try {
                            const formulasResponse = await fetch(prefix + 'formulas.json');
                            if (formulasResponse.ok) {
                                const formulasData = await formulasResponse.json();
                                PaperRenderer._data.formulas = formulasData.formulas || formulasData;
                            }
                        } catch (e) {
                            if (PaperRenderer._debug) console.debug('PMPaperRenderer: formulas.json not available');
                        }

                        try {
                            const paramsResponse = await fetch(prefix + 'parameters.json');
                            if (paramsResponse.ok) {
                                const paramsData = await paramsResponse.json();
                                PaperRenderer._data.parameters = paramsData.parameters || paramsData;
                            }
                        } catch (e) {
                            if (PaperRenderer._debug) console.debug('PMPaperRenderer: parameters.json not available');
                        }

                        PaperRenderer._loaded = true;
                        PaperRenderer._basePath = prefix;
                        console.log(`PMPaperRenderer: Loaded from split files at ${prefix}`);
                        return true;
                    }
                } catch (e) {
                    if (PaperRenderer._debug) {
                        console.debug(`PMPaperRenderer: Failed to load split files from ${prefix}`);
                    }
                }
            }

            console.error('PMPaperRenderer: Could not load data files');
            return false;
        })();

        return PaperRenderer._loading;
    }

    /**
     * Load a single section from individual file (lazy loading)
     * @private
     */
    async function loadIndividualSection(sectionId) {
        const prefix = PaperRenderer._basePath || '/AutoGenerated/';
        const isAppendix = /^[A-N]$/.test(sectionId);
        const fileName = isAppendix ? `appendix-${sectionId}.json` : `section-${sectionId}.json`;
        const path = `${prefix}sections/${fileName}`;

        try {
            const response = await fetch(path);
            if (response.ok) {
                const section = await response.json();
                // Cache the loaded section
                if (!PaperRenderer._data.sections) {
                    PaperRenderer._data.sections = {};
                }
                PaperRenderer._data.sections[sectionId] = section;
                console.log(`PMPaperRenderer: Lazy loaded section ${sectionId} from ${path}`);
                return section;
            }
        } catch (e) {
            if (PaperRenderer._debug) {
                console.debug(`PMPaperRenderer: Failed to load ${path}`);
            }
        }
        return null;
    }

    // ========================================================================
    // COMPONENT RENDERERS
    // ========================================================================

    /**
     * Render paper title and metadata
     * @private
     */
    function renderTitle(container, metadata) {
        const titleSection = document.createElement('div');
        titleSection.className = 'paper-title-section';
        titleSection.innerHTML = `
            <h1 class="paper-title">${metadata.title || 'Principia Metaphysica'}</h1>
            ${metadata.subtitle ? `<h2 class="paper-subtitle">${metadata.subtitle}</h2>` : ''}
            ${metadata.author ? `<div class="paper-author">${metadata.author}</div>` : ''}
            ${metadata.date ? `<div class="paper-date">${metadata.date}</div>` : ''}
            ${metadata.version ? `<div class="paper-version">Version ${metadata.version}</div>` : ''}
        `;
        container.appendChild(titleSection);
    }

    /**
     * Render abstract section
     * @private
     */
    function renderAbstractSection(container, abstractText) {
        const abstractDiv = document.createElement('div');
        abstractDiv.className = 'paper-abstract';
        abstractDiv.innerHTML = `
            <h2>Abstract</h2>
            <p>${abstractText}</p>
        `;
        container.appendChild(abstractDiv);
    }

    /**
     * Render table of contents
     * @private
     */
    function renderTableOfContents(container, sections) {
        if (!sections || Object.keys(sections).length === 0) return;

        const tocDiv = document.createElement('div');
        tocDiv.className = 'paper-toc';
        tocDiv.innerHTML = '<h2>Table of Contents</h2>';

        // Create two-column grid for main sections and appendices
        const tocGrid = document.createElement('div');
        tocGrid.className = 'toc-grid';

        // Split sections into main sections (numeric) and appendices (letters)
        const mainSections = [];
        const appendices = [];

        for (const section of Object.values(sections)) {
            const isAppendix = /^[A-Z]$/.test(section.id) || section.type === 'appendix' || section.appendix === true ||
                              (section.title && section.title.startsWith('Appendix'));
            if (isAppendix) {
                appendices.push(section);
            } else {
                mainSections.push(section);
            }
        }

        // Sort main sections by order or numeric ID
        mainSections.sort((a, b) => {
            const orderA = a.order || parseInt(a.id) || 0;
            const orderB = b.order || parseInt(b.id) || 0;
            return orderA - orderB;
        });

        // Sort appendices by letter ID
        appendices.sort((a, b) => {
            // Extract letter from subsection_id, id, or title
            const getAppendixLetter = (sec) => {
                if (sec.subsection_id && /^[A-Z]$/.test(sec.subsection_id)) return sec.subsection_id;
                if (/^[A-Z]$/.test(sec.id)) return sec.id;
                const match = sec.title?.match(/Appendix ([A-Z])/);
                return match ? match[1] : 'Z';
            };
            return getAppendixLetter(a).localeCompare(getAppendixLetter(b));
        });

        // Helper to get appendix ID for linking
        const getAppendixId = (sec) => {
            if (sec.subsection_id && /^[A-Z]$/.test(sec.subsection_id)) return sec.subsection_id;
            if (/^[A-Z]$/.test(sec.id)) return sec.id;
            const match = sec.title?.match(/Appendix ([A-Z])/);
            return match ? match[1] : sec.id;
        };

        // Render main sections column
        const mainColumn = document.createElement('div');
        mainColumn.className = 'toc-column';
        mainColumn.innerHTML = '<div class="toc-column-header">Main Sections</div>';

        const mainList = document.createElement('ol');
        mainList.className = 'toc-list';

        for (const section of mainSections) {
            const li = document.createElement('li');
            li.innerHTML = `
                <a href="#section-${section.id}" class="toc-link">
                    <span class="toc-number">${section.id}</span>
                    <span class="toc-title">${section.title}</span>
                </a>
            `;
            mainList.appendChild(li);

            // Subsections (if any)
            if (section.subsections && section.subsections.length > 0) {
                const subList = document.createElement('ol');
                subList.className = 'toc-sublist';
                for (const subsection of section.subsections) {
                    const subLi = document.createElement('li');
                    subLi.innerHTML = `
                        <a href="#section-${subsection.id}" class="toc-link">
                            <span class="toc-number">${subsection.id}</span>
                            <span class="toc-title">${subsection.title}</span>
                        </a>
                    `;
                    subList.appendChild(subLi);
                }
                li.appendChild(subList);
            }
        }

        mainColumn.appendChild(mainList);
        tocGrid.appendChild(mainColumn);

        // Render appendices column (if any)
        if (appendices.length > 0) {
            const appendixColumn = document.createElement('div');
            appendixColumn.className = 'toc-column';
            appendixColumn.innerHTML = '<div class="toc-column-header">Appendices</div>';

            const appendixList = document.createElement('ul');
            appendixList.className = 'toc-list toc-appendices';

            for (const appendix of appendices) {
                const li = document.createElement('li');
                const appendixId = getAppendixId(appendix);
                li.innerHTML = `
                    <a href="#section-${appendixId}" class="toc-link">
                        <span class="toc-title">${appendix.title}</span>
                    </a>
                `;
                appendixList.appendChild(li);
            }

            appendixColumn.appendChild(appendixList);
            tocGrid.appendChild(appendixColumn);
        }

        tocDiv.appendChild(tocGrid);
        container.appendChild(tocDiv);
    }

    /**
     * Render all sections
     * @private
     */
    async function renderAllSections(container, sections, options) {
        if (!sections || Object.keys(sections).length === 0) return;

        const sectionsDiv = document.createElement('div');
        sectionsDiv.className = 'paper-sections';

        // Sort sections: main sections first (by order/ID), then appendices (alphabetically)
        const sortedSections = Object.values(sections).sort((a, b) => {
            const isAppendixA = /^[A-Z]$/.test(a.id) || a.type === 'appendix' || a.appendix === true ||
                               (a.title && a.title.startsWith('Appendix'));
            const isAppendixB = /^[A-Z]$/.test(b.id) || b.type === 'appendix' || b.appendix === true ||
                               (b.title && b.title.startsWith('Appendix'));

            // Main sections come before appendices
            if (!isAppendixA && isAppendixB) return -1;
            if (isAppendixA && !isAppendixB) return 1;

            // Both are appendices - sort by letter
            if (isAppendixA && isAppendixB) {
                const getAppendixLetter = (sec) => {
                    if (sec.subsection_id && /^[A-Z]$/.test(sec.subsection_id)) return sec.subsection_id;
                    if (/^[A-Z]$/.test(sec.id)) return sec.id;
                    const match = sec.title?.match(/Appendix ([A-Z])/);
                    return match ? match[1] : 'Z';
                };
                return getAppendixLetter(a).localeCompare(getAppendixLetter(b));
            }

            // Both are main sections - sort by order or numeric ID
            const orderA = a.order || parseInt(a.id) || 0;
            const orderB = b.order || parseInt(b.id) || 0;
            return orderA - orderB;
        });

        // Track if we've rendered the appendix nav yet
        let appendixNavRendered = false;

        for (const section of sortedSections) {
            // Insert appendix navigation before first appendix
            const isAppendix = /^[A-Z]$/.test(section.id) || section.type === 'appendix' || section.appendix === true ||
                              (section.title && section.title.startsWith('Appendix'));

            if (isAppendix && !appendixNavRendered) {
                const appendixNav = renderAppendixNavigation(sortedSections);
                if (appendixNav) {
                    sectionsDiv.appendChild(appendixNav);
                }
                appendixNavRendered = true;
            }

            const sectionEl = await renderSection(section, options);
            if (sectionEl) {
                sectionsDiv.appendChild(sectionEl);
            }
        }

        container.appendChild(sectionsDiv);
    }

    /**
     * Render appendix navigation component
     * @private
     */
    function renderAppendixNavigation(allSections) {
        const appendices = allSections.filter(s =>
            /^[A-Z]$/.test(s.id) || s.type === 'appendix' || s.appendix === true ||
            (s.title && s.title.startsWith('Appendix'))
        );

        if (appendices.length === 0) return null;

        const navDiv = document.createElement('div');
        navDiv.className = 'appendix-nav';
        navDiv.id = 'appendix-navigation';

        const title = document.createElement('h3');
        title.textContent = `Appendices (${appendices.length})`;
        navDiv.appendChild(title);

        const grid = document.createElement('div');
        grid.className = 'appendix-nav-grid';

        for (const appendix of appendices) {
            const link = document.createElement('a');
            // Use subsection_id for appendices (e.g., "A"), fallback to id, or extract from title
            const appendixId = (appendix.subsection_id && /^[A-Z]$/.test(appendix.subsection_id))
                ? appendix.subsection_id
                : (/^[A-Z]$/.test(appendix.id) ? appendix.id : appendix.title?.match(/Appendix ([A-Z])/)?.[1] || appendix.id);
            link.href = `#section-${appendixId}`;
            link.className = 'appendix-nav-link';
            link.textContent = appendix.title;
            grid.appendChild(link);
        }

        navDiv.appendChild(grid);

        // Back to top link
        const backLink = document.createElement('a');
        backLink.href = '#';
        backLink.className = 'back-to-top';
        backLink.textContent = 'Back to Top';
        navDiv.appendChild(backLink);

        return navDiv;
    }

    /**
     * Render a single section with subsections
     * @param {Object} section - Section data from theory_output.json
     * @param {Object} options - Rendering options
     * @returns {Promise<HTMLElement>} - Rendered section element
     */
    async function renderSection(section, options = {}) {
        const { loadFormulas = true, loadParameters = true, useJsonContent = true } = options;

        // Handle both flat structure and metadata/content wrapper
        // For appendices, use subsection_id (e.g., "A") instead of id (which may be "2")
        const isAppendixSection = section.appendix === true || section.type === 'appendix' ||
                                  (section.title && section.title.startsWith('Appendix'));
        const sectionId = isAppendixSection && section.subsection_id
            ? section.subsection_id
            : (section.metadata?.id || section.id);
        const sectionTitle = section.metadata?.title || section.title;
        const sectionAbstract = section.metadata?.abstract || section.abstract;
        const subsections = section.content?.subsections || section.subsections || [];
        const contentBlocks = section.contentBlocks || section.content_blocks || [];

        const sectionDiv = document.createElement('section');
        sectionDiv.id = `section-${sectionId}`;
        sectionDiv.className = 'paper-section';
        sectionDiv.setAttribute('data-section-id', sectionId);

        // Add appendix class and alias for letter-based section IDs (e.g., B -> appendix-b)
        const isAppendix = /^[A-Z]$/.test(sectionId) || section.type === 'appendix' || section.appendix === true ||
                          (sectionTitle && sectionTitle.startsWith('Appendix'));
        if (isAppendix) {
            sectionDiv.classList.add('appendix-section');
        }

        if (/^[A-Za-z]$/.test(sectionId)) {
            const appendixAlias = document.createElement('a');
            appendixAlias.id = `appendix-${sectionId.toLowerCase()}`;
            appendixAlias.className = 'appendix-anchor';
            sectionDiv.insertBefore(appendixAlias, sectionDiv.firstChild);
        }

        // Section header
        const header = document.createElement('div');
        header.className = 'section-header';
        header.innerHTML = `
            <h2 class="section-title">
                <span class="section-number">${sectionId}</span>
                ${sectionTitle}
            </h2>
        `;
        sectionDiv.appendChild(header);

        // Section abstract (if available)
        if (sectionAbstract) {
            const abstractDiv = document.createElement('div');
            abstractDiv.className = 'section-abstract';
            abstractDiv.innerHTML = `<p>${sectionAbstract}</p>`;
            sectionDiv.appendChild(abstractDiv);
        }

        // Render subsections from JSON
        if (useJsonContent && subsections.length > 0) {
            const subsectionsDiv = document.createElement('div');
            subsectionsDiv.className = 'section-subsections';

            for (const subsection of subsections) {
                const subDiv = renderSubsection(subsection);
                subsectionsDiv.appendChild(subDiv);
            }

            sectionDiv.appendChild(subsectionsDiv);

            // Process formulas, parameters, and equation references
            if (loadFormulas) {
                processFormulas(subsectionsDiv);
            }
            if (loadParameters) {
                processParameters(subsectionsDiv);
            }
            // Always process equation cross-references in paper mode
            processEquationReferences(subsectionsDiv);
        }
        // Fallback: Try to load section HTML file if no JSON content
        else if (section.sectionFile) {
            const content = await loadSectionFile(section.sectionFile);
            if (content) {
                const contentDiv = document.createElement('div');
                contentDiv.className = 'section-content';
                contentDiv.innerHTML = content;
                sectionDiv.appendChild(contentDiv);

                if (loadFormulas) {
                    processFormulas(contentDiv);
                }
                if (loadParameters) {
                    processParameters(contentDiv);
                }
                processEquationReferences(contentDiv);
            } else {
                // No HTML file found - show placeholder
                if (PaperRenderer._debug) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'empty-section-placeholder';
                    placeholder.style.cssText = 'padding: 1rem; color: #999; font-style: italic; background: #f8f9fa; border-radius: 4px; margin: 1rem 0; border-left: 3px solid #f9a825;';
                    placeholder.textContent = `[Section content for "${sectionTitle}" is being developed - referenced file: ${section.sectionFile}]`;
                    sectionDiv.appendChild(placeholder);
                }
            }
        }
        // No subsections and no section file - completely empty
        else if (subsections.length === 0 && contentBlocks.length === 0) {
            if (PaperRenderer._debug) {
                const placeholder = document.createElement('div');
                placeholder.className = 'empty-section-placeholder';
                placeholder.style.cssText = 'padding: 1rem; color: #999; font-style: italic; background: #f8f9fa; border-radius: 4px; margin: 1rem 0; border-left: 3px solid #f9a825;';
                placeholder.textContent = `[Content for this section is being developed]`;
                sectionDiv.appendChild(placeholder);
            }
        }

        // Render top-level content blocks (if any)
        if (contentBlocks.length > 0) {
            const blocksDiv = renderContentBlocks(contentBlocks);
            sectionDiv.appendChild(blocksDiv);
        }

        // Key takeaways (if available)
        if (section.keyTakeaways && section.keyTakeaways.length > 0) {
            const takeawaysDiv = document.createElement('div');
            takeawaysDiv.className = 'section-takeaways';
            takeawaysDiv.innerHTML = `
                <h3>Key Takeaways</h3>
                <ul>
                    ${section.keyTakeaways.map(item => `<li>${item}</li>`).join('')}
                </ul>
            `;
            sectionDiv.appendChild(takeawaysDiv);
        }

        return sectionDiv;
    }

    /**
     * Render a subsection with its content blocks
     * @private
     */
    function renderSubsection(subsection) {
        const subDiv = document.createElement('div');
        subDiv.className = 'paper-subsection';
        subDiv.id = `subsection-${subsection.id || subsection.number || 'unknown'}`;

        // Subsection header
        const header = document.createElement('h3');
        header.className = 'subsection-title';
        header.innerHTML = `
            <span class="subsection-number">${subsection.number || ''}</span>
            ${subsection.title}
        `;
        subDiv.appendChild(header);

        // Render content blocks (support camelCase, snake_case, and plain content)
        let blocks = subsection.contentBlocks || subsection.content_blocks || subsection.content || [];

        // Handle string content (convert to single paragraph block)
        if (typeof blocks === 'string') {
            blocks = [{ type: 'paragraph', text: blocks }];
        }

        if (Array.isArray(blocks) && blocks.length > 0) {
            for (const block of blocks) {
                const blockEl = renderContentBlock(block);
                if (blockEl) {
                    subDiv.appendChild(blockEl);
                }
            }
        } else if (!Array.isArray(blocks) && blocks) {
            // Object content - treat as single block
            const blockEl = renderContentBlock(blocks);
            if (blockEl) {
                subDiv.appendChild(blockEl);
            }
        } else {
            // Empty subsection - add placeholder message
            if (PaperRenderer._debug) {
                const placeholder = document.createElement('p');
                placeholder.className = 'empty-subsection-placeholder';
                placeholder.style.cssText = 'color: #999; font-style: italic; padding: 0.5rem; background: #f8f9fa; border-radius: 4px; margin: 0.5rem 0;';
                placeholder.textContent = '[Content for this subsection is being developed]';
                subDiv.appendChild(placeholder);
            }
        }

        // Handle nested subsections
        if (subsection.subsections && subsection.subsections.length > 0) {
            for (const nested of subsection.subsections) {
                const nestedDiv = renderSubsection(nested);
                subDiv.appendChild(nestedDiv);
            }
        }

        return subDiv;
    }

    /**
     * Load section HTML file
     * @private
     */
    async function loadSectionFile(filePath) {
        // Check cache first
        if (PaperRenderer._sectionsCache.has(filePath)) {
            return PaperRenderer._sectionsCache.get(filePath);
        }

        const pathPrefixes = ['', '../', '../../'];

        for (const prefix of pathPrefixes) {
            try {
                const fullPath = prefix + filePath;
                const response = await fetch(fullPath);
                if (response.ok) {
                    const html = await response.text();

                    // Extract content from the <body> tag
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const body = doc.querySelector('body');

                    if (body) {
                        const content = body.innerHTML;
                        PaperRenderer._sectionsCache.set(filePath, content);
                        return content;
                    }
                }
            } catch (e) {
                if (PaperRenderer._debug) {
                    console.debug(`PMPaperRenderer: Failed to load ${filePath} from ${prefix}`);
                }
            }
        }

        console.warn(`PMPaperRenderer: Could not load section file: ${filePath}`);
        return null;
    }

    /**
     * Render content blocks
     * @private
     */
    function renderContentBlocks(blocks) {
        const container = document.createElement('div');
        container.className = 'content-blocks';

        for (const block of blocks) {
            const blockEl = renderContentBlock(block);
            if (blockEl) {
                container.appendChild(blockEl);
            }
        }

        return container;
    }

    /**
     * Render a single content block
     * @private
     */
    function renderContentBlock(block) {
        // Helper function to safely convert values to strings
        const safeStringify = (value, fieldName = 'content') => {
            if (value === null || value === undefined) return '';
            if (typeof value === 'object') {
                console.warn(`PMPaperRenderer: Found object in ${fieldName} field of ${block.type} block, converting to JSON:`, value);
                return JSON.stringify(value);
            }
            return String(value);
        };

        const blockDiv = document.createElement('div');
        blockDiv.className = `content-block content-block-${block.type}`;

        switch (block.type) {
            case 'paragraph':
            case 'text':
                blockDiv.innerHTML = `<p>${safeStringify(block.content || block.text, 'text/content')}</p>`;
                break;

            case 'heading':
                const level = block.level || 3;
                blockDiv.innerHTML = `<h${level}>${safeStringify(block.content, 'heading.content')}</h${level}>`;
                break;

            case 'formula':
            case 'equation':
                // Render equation in academic paper style
                const formulaHtml = renderEquation(block);
                if (formulaHtml) {
                    blockDiv.innerHTML = formulaHtml;
                } else {
                    // Fallback for simple formula blocks
                    // Wrap content in LaTeX if it looks like a formula
                    const formulaId = block.formulaId || block.id || block.label || '';
                    let formulaContent = '';
                    if (block.latex) {
                        // Add displaystyle for proper fraction rendering
                        const displayLatex = block.latex.startsWith('\\displaystyle') ? block.latex : `\\displaystyle ${block.latex}`;
                        formulaContent = `$$${displayLatex}$$`;
                    } else if (block.content) {
                        // Wrap plain text content in LaTeX display mode
                        // Convert common Unicode math symbols to LaTeX
                        let latexContent = block.content
                            .replace(/∫/g, '\\int ')
                            .replace(/√/g, '\\sqrt')
                            .replace(/≈/g, '\\approx ')
                            .replace(/±/g, '\\pm ')
                            .replace(/×/g, '\\times ')
                            .replace(/÷/g, '\\div ')
                            .replace(/≤/g, '\\leq ')
                            .replace(/≥/g, '\\geq ')
                            .replace(/≠/g, '\\neq ')
                            .replace(/∞/g, '\\infty ')
                            .replace(/Σ/g, '\\Sigma ')
                            .replace(/Π/g, '\\Pi ')
                            .replace(/Δ/g, '\\Delta ')
                            .replace(/Ω/g, '\\Omega ')
                            .replace(/α/g, '\\alpha ')
                            .replace(/β/g, '\\beta ')
                            .replace(/γ/g, '\\gamma ')
                            .replace(/δ/g, '\\delta ')
                            .replace(/ε/g, '\\epsilon ')
                            .replace(/ζ/g, '\\zeta ')
                            .replace(/η/g, '\\eta ')
                            .replace(/θ/g, '\\theta ')
                            .replace(/λ/g, '\\lambda ')
                            .replace(/μ/g, '\\mu ')
                            .replace(/ν/g, '\\nu ')
                            .replace(/π/g, '\\pi ')
                            .replace(/ρ/g, '\\rho ')
                            .replace(/σ/g, '\\sigma ')
                            .replace(/τ/g, '\\tau ')
                            .replace(/φ/g, '\\phi ')
                            .replace(/χ/g, '\\chi ')
                            .replace(/ψ/g, '\\psi ')
                            .replace(/ω/g, '\\omega ')
                            .replace(/Γ/g, '\\Gamma ')
                            .replace(/Ψ/g, '\\Psi ')
                            .replace(/Φ/g, '\\Phi ')
                            .replace(/⊗/g, '\\otimes ')
                            .replace(/⟨/g, '\\langle ')
                            .replace(/⟩/g, '\\rangle ')
                            .replace(/—/g, '\\quad \\text{—} \\quad ')
                            // Multi-digit exponents: ^26 -> ^{26}
                            .replace(/\^(\d{2,})/g, '^{$1}')
                            // Combining overline for Dirac adjoint: Ψ̄ -> \bar{\Psi}
                            .replace(/([A-Za-z\u0391-\u03C9])̄/g, '\\bar{$1}')
                            .replace(/([A-Za-z\u0391-\u03C9])̅/g, '\\bar{$1}');
                        // Add displaystyle for proper fraction rendering
                        formulaContent = `$$\\displaystyle ${latexContent}$$`;
                    }
                    const labelHtml = block.label ? `<span class="equation-number">${escapeHtml(block.label)}</span>` : '';
                    blockDiv.innerHTML = `
                        <div class="formula-block equation-wrapper" data-formula-id="${escapeHtml(formulaId)}">
                            <div class="equation-line">
                                <div class="equation-content">${formulaContent}</div>
                                ${labelHtml}
                            </div>
                        </div>
                    `;
                }
                break;

            case 'list':
                // Handle list blocks - items might be in block.items or block.content.items
                let listItemsArray = block.items;
                let isOrdered = block.ordered;
                if (!listItemsArray && typeof block.content === 'object' && block.content !== null) {
                    listItemsArray = block.content.items || [];
                    isOrdered = block.content.type === 'ordered' || isOrdered;
                }
                const listType = isOrdered ? 'ol' : 'ul';
                const listItems = (listItemsArray || []).map((item, idx) =>
                    `<li>${safeStringify(item, `list.items[${idx}]`)}</li>`
                ).join('');
                blockDiv.innerHTML = `<${listType}>${listItems}</${listType}>`;
                break;

            case 'code':
                // Handle code blocks - content might be string or object with nested structure
                let codeContent = block.content;
                let codeLang = block.language;
                if (typeof codeContent === 'object' && codeContent !== null) {
                    // Extract from nested structure if present
                    codeLang = codeContent.language || codeLang;
                    codeContent = codeContent.code || codeContent.content || JSON.stringify(codeContent, null, 2);
                }
                const lang = codeLang ? ` class="language-${codeLang}"` : '';
                blockDiv.innerHTML = `<pre><code${lang}>${escapeHtml(codeContent || '')}</code></pre>`;
                break;

            case 'quote':
            case 'blockquote':
                blockDiv.innerHTML = `<blockquote>${safeStringify(block.content, 'quote.content')}</blockquote>`;
                break;

            case 'table':
                // Handle table blocks - data might be in block directly or in block.content
                let tableData = block;
                if (typeof block.content === 'object' && block.content !== null) {
                    // If content is an object with headers/rows, use it
                    if (block.content.headers || block.content.rows) {
                        tableData = { ...block, ...block.content };
                    }
                }
                blockDiv.innerHTML = renderTable(tableData);
                break;

            case 'note':
                // Academic note/aside
                blockDiv.className = 'academic-note';
                blockDiv.innerHTML = `<div class="note-content">${safeStringify(block.content, 'note.content')}</div>`;
                blockDiv.setAttribute('role', 'note');
                break;

            case 'highlight_box':
                // Highlighted information box
                blockDiv.className = 'highlight-box';
                blockDiv.innerHTML = `
                    ${block.title ? `<div class="highlight-title">${safeStringify(block.title, 'highlight.title')}</div>` : ''}
                    <div class="highlight-content">${safeStringify(block.content, 'highlight.content')}</div>
                `;
                blockDiv.setAttribute('role', 'complementary');
                break;

            case 'definition':
                // Mathematical definition block
                blockDiv.className = 'definition-block';
                blockDiv.innerHTML = `
                    ${block.term ? `<div class="definition-term"><strong>Definition:</strong> ${safeStringify(block.term, 'definition.term')}</div>` : ''}
                    <div class="definition-content">${safeStringify(block.content, 'definition.content')}</div>
                `;
                blockDiv.setAttribute('role', 'definition');
                break;

            case 'theorem':
                // Theorem block
                blockDiv.className = 'theorem-block';
                blockDiv.innerHTML = `
                    <div class="theorem-header">
                        <span class="theorem-label">${safeStringify(block.label, 'theorem.label') || 'Theorem'}</span>
                        ${block.title ? `<span class="theorem-title">${safeStringify(block.title, 'theorem.title')}</span>` : ''}
                    </div>
                    <div class="theorem-content">${safeStringify(block.content, 'theorem.content')}</div>
                `;
                blockDiv.setAttribute('role', 'article');
                break;

            case 'proof':
                // Proof block
                blockDiv.className = 'proof-block';
                blockDiv.innerHTML = `
                    <div class="proof-header">Proof.</div>
                    <div class="proof-content">${safeStringify(block.content, 'proof.content')}</div>
                    <div class="proof-end">∎</div>
                `;
                blockDiv.setAttribute('role', 'article');
                break;

            case 'remark':
                // Remark/observation block
                blockDiv.className = 'remark-block';
                blockDiv.innerHTML = `
                    <div class="remark-header">${safeStringify(block.title, 'remark.title') || 'Remark'}</div>
                    <div class="remark-content">${safeStringify(block.content, 'remark.content')}</div>
                `;
                blockDiv.setAttribute('role', 'note');
                break;

            case 'example':
                // Worked example block
                blockDiv.className = 'example-block';
                blockDiv.innerHTML = `
                    <div class="example-header">${safeStringify(block.title, 'example.title') || 'Example'}</div>
                    <div class="example-content">${safeStringify(block.content, 'example.content')}</div>
                `;
                blockDiv.setAttribute('role', 'article');
                break;

            case 'derivation':
            case 'derivation_box':
                blockDiv.className = 'derivation-box';
                blockDiv.innerHTML = `
                    <div class="derivation-title">${safeStringify(block.title, 'derivation.title') || 'Derivation'}</div>
                    <div class="derivation-content">${safeStringify(block.content, 'derivation.content')}</div>
                `;
                break;

            case 'callout':
            case 'info_box':
            case 'highlight':
                const calloutType = block.calloutType || block.variant || 'info';
                blockDiv.className = `callout callout-${calloutType}`;
                blockDiv.innerHTML = `
                    ${block.title ? `<div class="callout-title">${safeStringify(block.title, 'callout.title')}</div>` : ''}
                    <div class="callout-content">${safeStringify(block.content, 'callout.content')}</div>
                `;
                break;

            case 'subsection':
                // Nested subsection - recursively render
                if (block.subsection) {
                    return renderSubsection(block.subsection);
                }
                blockDiv.innerHTML = safeStringify(block.content, 'subsection.content');
                break;

            case 'image':
            case 'figure':
            case 'visualization':
                // Render images/figures with captions
                blockDiv.className = 'figure-block';
                const imgSrc = block.src || block.path || block.url || '';
                const imgAlt = block.alt || block.title || block.caption || '';
                const imgCaption = block.caption || block.description || '';
                const figLabel = block.label || block.id || '';

                // Handle relative paths - prepend ../images/ if not absolute
                let resolvedSrc = imgSrc;
                if (imgSrc && !imgSrc.startsWith('http') && !imgSrc.startsWith('/') && !imgSrc.startsWith('../')) {
                    resolvedSrc = '../images/' + imgSrc;
                }

                blockDiv.innerHTML = `
                    <figure class="paper-figure" ${figLabel ? `id="fig-${figLabel}"` : ''}>
                        <img src="${escapeHtml(resolvedSrc)}" alt="${escapeHtml(imgAlt)}" class="figure-image" loading="lazy">
                        ${imgCaption ? `<figcaption class="figure-caption">${figLabel ? `<span class="figure-label">Figure ${figLabel}:</span> ` : ''}${safeStringify(imgCaption, 'figure.caption')}</figcaption>` : ''}
                    </figure>
                `;
                break;

            default:
                // Handle unknown types gracefully - ensure content is a string
                blockDiv.innerHTML = safeStringify(block.content || block.text, 'unknown.content');
                console.warn(`PMPaperRenderer: Unknown block type: ${block.type}`);
        }

        return blockDiv;
    }

    /**
     * Render a table from block data
     * @private
     */
    function renderTable(block) {
        const headers = block.headers || [];
        const rows = block.rows || [];

        // Helper to safely stringify table values
        const safeTableValue = (value, type, index) => {
            if (value === null || value === undefined) return '';
            if (typeof value === 'object') {
                console.warn(`PMPaperRenderer: Found object in table ${type}[${index}], converting to JSON:`, value);
                return JSON.stringify(value);
            }
            return String(value);
        };

        let html = '<table class="pm-table">';

        if (headers.length > 0) {
            html += '<thead><tr>';
            headers.forEach((header, idx) => {
                html += `<th>${safeTableValue(header, 'header', idx)}</th>`;
            });
            html += '</tr></thead>';
        }

        if (rows.length > 0) {
            html += '<tbody>';
            rows.forEach((row, rowIdx) => {
                html += '<tr>';
                // Handle both array format [cell1, cell2] and object format {col1: val1, col2: val2}
                if (Array.isArray(row)) {
                    row.forEach((cell, cellIdx) => {
                        html += `<td>${safeTableValue(cell, `row[${rowIdx}].cell`, cellIdx)}</td>`;
                    });
                } else if (row && typeof row === 'object') {
                    // Object format: iterate over values in order of headers or object keys
                    const values = headers.length > 0
                        ? headers.map(h => row[h] || row[h.toLowerCase()] || '')
                        : Object.values(row);
                    values.forEach((cell, cellIdx) => {
                        html += `<td>${safeTableValue(cell, `row[${rowIdx}].cell`, cellIdx)}</td>`;
                    });
                } else {
                    // Single value - render as single cell
                    html += `<td>${safeTableValue(row, `row[${rowIdx}]`, 0)}</td>`;
                }
                html += '</tr>';
            });
            html += '</tbody>';
        }

        html += '</table>';
        return html;
    }

    // ========================================================================
    // FORMULA AND PARAMETER PROCESSING
    // ========================================================================

    /**
     * Render an equation in academic paper style with complete metadata
     * @param {Object} block - Formula/equation content block
     * @returns {string|null} - HTML string for academic-style equation
     * @private
     */
    function renderEquation(block) {
        // Get formula ID from various possible fields
        const formulaId = block.formulaId || block.formula_id || block.id || '';

        // Try to get full formula metadata from global data
        let formulaData = null;
        if (formulaId && PaperRenderer._data?.formulas) {
            formulaData = PaperRenderer._data.formulas[formulaId];
        }

        // Extract equation number from label (e.g., "(4.2)" from label or formulaData)
        const label = block.label || block.equationNumber || formulaData?.label || '';
        const equationNumber = extractEquationNumber(label);

        // Get LaTeX code - try multiple sources
        let latex = block.latex || formulaData?.latex || '';
        let formulaCaption = '';

        // If no LaTeX but has content, try to convert content to LaTeX
        if (!latex && block.content) {
            let contentToParse = block.content;

            // Extract caption (text after em-dash on its own line or at end)
            // Matches: "\n— Caption" or just "— Caption" at end
            const captionMatch = contentToParse.match(/(?:\n|^)\s*[—–-]\s*([^\n]+)$/);
            if (captionMatch) {
                formulaCaption = captionMatch[1].trim();
                // Remove caption from content before LaTeX conversion
                contentToParse = contentToParse.replace(/(?:\n|^)\s*[—–-]\s*[^\n]+$/, '');
            }

            latex = convertToLatex(contentToParse);
        }

        // If we still have no formula ID and no LaTeX, fall back to null
        if (!formulaId && !latex) return null;

        const plainText = block.plain_text || formulaData?.plain_text || block.content || '';

        // Build the equation HTML with anchor ID and hover tooltip
        const anchorId = equationNumber ? `eq-${equationNumber}` : `eq-${formulaId}`;

        // Create tooltip text from description or formula metadata
        let tooltipText = '';
        if (formulaData?.description || block.description) {
            tooltipText = (formulaData?.description || block.description).replace(/"/g, '&quot;');
        } else if (formulaData?.label) {
            tooltipText = formulaData.label.replace(/"/g, '&quot;');
        } else if (label) {
            tooltipText = label.replace(/"/g, '&quot;');
        }

        const titleAttr = tooltipText ? ` title="${tooltipText}"` : '';
        let html = `<div class="equation-wrapper academic-equation" id="${anchorId}" data-formula-id="${formulaId}"${titleAttr}>`;

        // Main equation with number
        // Add \displaystyle to ensure fractions render at full size (prevents cramped rendering)
        const displayLatex = latex.startsWith('\\displaystyle') ? latex : `\\displaystyle ${latex}`;
        html += '<div class="equation-line">';
        html += `<div class="equation-content">$$${displayLatex}$$</div>`;
        if (equationNumber) {
            html += `<div class="equation-number">(${equationNumber})</div>`;
        }
        html += '</div>';

        // Formula caption (extracted from content, styled as italic and light)
        if (formulaCaption) {
            html += `<div class="equation-caption"><em>${formulaCaption}</em></div>`;
        }

        // Plain text is removed from display - LaTeX is the primary representation
        // (Plain text kept in data for search/accessibility but not rendered visually)

        // Parameter definitions (from terms)
        if (formulaData?.terms && Object.keys(formulaData.terms).length > 0) {
            html += '<div class="equation-terms">';
            const termsList = renderTermsDefinition(formulaData.terms);
            if (termsList) {
                html += `<div class="terms-intro">where ${termsList}</div>`;
            }
            html += '</div>';
        }

        // Discussion/description
        if (formulaData?.description || block.description) {
            const description = formulaData?.description || block.description;
            html += `<div class="equation-discussion"><p>${description}</p></div>`;
        }

        // Expandable metadata panel
        const hasMetadata = formulaData && (
            (formulaData.input_params && formulaData.input_params.length > 0) ||
            (formulaData.output_params && formulaData.output_params.length > 0) ||
            (formulaData.derivation && (formulaData.derivation.steps || formulaData.derivation.references)) ||
            formulaData.category ||
            formulaData.notes ||
            (formulaData.experimental_value !== undefined) ||
            (formulaData.computed_value !== undefined)
        );

        if (hasMetadata) {
            // Paper mode: always show metadata expanded (no toggle)
            html += '<div class="equation-metadata-panel always-expanded">';
            html += '<div class="metadata-content">';

            // Input/Output Parameters - compact grid layout
            if ((formulaData.input_params && formulaData.input_params.length > 0) ||
                (formulaData.output_params && formulaData.output_params.length > 0)) {
                html += '<div class="metadata-params-grid">';

                if (formulaData.input_params && formulaData.input_params.length > 0) {
                    html += '<div class="params-column params-inputs">';
                    html += '<span class="params-label">Inputs:</span>';
                    html += '<div class="params-list">';
                    for (const param of formulaData.input_params) {
                        html += `<code class="param-chip" data-param-id="${param}">${param}</code>`;
                    }
                    html += '</div></div>';
                }

                if (formulaData.output_params && formulaData.output_params.length > 0) {
                    html += '<div class="params-column params-outputs">';
                    html += '<span class="params-label">Outputs:</span>';
                    html += '<div class="params-list">';
                    for (const param of formulaData.output_params) {
                        html += `<code class="param-chip" data-param-id="${param}">${param}</code>`;
                    }
                    html += '</div></div>';
                }

                html += '</div>';
            }

            // Derivation steps - render as LaTeX formulas with descriptions
            if (formulaData.derivation?.steps && formulaData.derivation.steps.length > 0) {
                html += '<div class="metadata-section metadata-derivation">';
                html += '<ol class="derivation-steps">';
                for (const step of formulaData.derivation.steps) {
                    // Handle both object steps and string steps
                    if (typeof step === 'object' && step !== null) {
                        const desc = step.description || '';
                        const formula = step.formula || '';
                        html += '<li class="derivation-step">';
                        if (desc) html += `<span class="step-description">${escapeHtml(desc)}:</span> `;
                        if (formula) html += `<span class="step-formula">$${formula}$</span>`;
                        html += '</li>';
                    } else {
                        html += `<li class="derivation-step">${escapeHtml(String(step))}</li>`;
                    }
                }
                html += '</ol></div>';
            }

            // References - compact inline display
            if (formulaData.derivation?.references && formulaData.derivation.references.length > 0) {
                html += '<div class="metadata-references-inline">';
                html += '<span class="refs-label">Refs:</span> ';
                html += formulaData.derivation.references.map(ref => `<span class="ref-item">${ref}</span>`).join(', ');
                html += '</div>';
            }

            // Category - single line with badge
            if (formulaData.category) {
                const categoryBadge = getCategoryBadge(formulaData.category);
                html += `<div class="metadata-category-inline">${categoryBadge}</div>`;
            }

            // Experimental vs Computed values
            if (formulaData.experimental_value !== undefined || formulaData.computed_value !== undefined) {
                html += '<div class="metadata-section metadata-values">';
                html += '<h5 class="metadata-section-title">🎯 Values</h5>';
                html += '<div class="value-comparison">';

                if (formulaData.computed_value !== undefined) {
                    html += `<div class="value-item value-computed">`;
                    html += `<span class="value-label">Theory:</span> `;
                    html += `<span class="value-number">${formatScientificValue(formulaData.computed_value)}</span>`;
                    if (formulaData.units) {
                        html += ` <span class="value-units">${formulaData.units}</span>`;
                    }
                    html += `</div>`;
                }

                if (formulaData.experimental_value !== undefined) {
                    html += `<div class="value-item value-experimental">`;
                    html += `<span class="value-label">Experiment:</span> `;
                    html += `<span class="value-number">${formatScientificValue(formulaData.experimental_value)}</span>`;
                    if (formulaData.units) {
                        html += ` <span class="value-units">${formulaData.units}</span>`;
                    }
                    html += `</div>`;
                }

                if (formulaData.sigma_deviation !== undefined) {
                    const sigma = formulaData.sigma_deviation;
                    const sigmaClass = Math.abs(sigma) < 1 ? 'excellent' : Math.abs(sigma) < 2 ? 'good' : 'fair';
                    html += `<div class="value-item value-deviation ${sigmaClass}">`;
                    html += `<span class="value-label">Deviation:</span> `;
                    html += `<span class="value-number">${sigma.toFixed(2)}σ</span>`;
                    html += `</div>`;
                }

                html += '</div></div>';
            }

            // Notes
            if (formulaData.notes) {
                html += '<div class="metadata-section metadata-notes">';
                html += '<h5 class="metadata-section-title">📝 Notes</h5>';
                html += `<p class="metadata-notes-text">${formulaData.notes}</p>`;
                html += '</div>';
            }

            html += '</div>'; // metadata-content
            html += '</div>'; // equation-metadata-panel
        }

        html += '</div>'; // equation-wrapper
        return html;
    }

    /**
     * Extract equation number from label string
     * @param {string} label - Formula label like "(4.2) Three Generations", "(TT.1)", "Main Equation"
     * @returns {string|null} - Equation number like "4.2", "TT.1", or null
     * @private
     */
    function extractEquationNumber(label) {
        if (!label) return null;

        // Match patterns like "(4.2)" or "(Eq. 4.2)" at the start
        const match = label.match(/^\((?:Eq\.\s*)?([0-9]+\.[0-9]+)\)/);
        if (match) return match[1];

        // Match patterns like "4.2" or "Eq. 4.2"
        const simpleMatch = label.match(/^(?:Eq\.\s*)?([0-9]+\.[0-9]+)/);
        if (simpleMatch) return simpleMatch[1];

        // Match special section labels like "(TT.1)", "(TT.2)", etc.
        const specialMatch = label.match(/^\(([A-Z]+\.[0-9]+)\)/);
        if (specialMatch) return specialMatch[1];

        // Match special patterns without parens like "TT.1"
        const specialSimple = label.match(/^([A-Z]+\.[0-9]+)/);
        if (specialSimple) return specialSimple[1];

        // If label is just a descriptive name like "Main Equation", return it as-is
        // (This allows the equation to have a label even without a formal number)
        if (label && label.length > 0 && !label.match(/^[\s\(\)]+$/)) {
            return label;
        }

        return null;
    }

    /**
     * Render terms as inline definition list
     * @param {Object} terms - Terms object with parameter definitions
     * @returns {string} - Formatted "X is..., Y represents..." string
     * @private
     */
    function renderTermsDefinition(terms) {
        if (!terms || Object.keys(terms).length === 0) return '';

        const definitions = [];
        for (const [symbol, termData] of Object.entries(terms)) {
            const desc = termData.description || termData.name || '';
            if (desc) {
                // Format: "X is the description" or "X represents the description"
                const verb = definitions.length === 0 ? 'is' : 'is';
                const cleanDesc = desc.replace(/^(is|represents|denotes)\s+/i, '');
                definitions.push(`<i>${symbol}</i> ${verb} ${cleanDesc}`);
            }
        }

        return definitions.join(', ');
    }

    /**
     * Format a formula reference for citation
     * @param {Object} formula - Formula data object
     * @returns {string} - Formatted reference like "[Section 2.3, Eq. (2.7)]"
     * @private
     */
    function formatFormulaReference(formula) {
        const eqNum = extractEquationNumber(formula.label);
        const section = formula.section || '';

        if (eqNum && section) {
            return `[${section}, Eq. (${eqNum})]`;
        } else if (eqNum) {
            return `[Eq. (${eqNum})]`;
        } else if (section) {
            return `[${section}]`;
        } else {
            return `[${formula.label || formula.id}]`;
        }
    }

    /**
     * Process formulas in a container
     * Replaces inline formula references with proper data-formula-id elements
     * @private
     */
    function processFormulas(container) {
        // Find all elements with data-formula-id that are empty
        const formulaElements = container.querySelectorAll('[data-formula-id]');

        formulaElements.forEach(el => {
            const formulaId = el.getAttribute('data-formula-id');

            // Skip if already has content
            if (el.innerHTML.trim() && !el.classList.contains('pm-formula-auto')) {
                return;
            }

            // Try to get formula from PM
            if (window.PM && typeof window.PM.formula === 'function') {
                const formula = window.PM.formula(formulaId);
                if (formula) {
                    el.innerHTML = formula.html || formula.latex || formula.plainText || '';
                    el.classList.add('pm-formula-loaded');

                    // Add tooltip with description
                    if (formula.description) {
                        el.setAttribute('title', formula.description);
                    }
                }
            }
        });
    }

    /**
     * Process equation cross-references in text
     * Converts "Eq. (4.2)" to clickable links with hover tooltips
     * @param {HTMLElement} container - Container to process
     * @private
     */
    function processEquationReferences(container) {
        // Find all text nodes
        const walker = document.createTreeWalker(
            container,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );

        const textNodes = [];
        let node;
        while (node = walker.nextNode()) {
            // Skip if parent is script, style, or already a link
            const parent = node.parentElement;
            if (parent && !['SCRIPT', 'STYLE', 'A', 'CODE', 'PRE'].includes(parent.tagName)) {
                textNodes.push(node);
            }
        }

        // Process each text node
        for (const textNode of textNodes) {
            const text = textNode.textContent;

            // Match patterns like "Eq. (4.2)", "equation (4.2)", "(4.2)"
            const pattern = /\b(?:Eq\.|equation)\s*\(([0-9]+\.[0-9]+)\)|\(([0-9]+\.[0-9]+)\)/gi;

            if (pattern.test(text)) {
                // Create a temporary container to build the replacement HTML
                const tempDiv = document.createElement('div');
                let lastIndex = 0;
                let match;
                pattern.lastIndex = 0; // Reset regex

                while ((match = pattern.exec(text)) !== null) {
                    const eqNum = match[1] || match[2];
                    const fullMatch = match[0];

                    // Add text before match
                    if (match.index > lastIndex) {
                        tempDiv.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                    }

                    // Create link to equation with tooltip
                    const link = document.createElement('a');
                    link.href = `#eq-${eqNum}`;
                    link.className = 'equation-ref';
                    link.textContent = fullMatch;

                    // Add tooltip with formula preview
                    link.setAttribute('data-equation-ref', eqNum);
                    link.addEventListener('mouseenter', showEquationTooltip);
                    link.addEventListener('mouseleave', hideEquationTooltip);

                    tempDiv.appendChild(link);

                    lastIndex = match.index + fullMatch.length;
                }

                // Add remaining text
                if (lastIndex < text.length) {
                    tempDiv.appendChild(document.createTextNode(text.substring(lastIndex)));
                }

                // Replace the text node with the new content
                if (tempDiv.childNodes.length > 0) {
                    const parent = textNode.parentNode;
                    while (tempDiv.firstChild) {
                        parent.insertBefore(tempDiv.firstChild, textNode);
                    }
                    parent.removeChild(textNode);
                }
            }
        }
    }

    /**
     * Show equation tooltip on hover
     * @private
     */
    function showEquationTooltip(event) {
        const link = event.target;
        const eqNum = link.getAttribute('data-equation-ref');
        const targetEq = document.getElementById(`eq-${eqNum}`);

        if (!targetEq) return;

        // Find the formula data
        const formulaId = targetEq.getAttribute('data-formula-id');
        let formulaData = null;
        if (formulaId && PaperRenderer._data?.formulas) {
            formulaData = PaperRenderer._data.formulas[formulaId];
        }

        // Create tooltip
        const tooltip = document.createElement('div');
        tooltip.className = 'equation-tooltip';
        tooltip.innerHTML = `
            <div class="tooltip-header">Equation ${eqNum}</div>
            ${formulaData ? `
                <div class="tooltip-latex">$$${formulaData.latex}$$</div>
                ${formulaData.description ? `<div class="tooltip-desc">${formulaData.description}</div>` : ''}
            ` : ''}
            <div class="tooltip-hint">Click to jump to equation</div>
        `;

        document.body.appendChild(tooltip);

        // Position tooltip
        const rect = link.getBoundingClientRect();
        tooltip.style.position = 'fixed';
        tooltip.style.left = rect.left + 'px';
        tooltip.style.top = (rect.bottom + 10) + 'px';

        // Typeset MathJax in tooltip
        if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
            MathJax.typesetPromise([tooltip]).catch(() => {});
        }

        // Store reference for memory-safe cleanup (WeakMap auto-releases when link is GC'd)
        PaperRenderer._tooltipCache.set(link, tooltip);
    }

    /**
     * Hide equation tooltip
     * @private
     */
    function hideEquationTooltip(event) {
        const link = event.target;
        const tooltip = PaperRenderer._tooltipCache.get(link);
        if (tooltip) {
            tooltip.remove();
            PaperRenderer._tooltipCache.delete(link);
        }
    }

    /**
     * Process parameters in a container
     * Replaces data-pm-value elements with actual values
     * @private
     */
    function processParameters(container) {
        // Process data-pm-value elements
        const pmValueElements = container.querySelectorAll('[data-pm-value]');

        pmValueElements.forEach(el => {
            const path = el.getAttribute('data-pm-value');
            const format = el.getAttribute('data-format');

            if (window.PM && typeof window.PM.get === 'function') {
                const value = window.PM.get(path);
                if (value !== null && value !== undefined) {
                    el.textContent = formatValue(value, format);
                    el.classList.add('pm-loaded');
                    el.classList.remove('pm-loading', 'pm-error');
                }
            }
        });

        // Process data-category + data-param elements
        const categoryElements = container.querySelectorAll('[data-category][data-param]');

        categoryElements.forEach(el => {
            const category = el.getAttribute('data-category');
            const param = el.getAttribute('data-param');
            const format = el.getAttribute('data-format');

            if (window.PM && typeof window.PM.get === 'function') {
                // Try multiple paths
                const paths = [
                    `simulations.${param}`,
                    `simulations.${category}.${param}`,
                    `parameters.${category}.${param}`,
                    `${category}.${param}`
                ];

                for (const path of paths) {
                    let value = window.PM.get(path);

                    // Auto-extract .value property if present
                    if (value !== null && value !== undefined && typeof value === 'object' && 'value' in value) {
                        // Check for renderable_value first (for complex values like dicts/lists)
                        if ('renderable_value' in value) {
                            value = value.renderable_value;
                        } else {
                            value = value.value;
                        }
                    }

                    if (value !== null && value !== undefined) {
                        el.textContent = formatValue(value, format);
                        el.classList.add('pm-loaded');
                        el.classList.remove('pm-loading', 'pm-error');
                        break;
                    }
                }
            }
        });
    }

    /**
     * Render a formula by ID
     * @param {string} formulaId - Formula ID
     * @returns {string|null} - HTML/LaTeX string
     */
    function renderFormula(formulaId) {
        if (!window.PM || typeof window.PM.formula !== 'function') {
            console.error('PMPaperRenderer: PM.formula() not available');
            return null;
        }

        const formula = window.PM.formula(formulaId);
        if (!formula) {
            console.warn(`PMPaperRenderer: Formula not found: ${formulaId}`);
            return null;
        }

        return formula.html || formula.latex || formula.plainText || null;
    }

    // ========================================================================
    // UTILITY FUNCTIONS
    // ========================================================================

    /**
     * Format a value for display
     * @private
     */
    function formatValue(value, format) {
        if (value === null || value === undefined) return '?';

        if (typeof value === 'number') {
            if (format) {
                if (format.startsWith('scientific:')) {
                    const decimals = parseInt(format.split(':')[1]) || 2;
                    return value.toExponential(decimals);
                }
                if (format.startsWith('fixed:')) {
                    const decimals = parseInt(format.split(':')[1]) || 2;
                    return value.toFixed(decimals);
                }
                if (format === 'percent') {
                    return (value * 100).toFixed(1) + '%';
                }
                if (format === 'integer') {
                    return Math.round(value).toString();
                }
            }

            // Auto-format based on magnitude
            if (Math.abs(value) >= 1e10 || (Math.abs(value) < 0.001 && value !== 0)) {
                return value.toExponential(2);
            } else if (Number.isInteger(value)) {
                return value.toString();
            } else {
                return value.toFixed(3);
            }
        }

        if (typeof value === 'boolean') {
            return value ? 'Yes' : 'No';
        }

        return String(value);
    }

    /**
     * Convert Unicode math to LaTeX notation
     * @param {string} content - Plain text with Unicode math symbols
     * @returns {string} - LaTeX formatted string
     * @private
     */
    function convertToLatex(content) {
        if (!content || typeof content !== 'string') return '';

        return content
            // HTML subscripts and superscripts - convert to LaTeX FIRST
            .replace(/<sub>([^<]+)<\/sub>/gi, '_{$1}')
            .replace(/<sup>([^<]+)<\/sup>/gi, '^{$1}')
            // Strip any remaining HTML tags
            .replace(/<[^>]+>/g, '')
            // Greek letters
            .replace(/α/g, '\\alpha ')
            .replace(/β/g, '\\beta ')
            .replace(/γ/g, '\\gamma ')
            .replace(/δ/g, '\\delta ')
            .replace(/ε/g, '\\epsilon ')
            .replace(/ζ/g, '\\zeta ')
            .replace(/η/g, '\\eta ')
            .replace(/θ/g, '\\theta ')
            .replace(/λ/g, '\\lambda ')
            .replace(/μ/g, '\\mu ')
            .replace(/ν/g, '\\nu ')
            .replace(/π/g, '\\pi ')
            .replace(/ρ/g, '\\rho ')
            .replace(/σ/g, '\\sigma ')
            .replace(/τ/g, '\\tau ')
            .replace(/φ/g, '\\phi ')
            .replace(/χ/g, '\\chi ')
            .replace(/ψ/g, '\\psi ')
            .replace(/ω/g, '\\omega ')
            // Capital Greek
            .replace(/Γ/g, '\\Gamma ')
            .replace(/Δ/g, '\\Delta ')
            .replace(/Θ/g, '\\Theta ')
            .replace(/Λ/g, '\\Lambda ')
            .replace(/Ξ/g, '\\Xi ')
            .replace(/Π/g, '\\Pi ')
            .replace(/Σ/g, '\\Sigma ')
            .replace(/Φ/g, '\\Phi ')
            .replace(/Ψ/g, '\\Psi ')
            .replace(/Ω/g, '\\Omega ')
            // Math operators
            .replace(/∫/g, '\\int ')
            .replace(/∑/g, '\\sum ')
            .replace(/∏/g, '\\prod ')
            .replace(/√/g, '\\sqrt')
            .replace(/∂/g, '\\partial ')
            .replace(/∇/g, '\\nabla ')
            .replace(/∞/g, '\\infty ')
            // Relations
            .replace(/≈/g, '\\approx ')
            .replace(/≡/g, '\\equiv ')
            .replace(/≠/g, '\\neq ')
            .replace(/≤/g, '\\leq ')
            .replace(/≥/g, '\\geq ')
            .replace(/≪/g, '\\ll ')
            .replace(/≫/g, '\\gg ')
            .replace(/∈/g, '\\in ')
            .replace(/∉/g, '\\notin ')
            .replace(/⊂/g, '\\subset ')
            .replace(/⊃/g, '\\supset ')
            // Operators
            .replace(/×/g, '\\times ')
            .replace(/÷/g, '\\div ')
            .replace(/±/g, '\\pm ')
            .replace(/∓/g, '\\mp ')
            .replace(/⊗/g, '\\otimes ')
            .replace(/⊕/g, '\\oplus ')
            .replace(/→/g, '\\rightarrow ')
            .replace(/←/g, '\\leftarrow ')
            .replace(/↔/g, '\\leftrightarrow ')
            .replace(/⇒/g, '\\Rightarrow ')
            .replace(/⇐/g, '\\Leftarrow ')
            // Brackets
            .replace(/⟨/g, '\\langle ')
            .replace(/⟩/g, '\\rangle ')
            .replace(/⌊/g, '\\lfloor ')
            .replace(/⌋/g, '\\rfloor ')
            .replace(/⌈/g, '\\lceil ')
            .replace(/⌉/g, '\\rceil ')
            // Misc
            .replace(/ℏ/g, '\\hbar ')
            .replace(/ℓ/g, '\\ell ')
            .replace(/†/g, '^\\dagger ')
            .replace(/′/g, "'")
            // Hebrew letters (for k_gimel)
            .replace(/ℷ/g, '\\gimel ')
            .replace(/ℵ/g, '\\aleph ')
            .replace(/ℶ/g, '\\beth ')
            // Text dashes - minimal rendering (captions extracted separately)
            .replace(/—/g, ' \\text{—} ')
            .replace(/–/g, ' \\text{–} ')
            // Newlines become line breaks
            .replace(/\n/g, ' \\\\ ')
            // Mathematical Greek (U+1D6AA-U+1D6E1)
            .replace(/𝛤/g, '\\Gamma ')
            .replace(/𝛥/g, '\\Delta ')
            .replace(/𝛩/g, '\\Theta ')
            .replace(/𝛬/g, '\\Lambda ')
            .replace(/𝛯/g, '\\Xi ')
            .replace(/𝛱/g, '\\Pi ')
            .replace(/𝛴/g, '\\Sigma ')
            .replace(/𝛶/g, '\\Upsilon ')
            .replace(/𝛷/g, '\\Phi ')
            .replace(/𝛹/g, '\\Psi ')
            .replace(/𝛺/g, '\\Omega ')
            .replace(/𝛼/g, '\\alpha ')
            .replace(/𝛽/g, '\\beta ')
            .replace(/𝛾/g, '\\gamma ')
            .replace(/𝛿/g, '\\delta ')
            .replace(/𝜀/g, '\\epsilon ')
            .replace(/𝜁/g, '\\zeta ')
            .replace(/𝜂/g, '\\eta ')
            .replace(/𝜃/g, '\\theta ')
            .replace(/𝜄/g, '\\iota ')
            .replace(/𝜅/g, '\\kappa ')
            .replace(/𝜆/g, '\\lambda ')
            .replace(/𝜇/g, '\\mu ')
            .replace(/𝜈/g, '\\nu ')
            .replace(/𝜉/g, '\\xi ')
            .replace(/𝜋/g, '\\pi ')
            .replace(/𝜌/g, '\\rho ')
            .replace(/𝜎/g, '\\sigma ')
            .replace(/𝜏/g, '\\tau ')
            .replace(/𝜐/g, '\\upsilon ')
            .replace(/𝜑/g, '\\phi ')
            .replace(/𝜒/g, '\\chi ')
            .replace(/𝜓/g, '\\psi ')
            .replace(/𝜔/g, '\\omega ')
            // Multi-digit exponents: ^26 -> ^{26}
            .replace(/\^(\d{2,})/g, '^{$1}')
            // Combining overline for Dirac adjoint: Ψ̄ -> \bar{\Psi}
            .replace(/([A-Za-z\u0391-\u03C9])̄/g, '\\bar{$1}')
            .replace(/([A-Za-z\u0391-\u03C9])̅/g, '\\bar{$1}')
            // Unicode superscript digits to LaTeX
            .replace(/⁰/g, '^{0}')
            .replace(/¹/g, '^{1}')
            .replace(/²/g, '^{2}')
            .replace(/³/g, '^{3}')
            .replace(/⁴/g, '^{4}')
            .replace(/⁵/g, '^{5}')
            .replace(/⁶/g, '^{6}')
            .replace(/⁷/g, '^{7}')
            .replace(/⁸/g, '^{8}')
            .replace(/⁹/g, '^{9}')
            .replace(/⁺/g, '^{+}')
            .replace(/⁻/g, '^{-}')
            .replace(/⁽/g, '^{(')
            .replace(/⁾/g, ')}')
            // Unicode subscript digits to LaTeX
            .replace(/₀/g, '_{0}')
            .replace(/₁/g, '_{1}')
            .replace(/₂/g, '_{2}')
            .replace(/₃/g, '_{3}')
            .replace(/₄/g, '_{4}')
            .replace(/₅/g, '_{5}')
            .replace(/₆/g, '_{6}')
            .replace(/₇/g, '_{7}')
            .replace(/₈/g, '_{8}')
            .replace(/₉/g, '_{9}')
            .replace(/₊/g, '_{+}')
            .replace(/₋/g, '_{-}')
            .replace(/₍/g, '_{(')
            .replace(/₎/g, ')}')
            // Common subscript letters
            .replace(/ₐ/g, '_{a}')
            .replace(/ₑ/g, '_{e}')
            .replace(/ₕ/g, '_{h}')
            .replace(/ᵢ/g, '_{i}')
            .replace(/ⱼ/g, '_{j}')
            .replace(/ₖ/g, '_{k}')
            .replace(/ₗ/g, '_{l}')
            .replace(/ₘ/g, '_{m}')
            .replace(/ₙ/g, '_{n}')
            .replace(/ₒ/g, '_{o}')
            .replace(/ₚ/g, '_{p}')
            .replace(/ᵣ/g, '_{r}')
            .replace(/ₛ/g, '_{s}')
            .replace(/ₜ/g, '_{t}')
            .replace(/ᵤ/g, '_{u}')
            .replace(/ᵥ/g, '_{v}')
            .replace(/ₓ/g, '_{x}')
            // Merge adjacent braces: ^{5}^{(} -> ^{5(}
            .replace(/\}\^?\{/g, '')
            .replace(/\}_?\{/g, '')
            // Fix double backslashes from newlines in math mode
            .replace(/\s*\\\\\s*/g, ' \\quad ')
            // Common gauge group patterns: SU(3)C -> SU(3)_C
            .replace(/SU\((\d)\)([CLRYW])/g, 'SU($1)_{$2}')
            .replace(/U\(1\)([CLRYW])/g, 'U(1)_{$1}')
            .replace(/SO\((\d+)\)([CLRYW])/g, 'SO($1)_{$2}')
            .replace(/Spin\((\d+),(\d+)\)([CLRYW])?/g, (m, a, b, c) => c ? `\\text{Spin}($1,$2)_{${c}}` : `\\text{Spin}(${a},${b})`)
            // Direct product notation
            .replace(/⊕/g, '\\oplus ')
            .replace(/⊗/g, '\\otimes ')
            .replace(/⊖/g, '\\ominus ')
            // Fix common patterns like 8s, 8c, 8v -> 8_s, 8_c, 8_v (spinor/conjugate/vector)
            .replace(/(\d+)([scv])(?=\s|\)|,|\}|$)/g, '$1_{$2}');
    }

    /**
     * Escape HTML special characters
     * @private
     */
    function escapeHtml(text) {
        // Handle non-string inputs
        if (text === null || text === undefined) return '';
        if (typeof text === 'object') {
            console.warn('PMPaperRenderer: escapeHtml received object, converting:', text);
            text = JSON.stringify(text);
        }
        if (typeof text !== 'string') {
            text = String(text);
        }
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }

    /**
     * Format a scientific value with proper notation
     * @private
     */
    function formatScientificValue(value) {
        if (typeof value === 'number') {
            if (Math.abs(value) >= 1e4 || (Math.abs(value) < 0.001 && value !== 0)) {
                return value.toExponential(3);
            } else if (Number.isInteger(value)) {
                return value.toString();
            } else {
                return value.toFixed(4);
            }
        }
        return String(value);
    }

    /**
     * Get category badge HTML
     * @private
     */
    function getCategoryBadge(category) {
        const badges = {
            'ESTABLISHED': '<span class="badge badge-established">ESTABLISHED</span><p class="badge-desc">Well-established result from literature</p>',
            'THEORY': '<span class="badge badge-theory">THEORY</span><p class="badge-desc">Core theoretical prediction of Principia Metaphysica</p>',
            'DERIVED': '<span class="badge badge-derived">DERIVED</span><p class="badge-desc">Derived from fundamental principles</p>',
            'PREDICTION': '<span class="badge badge-prediction">PREDICTION</span><p class="badge-desc">Novel prediction to be tested</p>',
            'EXPERIMENTAL': '<span class="badge badge-experimental">EXPERIMENTAL</span><p class="badge-desc">Experimental measurement or constraint</p>'
        };
        return badges[category] || `<span class="badge badge-unknown">${category}</span>`;
    }

    /**
     * Trigger MathJax typesetting on a specific element
     * @param {HTMLElement} element - Element to typeset
     */
    function typesetMathJax(element) {
        if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
            MathJax.typesetPromise([element]).catch(err => {
                console.warn('PMPaperRenderer: MathJax typesetting failed:', err);
            });
        } else if (typeof MathJax !== 'undefined' && MathJax.Hub) {
            MathJax.Hub.Queue(['Typeset', MathJax.Hub, element]);
        }
    }

    /**
     * Clean up paper renderer resources
     * Call this when removing paper from DOM or before re-rendering
     * @public
     */
    function cleanup() {
        // Abort any pending fetch requests
        PaperRenderer._abortControllers.forEach(controller => {
            controller.abort();
        });
        PaperRenderer._abortControllers.clear();

        // Clear caches
        PaperRenderer._sectionsCache.clear();
        PaperRenderer._formulaCache.clear();

        // Clean up event listeners
        // (WeakMap will automatically clean up when elements are garbage collected)

        console.log('PMPaperRenderer: Cleaned up resources');
    }

    /**
     * Refresh paper renderer by reloading data
     * @param {string} containerId - Container ID
     * @param {Object} options - Rendering options
     * @returns {Promise<boolean>} - Success status
     * @public
     */
    async function refresh(containerId, options = {}) {
        cleanup();
        PaperRenderer._loaded = false;
        PaperRenderer._loading = null;
        PaperRenderer._data = null;
        return renderPaper(containerId, options);
    }

    // ========================================================================
    // PUBLIC API
    // ========================================================================

    const API = {
        // Core rendering functions
        renderPaper,
        renderSection,
        renderFormula,
        renderEquation,

        // Processing functions
        processFormulas,
        processParameters,
        processEquationReferences,

        // Utility functions
        typesetMathJax,
        cleanup,
        refresh,

        // State accessors
        get data() { return PaperRenderer._data; },
        get loaded() { return PaperRenderer._loaded; },
        get debug() { return PaperRenderer._debug; },
        set debug(value) { PaperRenderer._debug = value; }
    };

    // Export globally
    window.PMPaperRenderer = API;

    // Export for ES modules
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = API;
    }

    console.log('PMPaperRenderer: Ready (v1.1.0 - Enhanced error handling & loading states)');

})();
