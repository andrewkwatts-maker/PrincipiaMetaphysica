/**
 * PM Paper Parameter Component
 * ============================
 *
 * Enhanced parameter display for paper rendering with full scientific rigor.
 * Displays parameters with proper scientific notation, units, uncertainties, and tooltips.
 *
 * Usage in paper content:
 *   <pm-param-paper key="gauge.M_GUT"></pm-param-paper>
 *   <pm-param-paper key="higgs.m_higgs_pred" format="scientific"></pm-param-paper>
 *   <pm-param-paper key="constants.M_PLANCK" show-uncertainty="true"></pm-param-paper>
 *
 * Features:
 * - Automatic lookup from AutoGenerated/parameters.json
 * - Scientific notation formatting
 * - Proper unit rendering (GeV, eV^2, dimensionless)
 * - Uncertainty display (± Δvalue)
 * - Source attribution (ESTABLISHED, DERIVED, PREDICTED, etc.)
 * - Rich tooltip with full metadata
 * - Links to full parameter page
 *
 * Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
 */

class PMPaperParam extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this._paramData = null;
    }

    static get observedAttributes() {
        return ['key', 'format', 'show-uncertainty', 'show-units', 'show-source', 'inline'];
    }

    connectedCallback() {
        this.render();
    }

    attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue !== newValue) {
            this.render();
        }
    }

    async loadParameterData(key) {
        // Check if parameters are already loaded in window.PM
        if (window.PM && window.PM.parameters && window.PM.parameters[key]) {
            return window.PM.parameters[key];
        }

        // Check window.PM_DATA
        if (window.PM_DATA && window.PM_DATA.parameters && window.PM_DATA.parameters[key]) {
            return window.PM_DATA.parameters[key];
        }

        // Load from AutoGenerated/parameters.json
        const pathPrefixes = [
            '/AutoGenerated/',
            'AutoGenerated/',
            './AutoGenerated/',
            '../AutoGenerated/',
            '../../AutoGenerated/'
        ];

        for (const prefix of pathPrefixes) {
            try {
                const path = prefix + 'parameters.json';
                const response = await fetch(path);
                if (response.ok) {
                    const data = await response.json();
                    const params = data.parameters || data;

                    // Cache in window.PM
                    if (!window.PM) window.PM = {};
                    window.PM.parameters = params;

                    return params[key] || null;
                }
            } catch (e) {
                continue;
            }
        }

        return null;
    }

    async render() {
        const key = this.getAttribute('key');
        if (!key) {
            this.shadowRoot.innerHTML = '<span style="color: red;">[Missing parameter key]</span>';
            return;
        }

        // Load parameter data
        this._paramData = await this.loadParameterData(key);

        if (!this._paramData) {
            this.shadowRoot.innerHTML = `<span style="color: red;" title="Parameter not found: ${key}">[${key}]</span>`;
            return;
        }

        const format = this.getAttribute('format') || 'auto';
        const showUncertainty = this.getAttribute('show-uncertainty') === 'true';
        const showUnits = this.getAttribute('show-units') !== 'false'; // Default true
        const showSource = this.getAttribute('show-source') === 'true';
        const inline = this.getAttribute('inline') !== 'false'; // Default true

        const styles = this.getStyles();
        const content = this.renderParameter(format, showUncertainty, showUnits, showSource, inline);

        this.shadowRoot.innerHTML = `
            <style>${styles}</style>
            ${content}
        `;

        // Add event listeners for tooltips
        this.setupTooltip();
    }

    renderParameter(format, showUncertainty, showUnits, showSource, inline) {
        const param = this._paramData;
        const value = param.value;
        const uncertainty = param.uncertainty;
        const units = param.metadata?.units || '';
        const description = param.metadata?.description || '';
        const source = param.source || '';
        const status = param.status || '';

        // Format the value
        const formattedValue = this.formatValue(value, format, units);

        // Build the display
        let html = inline
            ? '<span class="pm-param-inline">'
            : '<span class="pm-param-block">';

        html += `<span class="pm-param-value" title="${description}">${formattedValue}</span>`;

        // Add uncertainty if requested and available
        if (showUncertainty && uncertainty !== null && uncertainty !== undefined) {
            const formattedUncertainty = this.formatValue(uncertainty, format, units, true);
            html += `<span class="pm-param-uncertainty"> ± ${formattedUncertainty}</span>`;
        }

        // Add units if requested
        if (showUnits && units && units !== 'dimensionless') {
            html += `<span class="pm-param-units"> ${this.formatUnits(units)}</span>`;
        }

        // Add source if requested
        if (showSource && status) {
            const statusBadge = this.getStatusBadge(status);
            html += `<span class="pm-param-source">${statusBadge}</span>`;
        }

        html += '</span>';

        // Add tooltip
        html += this.renderTooltip();

        return html;
    }

    formatValue(value, format, units, isUncertainty = false) {
        if (value === null || value === undefined) return 'N/A';
        if (typeof value !== 'number') return String(value);

        // Determine format
        let actualFormat = format;
        if (format === 'auto') {
            // Auto-detect based on magnitude
            const absValue = Math.abs(value);
            if (absValue === 0) {
                actualFormat = 'fixed';
            } else if (absValue >= 1e10 || absValue < 1e-3) {
                actualFormat = 'scientific';
            } else if (Number.isInteger(value)) {
                actualFormat = 'integer';
            } else {
                actualFormat = 'fixed';
            }
        }

        switch (actualFormat) {
            case 'scientific':
                return this.toScientificNotation(value, isUncertainty ? 1 : 2);

            case 'fixed':
                const decimals = this.getAppropriateDecimals(value, isUncertainty);
                return value.toFixed(decimals);

            case 'integer':
                return Math.round(value).toString();

            case 'engineering':
                return this.toEngineeringNotation(value);

            default:
                return value.toPrecision(4);
        }
    }

    toScientificNotation(value, significantDigits = 2) {
        if (value === 0) return '0';

        const exp = value.toExponential(significantDigits);
        const [mantissa, exponent] = exp.split('e');
        const expNum = parseInt(exponent);

        // Use proper Unicode superscripts for cleaner display
        return `${mantissa} × 10<sup>${expNum}</sup>`;
    }

    toEngineeringNotation(value) {
        if (value === 0) return '0';

        const exp = Math.floor(Math.log10(Math.abs(value)));
        const engExp = Math.floor(exp / 3) * 3;
        const mantissa = value / Math.pow(10, engExp);

        return `${mantissa.toFixed(2)} × 10<sup>${engExp}</sup>`;
    }

    getAppropriateDecimals(value, isUncertainty) {
        if (isUncertainty) return 1;

        const absValue = Math.abs(value);
        if (absValue >= 1000) return 0;
        if (absValue >= 100) return 1;
        if (absValue >= 10) return 2;
        if (absValue >= 1) return 3;
        return 4;
    }

    formatUnits(units) {
        // Convert units to proper formatting
        // Examples: "GeV" -> "GeV", "eV^2" -> "eV²", "GeV·s" -> "GeV·s"

        return units
            .replace(/\^2/g, '²')
            .replace(/\^3/g, '³')
            .replace(/\^-1/g, '⁻¹')
            .replace(/\^-2/g, '⁻²')
            .replace(/\^-3/g, '⁻³')
            .replace(/\*/g, '·');
    }

    getStatusBadge(status) {
        const badges = {
            'ESTABLISHED': '<span class="status-badge status-established">ESTABLISHED</span>',
            'DERIVED': '<span class="status-badge status-derived">DERIVED</span>',
            'PREDICTED': '<span class="status-badge status-predicted">PREDICTED</span>',
            'GEOMETRIC': '<span class="status-badge status-geometric">GEOMETRIC</span>',
            'CALIBRATED': '<span class="status-badge status-calibrated">CALIBRATED</span>',
            'PHENOMENOLOGICAL': '<span class="status-badge status-phenomenological">PHENOM</span>'
        };
        return badges[status] || `<span class="status-badge">${status}</span>`;
    }

    renderTooltip() {
        const param = this._paramData;
        const key = this.getAttribute('key');

        const description = param.metadata?.description || '';
        const source = param.source || '';
        const status = param.status || '';
        const units = param.metadata?.units || '';
        const uncertainty = param.uncertainty;

        return `
            <div class="pm-param-tooltip">
                <div class="tooltip-header">
                    <strong>${key}</strong>
                    ${status ? `<span class="tooltip-status">${status}</span>` : ''}
                </div>
                ${description ? `<div class="tooltip-desc">${description}</div>` : ''}
                <div class="tooltip-meta">
                    ${source ? `<div><em>Source:</em> ${source}</div>` : ''}
                    ${units ? `<div><em>Units:</em> ${this.formatUnits(units)}</div>` : ''}
                    ${uncertainty ? `<div><em>Uncertainty:</em> ±${this.formatValue(uncertainty, 'auto', units, true)}</div>` : ''}
                </div>
                <div class="tooltip-link">
                    <a href="parameters.html#${key}" target="_blank">View full details →</a>
                </div>
            </div>
        `;
    }

    setupTooltip() {
        const paramEl = this.shadowRoot.querySelector('.pm-param-inline, .pm-param-block');
        const tooltip = this.shadowRoot.querySelector('.pm-param-tooltip');

        if (!paramEl || !tooltip) return;

        paramEl.addEventListener('mouseenter', () => {
            tooltip.classList.add('visible');
        });

        paramEl.addEventListener('mouseleave', () => {
            tooltip.classList.remove('visible');
        });
    }

    getStyles() {
        return `
            :host {
                display: inline;
                position: relative;
            }

            .pm-param-inline,
            .pm-param-block {
                position: relative;
                cursor: help;
                white-space: nowrap;
            }

            .pm-param-inline {
                display: inline;
            }

            .pm-param-block {
                display: block;
                padding: 0.25rem 0;
            }

            .pm-param-value {
                font-weight: 600;
                color: #1a1a1a;
                border-bottom: 1px dotted rgba(102, 126, 234, 0.5);
                padding-bottom: 1px;
            }

            .pm-param-uncertainty {
                font-size: 0.9em;
                color: #555;
                margin-left: 0.2em;
            }

            .pm-param-units {
                font-size: 0.9em;
                color: #666;
                margin-left: 0.15em;
                font-style: normal;
            }

            .pm-param-source {
                margin-left: 0.5em;
            }

            .status-badge {
                display: inline-block;
                padding: 2px 6px;
                border-radius: 3px;
                font-size: 0.7em;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.3px;
            }

            .status-established {
                background: #e8f5e9;
                color: #2e7d32;
            }

            .status-derived {
                background: #e3f2fd;
                color: #1976d2;
            }

            .status-predicted {
                background: #fff3e0;
                color: #f57c00;
            }

            .status-geometric {
                background: #f3e5f5;
                color: #7b1fa2;
            }

            .status-calibrated {
                background: #fce4ec;
                color: #c2185b;
            }

            .status-phenomenological {
                background: #f1f8e9;
                color: #558b2f;
            }

            /* Tooltip styles */
            .pm-param-tooltip {
                position: absolute;
                bottom: calc(100% + 8px);
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, rgba(20, 20, 35, 0.98), rgba(30, 30, 50, 0.95));
                border: 1px solid rgba(139, 127, 255, 0.3);
                border-radius: 8px;
                padding: 12px 16px;
                min-width: 280px;
                max-width: 400px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
                z-index: 10000;
                font-size: 0.85rem;
                line-height: 1.5;
                opacity: 0;
                visibility: hidden;
                transition: opacity 0.2s, visibility 0.2s;
                pointer-events: none;
                color: #e0e0e0;
                font-family: 'Crimson Text', Georgia, serif;
            }

            .pm-param-tooltip.visible {
                opacity: 1;
                visibility: visible;
            }

            /* Tooltip arrow */
            .pm-param-tooltip::after {
                content: '';
                position: absolute;
                top: 100%;
                left: 50%;
                transform: translateX(-50%);
                border: 6px solid transparent;
                border-top-color: rgba(30, 30, 50, 0.95);
            }

            .tooltip-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
                color: #fff;
                font-weight: 600;
            }

            .tooltip-status {
                font-size: 0.75em;
                color: #8b7fff;
                background: rgba(139, 127, 255, 0.2);
                padding: 2px 6px;
                border-radius: 3px;
            }

            .tooltip-desc {
                color: #bbb;
                margin-bottom: 10px;
                font-size: 0.9em;
                line-height: 1.4;
            }

            .tooltip-meta {
                margin: 8px 0;
                padding: 8px 0;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                font-size: 0.85em;
            }

            .tooltip-meta div {
                margin: 4px 0;
                color: #ccc;
            }

            .tooltip-meta em {
                color: #888;
                font-style: normal;
                margin-right: 4px;
            }

            .tooltip-link {
                margin-top: 8px;
                padding-top: 8px;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
            }

            .tooltip-link a {
                color: #8b7fff;
                text-decoration: none;
                font-size: 0.85em;
                transition: color 0.2s;
            }

            .tooltip-link a:hover {
                color: #a89fff;
                text-decoration: underline;
            }

            /* Scientific notation superscripts */
            sup {
                font-size: 0.7em;
                vertical-align: super;
                line-height: 0;
            }

            /* Mobile responsive */
            @media (max-width: 768px) {
                .pm-param-tooltip {
                    min-width: 200px;
                    max-width: 90vw;
                    font-size: 0.8rem;
                }
            }

            /* Print styles */
            @media print {
                .pm-param-tooltip {
                    display: none !important;
                }

                .pm-param-value {
                    border-bottom: none;
                }
            }
        `;
    }
}

// Register the custom element
if (!customElements.get('pm-param-paper')) {
    customElements.define('pm-param-paper', PMPaperParam);
}

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { PMPaperParam };
}

console.log('PMPaperParam: Component ready for scientific parameter display');
