<!DOCTYPE html>
<!--
    Copyright (c) 2025 Andrew Keith Watts. All rights reserved.

    This is the intellectual property of Andrew Keith Watts. Unauthorized
    reproduction, distribution, or modification of this code, in whole or in part,
    without the express written permission of Andrew Keith Watts is strictly prohibited.

    For inquiries, please contact AndrewKWatts@Gmail.com
-->
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Complete parameter reference for Principia Metaphysica - geometric, derived, calibrated, predicted, and experimental parameters" name="description"/>
    <title>Theory Parameters - Principia Metaphysica</title>
    <link href="../css/styles.css" rel="stylesheet"/>
    <link href="../css/pm-common.css" rel="stylesheet"/>
    <link rel="stylesheet" href="../css/auth.css">

    <!-- MathJax for mathematical symbols -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                tags: 'ams'
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        /* Page-specific styles */
        .parameters-hero {
            background: linear-gradient(135deg, rgba(139, 127, 255, 0.15), rgba(81, 207, 102, 0.1));
            border: 2px solid rgba(139, 127, 255, 0.3);
            border-radius: 20px;
            padding: 3rem;
            margin-bottom: 2.5rem;
            text-align: center;
            position: relative;
        }

        .parameters-hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-primary), #51cf66);
            border-radius: 20px 20px 0 0;
        }

        .parameters-hero h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--accent-primary), #51cf66);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
        }

        .parameters-hero p {
            color: var(--text-secondary);
            font-size: 1.1rem;
            max-width: 800px;
            margin: 0 auto;
        }

        /* Filter controls */
        .filter-controls {
            background: rgba(26, 31, 58, 0.5);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .filter-group label {
            color: var(--text-primary);
            font-weight: 600;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-group input[type="text"],
        .filter-group select {
            padding: 0.875rem 1.25rem;
            border: 1px solid rgba(139, 127, 255, 0.3);
            border-radius: 12px;
            background: rgba(139, 127, 255, 0.15);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            color: #f8f9fa;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .filter-group input[type="text"]:focus,
        .filter-group select:focus {
            outline: none;
            background: rgba(139, 127, 255, 0.2);
            border-color: rgba(139, 127, 255, 0.6);
            box-shadow:
                0 0 0 3px rgba(139, 127, 255, 0.15),
                0 0 20px rgba(139, 127, 255, 0.2);
        }

        .filter-group input[type="text"]::placeholder {
            color: rgba(248, 249, 250, 0.5);
        }

        /* Select dropdown options - dark background for readability */
        .filter-group select {
            cursor: pointer;
        }

        /* Dropdown options - ensure dark background for all browsers */
        .filter-group select option {
            background-color: #1a1f3a !important;
            color: #f8f9fa !important;
            padding: 0.5rem;
        }

        .filter-group select option:hover,
        .filter-group select option:focus,
        .filter-group select option:checked {
            background-color: rgba(139, 127, 255, 0.5) !important;
            color: #ffffff !important;
        }

        /* Firefox-specific dropdown styling */
        @-moz-document url-prefix() {
            .filter-group select option {
                background-color: #1a1f3a;
                color: #f8f9fa;
            }
        }

        /* Statistics bar */
        .stats-bar {
            background: rgba(26, 31, 58, 0.5);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 1.5rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            display: block;
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-primary);
        }

        .stat-label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 0.25rem;
        }

        /* Category sections */
        .category-section {
            background: rgba(26, 31, 58, 0.4);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid rgba(139, 127, 255, 0.2);
            position: relative;
        }

        .category-header::before {
            content: '';
            position: absolute;
            top: -1rem;
            left: -1rem;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(139, 127, 255, 0.15) 0%, transparent 70%);
            pointer-events: none;
        }

        .category-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: capitalize;
            text-shadow: 0 0 20px rgba(139, 127, 255, 0.3);
        }

        .category-count {
            background: rgba(139, 127, 255, 0.15);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(139, 127, 255, 0.3);
            color: var(--accent-primary);
            padding: 0.35rem 0.85rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        /* Parameter cards */
        .parameter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
        }

        .parameter-card {
            background: rgba(26, 31, 58, 0.5);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 1.5rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .parameter-card:hover {
            background: rgba(26, 31, 58, 0.7);
            border-color: rgba(139, 127, 255, 0.3);
            transform: translateY(-2px) scale(1.01);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .parameter-card.filtered-out {
            display: none;
        }

        .param-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }

        .param-name {
            font-family: 'Courier New', monospace;
            font-weight: 700;
            font-size: 1rem;
            color: var(--accent-primary);
        }

        .param-status-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        .status-DERIVED {
            background: rgba(139, 127, 255, 0.15);
            border: 1px solid rgba(139, 127, 255, 0.3);
            color: #8b7fff;
        }
        .status-PREDICTED {
            background: rgba(255, 183, 77, 0.15);
            border: 1px solid rgba(255, 183, 77, 0.3);
            color: #ffb74d;
        }
        .status-INPUT {
            background: rgba(77, 182, 255, 0.15);
            border: 1px solid rgba(77, 182, 255, 0.3);
            color: #4db6ff;
        }
        .status-MEASURED {
            background: rgba(81, 207, 102, 0.15);
            border: 1px solid rgba(81, 207, 102, 0.3);
            color: #51cf66;
        }
        .status-GEOMETRIC {
            background: rgba(81, 207, 102, 0.15);
            border: 1px solid rgba(81, 207, 102, 0.3);
            color: #51cf66;
        }
        .status-PASS,
        .status-RESOLVED {
            background: rgba(81, 207, 102, 0.15);
            border: 1px solid rgba(81, 207, 102, 0.3);
            color: #51cf66;
        }
        .status-CHECK,
        .status-PENDING {
            background: rgba(255, 183, 77, 0.15);
            border: 1px solid rgba(255, 183, 77, 0.3);
            color: #ffb74d;
        }
        .status-SPECULATIVE {
            background: rgba(255, 126, 182, 0.15);
            border: 1px solid rgba(255, 126, 182, 0.3);
            color: var(--accent-secondary);
        }

        .param-symbol {
            font-size: 1.8rem;
            color: var(--text-primary);
            margin: 0.75rem 0;
            font-style: italic;
        }

        .param-value-display {
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(139, 127, 255, 0.15);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(139, 127, 255, 0.3);
            border-radius: 8px;
        }

        .param-value {
            font-family: 'Source Code Pro', monospace;
            font-size: 1.3rem;
            font-weight: 600;
            color: #f8f9fa;
        }

        .param-units {
            color: rgba(248, 249, 250, 0.7);
            font-size: 0.9rem;
            font-style: italic;
            font-weight: 500;
        }

        .param-uncertainty {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-left: 0.5rem;
        }

        .param-description {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        .param-metadata {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-primary);
            font-size: 0.85rem;
        }

        .metadata-item {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            color: var(--text-muted);
        }

        .metadata-label {
            font-weight: 600;
            color: var(--text-secondary);
        }

        .param-comparison {
            background: rgba(81, 207, 102, 0.08);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(81, 207, 102, 0.3);
            border-radius: 8px;
            padding: 0.75rem;
            margin-top: 1rem;
        }

        .comparison-header {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }

        .comparison-values {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            font-size: 0.85rem;
        }

        .comparison-item {
            display: flex;
            flex-direction: column;
        }

        .comparison-label {
            color: var(--text-muted);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .comparison-value {
            color: var(--text-primary);
            font-family: 'Source Code Pro', monospace;
            font-weight: 600;
            margin-top: 0.25rem;
        }

        .deviation-indicator {
            margin-top: 0.5rem;
            font-size: 0.8rem;
            padding: 0.35rem 0.6rem;
            border-radius: 6px;
            text-align: center;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        .deviation-good {
            background: rgba(81, 207, 102, 0.15);
            border: 1px solid rgba(81, 207, 102, 0.3);
            color: #51cf66;
        }

        .deviation-moderate {
            background: rgba(255, 183, 77, 0.15);
            border: 1px solid rgba(255, 183, 77, 0.3);
            color: #ffb74d;
        }

        .deviation-high {
            background: rgba(255, 126, 182, 0.15);
            border: 1px solid rgba(255, 126, 182, 0.3);
            color: var(--accent-secondary);
        }

        .formula-links {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-primary);
        }

        .formula-links-header {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .formula-link-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .formula-link {
            display: inline-block;
            padding: 0.35rem 0.75rem;
            background: rgba(139, 127, 255, 0.1);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            border: 1px solid rgba(139, 127, 255, 0.3);
            border-radius: 8px;
            color: var(--accent-primary);
            text-decoration: none;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .formula-link:hover {
            background: rgba(139, 127, 255, 0.2);
            border-color: rgba(139, 127, 255, 0.5);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 127, 255, 0.2);
        }

        /* View Toggle */
        .view-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            justify-content: center;
        }

        .view-btn {
            padding: 0.75rem 1.5rem;
            background: rgba(26, 31, 58, 0.5);
            border: 1px solid rgba(139, 127, 255, 0.3);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .view-btn:hover {
            background: rgba(139, 127, 255, 0.15);
            color: var(--text-primary);
        }

        .view-btn.active {
            background: linear-gradient(135deg, rgba(139, 127, 255, 0.25), rgba(255, 126, 182, 0.15));
            border-color: rgba(139, 127, 255, 0.5);
            color: var(--text-primary);
        }

        /* OOM Gap Table */
        .oom-table-container {
            background: rgba(26, 31, 58, 0.4);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 1.5rem;
            overflow-x: auto;
            display: none;
        }

        .oom-table-container.active {
            display: block;
        }

        .oom-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .oom-table th {
            background: rgba(139, 127, 255, 0.15);
            color: var(--text-primary);
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid rgba(139, 127, 255, 0.3);
            cursor: pointer;
            white-space: nowrap;
            user-select: none;
        }

        .oom-table th:hover {
            background: rgba(139, 127, 255, 0.25);
        }

        .oom-table th.sort-asc::after {
            content: ' ▲';
            font-size: 0.7rem;
        }

        .oom-table th.sort-desc::after {
            content: ' ▼';
            font-size: 0.7rem;
        }

        .oom-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
        }

        .oom-table tr:hover td {
            background: rgba(139, 127, 255, 0.08);
        }

        .oom-table .param-name-cell {
            font-family: 'Courier New', monospace;
            color: var(--accent-primary);
            font-weight: 500;
        }

        .oom-table .sigma-cell {
            font-weight: 600;
        }

        .oom-table .sigma-good {
            color: #51cf66;
        }

        .oom-table .sigma-moderate {
            color: #ffb74d;
        }

        .oom-table .sigma-warning {
            color: var(--accent-secondary);
        }

        .oom-table .sigma-high {
            color: #f87171;
        }

        .table-info {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }

        /* Loading state */
        .loading-state {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
        }

        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(139, 127, 255, 0.2);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error-message {
            background: rgba(255, 126, 182, 0.1);
            border: 1px solid rgba(255, 126, 182, 0.3);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            color: var(--accent-secondary);
        }

        /* No results message */
        .no-results {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        /* Navigation links */
        .nav-links {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-primary);
        }

        .nav-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background: rgba(139, 127, 255, 0.1);
            border: 1px solid rgba(139, 127, 255, 0.3);
            border-radius: 10px;
            color: var(--text-primary);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            background: rgba(139, 127, 255, 0.2);
            transform: translateY(-2px);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .parameter-grid {
                grid-template-columns: 1fr;
            }

            .filter-controls {
                grid-template-columns: 1fr;
            }

            .stats-bar {
                flex-direction: column;
            }
        }
    </style>
    <script src="../js/pm-constants-loader.js"></script>
</head>
<body class="auth-loading">
    <div id="main-content" style="display: none;">
    <!-- Header injected by pm-header.js -->

    <main>
        <nav aria-label="Breadcrumb" class="breadcrumb">
            <a href="../index.html">Home</a>
            <span class="separator">/</span>
            <span class="current">Theory Parameters</span>
        </nav>

        <!-- Hero Section -->
        <div class="parameters-hero">
            <h1>Theory Parameters</h1>
            <p>
                Complete reference of all theoretical parameters from Principia Metaphysica.
                Dynamically loaded from <code>theory_output.json</code> - includes registry, simulations, and formulas.
                <br><strong>Use Table View to sort by σ deviation and identify the weakest predictions.</strong>
            </p>
        </div>

        <!-- Statistics Bar -->
        <div class="stats-bar">
            <div class="stat-item">
                <span class="stat-value" id="stat-total">0</span>
                <span class="stat-label">Total Parameters</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="stat-visible">0</span>
                <span class="stat-label">Visible</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="stat-categories">0</span>
                <span class="stat-label">Categories</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="stat-validated">0</span>
                <span class="stat-label">Validated</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="stat-within-1sigma">0</span>
                <span class="stat-label">Within 1σ</span>
            </div>
        </div>

        <!-- View Toggle -->
        <div class="view-toggle">
            <button id="card-view-btn" class="view-btn active">Card View</button>
            <button id="table-view-btn" class="view-btn">Table View (OOM Gap)</button>
        </div>

        <!-- Filter Controls -->
        <div class="filter-controls">
            <div class="filter-group">
                <label for="search-input">Search</label>
                <input type="text" id="search-input" placeholder="Filter by name or description...">
            </div>
            <div class="filter-group">
                <label for="category-filter">Category</label>
                <select id="category-filter">
                    <option value="">All Categories</option>
                    <!-- Dynamically populated -->
                </select>
            </div>
            <div class="filter-group">
                <label for="status-filter">Status</label>
                <select id="status-filter">
                    <option value="">All Statuses</option>
                    <option value="DERIVED">Derived</option>
                    <option value="PREDICTED">Predicted</option>
                    <option value="INPUT">Input</option>
                    <option value="MEASURED">Measured</option>
                    <option value="GEOMETRIC">Geometric</option>
                </select>
            </div>
        </div>

        <!-- Loading State -->
        <div id="loading-indicator" class="loading-state">
            <div class="loading-spinner"></div>
            <p>Loading all parameters from theory_output.json...</p>
        </div>

        <!-- Error State -->
        <div id="error-indicator" class="error-message" style="display: none;">
            <h3>Failed to Load Parameters</h3>
            <p id="error-message"></p>
        </div>

        <!-- Parameters Container (Card View) -->
        <div id="parameters-container" style="display: none;">
            <!-- Dynamically populated category sections -->
        </div>

        <!-- OOM Gap Table Container -->
        <div id="oom-table-container" class="oom-table-container">
            <p class="table-info">
                Sortable table showing all parameters with their sigma (σ) deviation from experiment.
                <strong>Click column headers to sort.</strong> Higher sigma = weaker prediction.
            </p>
            <table class="oom-table">
                <thead>
                    <tr>
                        <th data-sort="name">Parameter</th>
                        <th data-sort="category">Category</th>
                        <th data-sort="status">Status</th>
                        <th data-sort="sigma" class="sort-desc">σ Deviation</th>
                        <th data-sort="computed">Computed</th>
                        <th data-sort="experimental">Experimental</th>
                        <th data-sort="units">Units</th>
                    </tr>
                </thead>
                <tbody id="oom-table-body">
                    <!-- Dynamically populated -->
                </tbody>
            </table>
        </div>

        <!-- No Results -->
        <div id="no-results" class="no-results" style="display: none;">
            <p>No parameters match your filter criteria.</p>
        </div>

        <!-- Navigation -->
        <div class="nav-links">
            <a class="nav-link" href="../index.html">← Back to Home</a>
            <a class="nav-link" href="formulas.html">View Formulas →</a>
        </div>
    </main>

    <footer>
        <p>
            <strong>Principia Metaphysica</strong><br/>
            © 2025 Andrew Keith Watts. All rights reserved.
        </p>
    </footer>
    </div>

    <script type="module">
        import { injectHeader } from './js/pm-header.js';
        import { setupAuthGuard } from './js/auth-guard.js';

        // Inject header first
        document.addEventListener('DOMContentLoaded', () => {
            injectHeader('parameters');
        });

        // Setup auth after header
        setupAuthGuard('parameters');
    </script>

    <script>
        // ====================================================================
        // PARAMETERS PAGE - Dynamic Loading from parameters.json
        // ====================================================================

        let allParameters = [];
        let parametersByCategory = {};
        let formulaDatabase = {};

        // Configuration for parameter metadata
        const CATEGORY_DISPLAY_NAMES = {
            // Core Categories
            'dimensions': 'Spacetime Dimensions',
            'topology': 'G₂ Topology',
            'dark_energy': 'Dark Energy',
            'gauge': 'Gauge Unification',
            'electroweak': 'Electroweak Parameters',
            'yukawa': 'Yukawa Couplings',
            'fermion_masses': 'Fermion Masses',
            'ckm': 'CKM Mixing Matrix',
            'pmns': 'PMNS Mixing Angles',
            'neutrino': 'Neutrino Physics',
            'higgs': 'Higgs Sector',

            // Extended Physics
            'proton_decay': 'Proton Decay',
            'kk_spectrum': 'Kaluza-Klein Spectrum',
            'pneuma': 'Pneuma Field',
            'xy_bosons': 'X/Y Gauge Bosons',
            'mirror_sector': 'Mirror Sector',
            'cosmology': 'Cosmology',

            // Data Sources
            'simulations': 'Simulation Results',
            'formulas': 'Formula Validations',
            'nested_validations': 'Detailed Validations',
            'uncategorized': 'Other Parameters'
        };

        const PARAMETER_SYMBOLS = {
            // Dimensions
            'D_BULK': 'D_{\\text{bulk}}',
            'D_AFTER_SP2R': 'D_{\\text{Sp(2,R)}}',
            'D_INTERNAL': 'D_{\\text{int}}',
            'D_EFFECTIVE': 'D_{\\text{eff}}',
            'D_COMMON': 'D_{\\text{common}}',
            'M_PLANCK': 'M_{\\text{Pl}}',
            'M_BULK': 'M_{\\text{bulk}}',

            // Topology
            'CHI_EFF': '\\chi_{\\text{eff}}',
            'B2': 'b_2',
            'B3': 'b_3',
            'n_flux': 'N_{\\text{flux}}',
            'HODGE_H11': 'h^{1,1}',
            'HODGE_H21': 'h^{2,1}',
            'HODGE_H31': 'h^{3,1}',
            'n_gen': 'n_{\\text{gen}}',
            'chi_eff_computed': '\\chi_{\\text{eff}}^{\\text{comp}}',

            // Dark Energy
            'w0': 'w_0',
            'wa': 'w_a',
            'd_eff': 'd_{\\text{eff}}',
            'alpha_T': '\\alpha_T',

            // Gauge
            'ALPHA_GUT': '\\alpha_{\\text{GUT}}',
            'ALPHA_GUT_INV': '\\alpha_{\\text{GUT}}^{-1}',
            'M_GUT': 'M_{\\text{GUT}}',
            'WEAK_MIXING_ANGLE': '\\sin^2\\theta_W',
            'alpha_s': '\\alpha_s',

            // Proton Decay
            'tau_p_years': '\\tau_p',
            'BR_epi0': 'BR(e^+\\pi^0)',

            // PMNS
            'theta_12': '\\theta_{12}',
            'theta_23': '\\theta_{23}',
            'theta_13': '\\theta_{13}',
            'delta_CP': '\\delta_{CP}',
            'delta_cp': '\\delta_{CP}',  // lowercase variant

            // Neutrino
            'delta_m21_sq': '\\Delta m_{21}^2',
            'delta_m31_sq': '\\Delta m_{31}^2',
            'm_nu_1': 'm_{\\nu_1}',
            'm_nu_2': 'm_{\\nu_2}',
            'm_nu_3': 'm_{\\nu_3}',
            'sum_m_nu': '\\sum m_\\nu',
            'm_rh_neutrino': 'M_{\\text{RH}}',

            // KK Spectrum
            'm1_TeV': 'm_{\\text{KK}}',

            // Pneuma
            'VEV': '\\langle\\Psi_P\\rangle',

            // XY Bosons
            'M_X': 'M_X',
            'M_Y': 'M_Y',

            // Mirror Sector
            'temperature_ratio': 'T\'/T',
            'dm_baryon_ratio': '\\Omega_{\\text{DM}}/\\Omega_b',
            'modulation_width': '\\Delta_{\\text{mod}}',
            'n_sectors': 'N_{\\text{sectors}}',
            'gravity_dilution': 'f_{\\text{grav}}',

            // Higgs
            'mu': '\\mu',
            'lambda_H': '\\lambda_H',

            // Proton decay additional
            'SUPER_K_BOUND': '\\tau_p^{\\text{SK}}',
            'ratio_to_bound': '\\tau_p / \\tau_p^{\\text{SK}}',
            'suppression': 'f_{\\text{supp}}',

            // Neutrino additional
            'm_nu_1': 'm_{\\nu_1}',
            'm_nu_2': 'm_{\\nu_2}',
            'm_nu_3': 'm_{\\nu_3}',
            'sum_m_nu': '\\sum m_\\nu',
            'hierarchy': 'H_{\\nu}',

            // KK additional
            'uncertainty_TeV': '\\sigma_{m_{\\text{KK}}}',
            'LHC_BOUND_TEV': 'm_{\\text{KK}}^{\\text{LHC}}',

            // Other
            'D_SHARED_EXTRAS': 'D_{\\text{shared}}',
            'average_deviation_sigma': '\\langle\\sigma\\rangle',
            'source_version': '\\text{Version}'
        };

        const PARAMETER_DESCRIPTIONS = {
            // Dimensions
            'D_BULK': 'Bulk spacetime dimensions from bosonic string theory',
            'D_AFTER_SP2R': 'Dimensions after Sp(2,ℝ) reduction',
            'D_INTERNAL': 'Internal G₂ manifold dimensions',
            'D_EFFECTIVE': 'Effective dimensions after compactification',
            'D_COMMON': 'Common observable spacetime dimensions',
            'M_PLANCK': 'Planck mass scale',
            'M_BULK': 'Bulk Planck mass',

            // Topology
            'CHI_EFF': 'Effective Euler characteristic of G₂ manifold #187',
            'B2': 'Second Betti number (number of 2-cycles)',
            'B3': 'Third Betti number (number of 3-cycles)',
            'n_flux': 'Flux quantization number',
            'n_gen': 'Number of fermion generations',

            // Dark Energy
            'w0': 'Dark energy equation of state parameter at z=0',
            'wa': 'Dark energy evolution parameter',
            'd_eff': 'Effective dimension for dark energy',
            'alpha_T': 'Temperature coupling parameter',

            // Gauge
            'ALPHA_GUT': 'GUT coupling constant α_GUT',
            'ALPHA_GUT_INV': 'Inverse GUT coupling 1/α_GUT ≈ 23.54',
            'M_GUT': 'GUT unification scale',
            'WEAK_MIXING_ANGLE': 'Weinberg angle sin²θ_W',
            'alpha_s': 'Strong coupling at M_Z',

            // Proton Decay
            'tau_p_years': 'Predicted proton lifetime',
            'BR_epi0': 'Branching ratio for p → e⁺π⁰',

            // PMNS
            'theta_12': 'Solar neutrino mixing angle',
            'theta_23': 'Atmospheric neutrino mixing angle',
            'theta_13': 'Reactor neutrino mixing angle',
            'delta_CP': 'CP-violating phase',

            // Neutrino
            'delta_m21_sq': 'Solar mass-squared difference',
            'delta_m31_sq': 'Atmospheric mass-squared difference',
            'sum_m_nu': 'Sum of neutrino masses',
            'm_rh_neutrino': 'Right-handed Majorana neutrino mass (seesaw)',
            'm_nu_1': 'Lightest neutrino mass eigenstate',
            'm_nu_2': 'Second neutrino mass eigenstate',
            'm_nu_3': 'Heaviest neutrino mass eigenstate',
            'hierarchy': 'Neutrino mass hierarchy',

            // KK
            'm1_TeV': 'First Kaluza-Klein excitation mass',
            'uncertainty_TeV': 'KK mass uncertainty',
            'LHC_BOUND_TEV': 'LHC experimental bound',

            // Pneuma
            'VEV': 'Pneuma field vacuum expectation value',

            // XY
            'M_X': 'X gauge boson mass',
            'M_Y': 'Y gauge boson mass',

            // Mirror
            'temperature_ratio': 'Mirror sector temperature ratio',
            'dm_baryon_ratio': 'Dark matter to baryon density ratio',
            'modulation_width': 'Geometric width from G₂ cycle overlap',
            'n_sectors': 'Number of mirror sectors',
            'gravity_dilution': 'Gravitational interaction dilution factor',

            // Proton Decay
            'SUPER_K_BOUND': 'Super-Kamiokande experimental lower bound',
            'ratio_to_bound': 'Ratio of prediction to experimental bound',
            'suppression': 'Proton decay suppression factor',

            // Higgs
            'mu': 'Higgs mass parameter',
            'lambda_H': 'Higgs quartic coupling',

            // Other
            'D_SHARED_EXTRAS': 'Shared extra dimensions',
            'SIGNATURE_INITIAL': 'Initial spacetime signature',
            'SIGNATURE_BULK': 'Bulk spacetime signature',
            'chi_eff_computed': 'Computed effective Euler characteristic',
            'average_deviation_sigma': 'Average deviation from experiment',
            'source_version': 'Reference data version'
        };

        // Initialize the page
        async function initializePage() {
            try {
                // Load ALL data from theory_output.json
                const theoryData = await loadTheoryOutputJSON();

                // Load formulas for cross-referencing
                await loadFormulasJSON();

                // Process and organize ALL parameters
                processAllParameters(theoryData);

                // Populate category filter
                populateCategoryFilter();

                // Render the parameters
                renderParameters();

                // Render the OOM table
                renderOOMTable();

                // Setup event listeners
                setupEventListeners();

                // Setup view toggle
                setupViewToggle();

                // Setup table sorting
                setupTableSorting();

                // Update statistics
                updateStatistics();

                // Hide loading, show content
                hideLoading();

            } catch (error) {
                console.error('Error initializing parameters page:', error);
                showError(error.message);
            }
        }

        async function loadTheoryOutputJSON() {
            const paths = [
                'AutoGenerated/theory_output.json',  // Primary location
                'AutoGenerated/theory_output.json', // Alternative casing
                'theory_output.json',
                '../AutoGenerated/theory_output.json',
                '../AutoGenerated/theory_output.json',
                '../theory_output.json'
            ];

            for (const path of paths) {
                try {
                    const response = await fetch(path);
                    if (response.ok) {
                        const data = await response.json();
                        console.log(`✓ Loaded theory_output.json from ${path}`);
                        console.log(`  Version: ${data.version}`);
                        console.log(`  Simulations: ${Object.keys(data.simulations || {}).length}`);
                        console.log(`  Parameters: ${Object.keys(data.parameters || {}).length}`);
                        console.log(`  Framework Stats: ${data.framework_statistics ? 'YES' : 'NO'}`);
                        return data;
                    }
                } catch (e) {
                    console.debug(`  Failed to load ${path}: ${e.message}`);
                    continue;
                }
            }

            throw new Error('Could not load theory_output.json. Please run: python run_all_simulations.py');
        }

        // Extract ALL parameters from theory_output.json
        function processAllParameters(theoryData) {
            allParameters = [];
            parametersByCategory = {};

            // 1. Extract from framework_statistics.registry.parameters (56 core SM params)
            if (theoryData.framework_statistics?.registry?.parameters) {
                const registry = theoryData.framework_statistics.registry.parameters;
                for (const [key, param] of Object.entries(registry)) {
                    const category = param.category || 'uncategorized';
                    if (!parametersByCategory[category]) {
                        parametersByCategory[category] = [];
                    }

                    // Extract value - handle both direct values and nested objects
                    let computedValue = param.value ?? param.computed ?? param.predicted ?? null;
                    if (typeof computedValue === 'object' && computedValue !== null && 'value' in computedValue) {
                        computedValue = computedValue.value;
                    }

                    // Get experimental value if available
                    let experimentalValue = param.experimental ?? null;
                    if (typeof experimentalValue === 'object' && experimentalValue !== null && 'value' in experimentalValue) {
                        experimentalValue = experimentalValue.value;
                    }

                    // Get units
                    let units = param.units || '';
                    if (typeof param.experimental === 'object' && param.experimental?.units) {
                        units = param.experimental.units;
                    }

                    // Get uncertainty
                    let uncertainty = param.uncertainty ?? null;
                    if (typeof param.experimental === 'object' && param.experimental?.uncertainty) {
                        uncertainty = param.experimental.uncertainty;
                    }

                    const paramObj = {
                        key,
                        displayName: param.name || formatParameterName(key),
                        category,
                        status: param.status || 'DERIVED',
                        sigma: param.sigma ?? null,
                        value: computedValue,
                        computed: computedValue,
                        experimental: experimentalValue,
                        displayValue: formatValue(computedValue),
                        units: units,
                        uncertainty: uncertainty,
                        symbol: PARAMETER_SYMBOLS[key] || '',
                        description: PARAMETER_DESCRIPTIONS[key] || param.name || '',
                        source: 'registry'
                    };
                    allParameters.push(paramObj);
                    parametersByCategory[category].push(paramObj);
                }
            }

            // 2. Extract from simulations (35 simulations with validation data)
            if (theoryData.simulations) {
                for (const [simKey, sim] of Object.entries(theoryData.simulations)) {
                    // Skip error entries
                    if (sim.error) continue;

                    if (sim.validation) {
                        const category = 'simulations';
                        if (!parametersByCategory[category]) {
                            parametersByCategory[category] = [];
                        }

                        // Extract computed and experimental values
                        let computedValue = sim.validation.computed;
                        let experimentalValue = sim.validation.experimental ?? sim.validation.bound;

                        // Handle nested value objects
                        if (typeof computedValue === 'object' && computedValue !== null && 'value' in computedValue) {
                            computedValue = computedValue.value;
                        }
                        if (typeof experimentalValue === 'object' && experimentalValue !== null && 'value' in experimentalValue) {
                            experimentalValue = experimentalValue.value;
                        }

                        const paramObj = {
                            key: simKey,
                            displayName: formatParameterName(simKey),
                            category,
                            status: sim.status || 'CHECK',
                            sigma: sim.validation.sigma ?? null,
                            value: computedValue,
                            computed: computedValue,
                            experimental: experimentalValue,
                            displayValue: formatValue(computedValue),
                            units: sim.validation.units || '',
                            symbol: '',
                            description: sim.mechanism || sim.formula?.plain_text || '',
                            source: 'simulations'
                        };
                        allParameters.push(paramObj);
                        parametersByCategory[category].push(paramObj);
                    }

                    // Extract nested validation data (like neutrino_masses.validation)
                    extractNestedValidations(sim, simKey);
                }
            }

            // 3. Extract from formulas (computed vs experimental values)
            if (theoryData.formulas) {
                for (const [fKey, formula] of Object.entries(theoryData.formulas)) {
                    if (formula.computedValue !== undefined && formula.experimentalValue !== undefined) {
                        const category = 'formulas';
                        if (!parametersByCategory[category]) {
                            parametersByCategory[category] = [];
                        }

                        const paramObj = {
                            key: fKey,
                            displayName: formula.label || formatParameterName(fKey),
                            category,
                            status: formula.status || 'DERIVED',
                            sigma: formula.sigmaDeviation ?? null,
                            computed: formula.computedValue,
                            experimental: formula.experimentalValue,
                            units: formula.units || '',
                            symbol: '',
                            description: formula.description || '',
                            source: 'formulas'
                        };
                        allParameters.push(paramObj);
                        parametersByCategory[category].push(paramObj);
                    }
                }
            }

            console.log(`Processed ${allParameters.length} total parameters across ${Object.keys(parametersByCategory).length} categories`);
        }

        function extractNestedValidations(obj, parentKey, depth = 0) {
            if (depth > 3 || typeof obj !== 'object' || obj === null) return;

            for (const [key, value] of Object.entries(obj)) {
                if (key === 'validation' && typeof value === 'object') {
                    // Skip if already processed as main validation
                    if (parentKey.includes('.')) continue;

                    // Check for nested validations like solar_splitting, atmospheric_splitting
                    for (const [subKey, subVal] of Object.entries(value)) {
                        if (typeof subVal === 'object' && subVal !== null && subVal.computed !== undefined) {
                            const category = 'nested_validations';
                            if (!parametersByCategory[category]) {
                                parametersByCategory[category] = [];
                            }

                            // Extract computed and experimental values
                            let computedValue = subVal.computed;
                            let experimentalValue = subVal.experimental ?? subVal.bound;

                            // Handle nested value objects
                            if (typeof computedValue === 'object' && computedValue !== null && 'value' in computedValue) {
                                computedValue = computedValue.value;
                            }
                            if (typeof experimentalValue === 'object' && experimentalValue !== null && 'value' in experimentalValue) {
                                experimentalValue = experimentalValue.value;
                            }

                            const fullKey = `${parentKey}.${subKey}`;
                            const paramObj = {
                                key: fullKey,
                                displayName: formatParameterName(subKey),
                                category,
                                status: subVal.status?.includes('PASS') ? 'PASS' : 'CHECK',
                                sigma: subVal.sigma ?? null,
                                value: computedValue,
                                computed: computedValue,
                                experimental: experimentalValue,
                                displayValue: formatValue(computedValue),
                                units: subVal.units || '',
                                symbol: '',
                                description: `From ${parentKey}`,
                                source: 'nested'
                            };
                            allParameters.push(paramObj);
                            parametersByCategory[category].push(paramObj);
                        }
                    }
                } else if (typeof value === 'object') {
                    extractNestedValidations(value, `${parentKey}.${key}`, depth + 1);
                }
            }
        }

        async function loadParametersJSON() {
            // Load parameters.json from AutoGenerated
            const paths = [
                '/AutoGenerated/parameters.json',     // Absolute path (for live site)
                'AutoGenerated/parameters.json',      // Relative from root
                './AutoGenerated/parameters.json',    // Explicit relative
                '../AutoGenerated/parameters.json',   // From subdirectory
                '../../AutoGenerated/parameters.json' // From nested subdirectory
            ];

            for (const path of paths) {
                try {
                    console.log(`Trying to load parameters from: ${path}`);
                    const response = await fetch(path);
                    if (response.ok) {
                        const data = await response.json();
                        console.log(`Successfully loaded parameters from ${path}`);
                        console.log(`Version: ${data.version}`);
                        return data;
                    }
                } catch (e) {
                    continue;
                }
            }

            throw new Error('Could not load AutoGenerated/parameters.json. Please run: python run_all_simulations.py --export');
        }

        async function loadFormulasJSON() {
            // Load formulas from theory_output.json (already loaded in main data)
            // This function now serves as a placeholder - formulas are in theoryData
            console.log('Formulas loaded from theory_output.json');
        }

        function processParameters(data) {
            allParameters = [];
            parametersByCategory = {};

            // Iterate through all categories in the JSON
            for (const [category, params] of Object.entries(data)) {
                if (category === 'version') continue;

                parametersByCategory[category] = [];

                // Handle nested parameters
                processCategory(category, params);
            }

            console.log(`Processed ${allParameters.length} parameters across ${Object.keys(parametersByCategory).length} categories`);
        }

        function processCategory(category, params, parentKey = '') {
            // Internal metadata fields that should NOT be displayed as parameters
            const SKIP_KEYS = ['metadata', 'timestamp', 'render', 'hidden', 'version', 'config_source', 'description'];

            for (const [key, value] of Object.entries(params)) {
                // Skip internal metadata keys
                if (SKIP_KEYS.includes(key)) {
                    continue;
                }

                // Skip if this is a standalone description field at category level
                if (key === 'description' && typeof value === 'string') {
                    continue;
                }

                // Skip date-only strings that look like timestamps
                if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(value)) {
                    continue;
                }

                // Skip count strings like "2 parameters"
                if (typeof value === 'string' && /^\d+\s+(parameter|item|field)s?$/i.test(value)) {
                    continue;
                }

                // Skip if explicitly marked as hidden or not to render
                if (typeof value === 'object' && value !== null) {
                    if (value.hidden === true || value.render === false) {
                        continue;
                    }
                }

                const fullKey = parentKey ? `${parentKey}.${key}` : key;

                // If value is a simple parameter (number, string) or has standard fields
                if (isParameter(value)) {
                    const param = createParameter(category, fullKey, value);
                    allParameters.push(param);
                    parametersByCategory[category].push(param);
                } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                    // Recursively process nested objects
                    processCategory(category, value, fullKey);
                }
            }
        }

        function isParameter(value) {
            // A parameter is either a primitive value or an object with specific fields
            if (typeof value !== 'object' || value === null) {
                return typeof value === 'number' || typeof value === 'string';
            }

            // Arrays are always parameters (like SIGNATURE_INITIAL)
            if (Array.isArray(value)) {
                return true;
            }

            // Check for render: false or hidden: true flags
            if (value.render === false || value.hidden === true) {
                return false; // Skip this parameter
            }

            // Check for common parameter field patterns
            const paramFields = ['value', 'predicted', 'experimental', 'units', 'status', 'description', 'derivation', 'source'];
            const hasParamField = paramFields.some(field => field in value);

            // If it has parameter fields, it's a parameter
            if (hasParamField) {
                return true;
            }

            // Check if all children are primitive values (like mass_spectrum with m_nu_1, m_nu_2, etc.)
            const values = Object.values(value);
            if (values.length > 0) {
                const allPrimitive = values.every(v =>
                    typeof v === 'number' ||
                    typeof v === 'string' ||
                    typeof v === 'boolean'
                );
                // If it has a mix of primitive values and metadata fields, treat as parameter group
                if (allPrimitive || (values.some(v => typeof v === 'number') && hasParamField)) {
                    return false; // This is a container, not a parameter
                }
            }

            return false;
        }

        function createParameter(category, key, value) {
            const displayName = formatParameterName(key);

            // Try full key first, then just the last part after the dot
            const keyParts = key.split('.');
            const lastKey = keyParts[keyParts.length - 1];
            const symbol = PARAMETER_SYMBOLS[key] || PARAMETER_SYMBOLS[lastKey] || '';

            let paramValue, units, status, description, experimental, predicted, uncertainty, derivation, source;
            let observed, observedUncertainty, deviationPercent, sigmaAgreement;

            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                // Extract primary value in order of preference
                paramValue = value.value ?? value.predicted ?? value.experimental ?? value.observed ?? null;

                // If no explicit value field and object has numeric properties, it might be a composite
                if (paramValue === null) {
                    // Check if this is a pure container (shouldn't happen but just in case)
                    paramValue = value;
                }

                units = value.units || '';
                status = value.status || 'DERIVED';
                description = value.description || value.derivation || PARAMETER_DESCRIPTIONS[key] || PARAMETER_DESCRIPTIONS[lastKey] || '';
                experimental = value.experimental;
                predicted = value.predicted;
                observed = value.observed;
                observedUncertainty = value.observed_uncertainty || value.experimental_error;
                uncertainty = value.predicted_error || value.experimental_error || value.uncertainty;
                derivation = value.derivation;
                source = value.source;
                deviationPercent = value.deviation_percent;
                sigmaAgreement = value.sigma_agreement;
            } else {
                // Primitive value (number, string, or array)
                paramValue = value;
                units = inferUnits(key);
                status = 'GEOMETRIC';
                description = PARAMETER_DESCRIPTIONS[key] || PARAMETER_DESCRIPTIONS[lastKey] || '';
            }

            return {
                category,
                key,
                displayName,
                symbol,
                value: paramValue,
                displayValue: formatValue(paramValue),
                units,
                status,
                description,
                experimental,
                predicted,
                observed,
                observedUncertainty,
                uncertainty,
                derivation,
                source,
                deviationPercent,
                sigmaAgreement,
                relatedFormulas: findRelatedFormulas(key)
            };
        }

        function formatParameterName(key) {
            // Handle dot notation - show full path for nested parameters
            const parts = key.split('.');

            if (parts.length > 1) {
                // For nested parameters, show the full path in a readable way
                return parts.map(part =>
                    part
                        .replace(/_/g, ' ')
                        .replace(/([A-Z])/g, ' $1')
                        .trim()
                        .split(' ')
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                        .join(' ')
                ).join(' → ');
            }

            // For top-level parameters, just format the name
            return key
                .replace(/_/g, ' ')
                .replace(/([A-Z])/g, ' $1')
                .trim()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ');
        }

        function formatValue(value) {
            if (value === null || value === undefined) return '—';
            if (typeof value === 'boolean') return value ? 'Yes' : 'No';
            if (Array.isArray(value)) return value.join(', ');

            if (typeof value === 'number') {
                const abs = Math.abs(value);
                if (abs === 0) return '0';
                if (abs >= 1e10 || (abs < 0.001 && abs > 0)) {
                    return value.toExponential(3);
                } else if (Number.isInteger(value)) {
                    return value.toLocaleString();
                } else {
                    return value.toPrecision(4);
                }
            }

            return String(value);
        }

        function inferUnits(key) {
            const unitPatterns = {
                '_TeV': 'TeV',
                '_GeV': 'GeV',
                '_eV': 'eV',
                '_years': 'years',
                'theta_': 'degrees',
                'delta_CP': 'degrees',
                'alpha_': 'dimensionless',
                'm_': 'GeV',
                'M_': 'GeV',
                'tau_': 'years'
            };

            for (const [pattern, unit] of Object.entries(unitPatterns)) {
                if (key.includes(pattern)) return unit;
            }

            return '';
        }

        function findRelatedFormulas(paramKey) {
            const related = [];
            const keyParts = paramKey.split('.');
            const lastKey = keyParts[keyParts.length - 1];

            for (const [formulaId, formula] of Object.entries(formulaDatabase)) {
                // Check if parameter appears in formula terms
                // Try both full key and last part
                if (formula.terms && (paramKey in formula.terms || lastKey in formula.terms)) {
                    related.push({
                        id: formulaId,
                        label: formula.label || formulaId,
                        section: formula.section
                    });
                }
            }

            return related;
        }

        function populateCategoryFilter() {
            const select = document.getElementById('category-filter');

            // Sort categories alphabetically by display name
            const categories = Object.keys(parametersByCategory).sort((a, b) => {
                const nameA = CATEGORY_DISPLAY_NAMES[a] || a;
                const nameB = CATEGORY_DISPLAY_NAMES[b] || b;
                return nameA.localeCompare(nameB);
            });

            for (const category of categories) {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = CATEGORY_DISPLAY_NAMES[category] || formatParameterName(category);
                select.appendChild(option);
            }

            console.log(`Populated category filter with ${categories.length} categories`);
        }

        function renderParameters() {
            const container = document.getElementById('parameters-container');
            container.innerHTML = '';

            // Render each category
            for (const [category, params] of Object.entries(parametersByCategory)) {
                if (params.length === 0) continue;

                const section = renderCategorySection(category, params);
                container.appendChild(section);
            }

            // Trigger MathJax rendering
            if (window.MathJax) {
                MathJax.typesetPromise();
            }
        }

        function renderCategorySection(category, params) {
            const section = document.createElement('div');
            section.className = 'category-section';
            section.dataset.category = category;

            const header = document.createElement('div');
            header.className = 'category-header';
            header.innerHTML = `
                <h2 class="category-title">${CATEGORY_DISPLAY_NAMES[category] || category}</h2>
                <span class="category-count">${params.length} parameters</span>
            `;
            section.appendChild(header);

            const grid = document.createElement('div');
            grid.className = 'parameter-grid';

            params.forEach(param => {
                const card = renderParameterCard(param);
                grid.appendChild(card);
            });

            section.appendChild(grid);
            return section;
        }

        function renderParameterCard(param) {
            const card = document.createElement('div');
            card.className = 'parameter-card';
            card.dataset.category = param.category;
            card.dataset.status = param.status;
            card.dataset.key = param.key;

            let html = `
                <div class="param-header">
                    <div class="param-name">${param.key}</div>
                    <span class="param-status-badge status-${param.status}">${param.status}</span>
                </div>
            `;

            if (param.symbol) {
                html += `<div class="param-symbol">$${param.symbol}$</div>`;
            }

            html += `
                <div class="param-value-display">
                    <span class="param-value">${param.displayValue}</span>
                    ${param.units ? `<span class="param-units">${param.units}</span>` : ''}
                    ${param.uncertainty ? `<span class="param-uncertainty">± ${formatValue(param.uncertainty)}</span>` : ''}
                </div>
            `;

            if (param.description) {
                html += `<div class="param-description">${param.description}</div>`;
            }

            // Show comparison if both computed and experimental exist
            if ((param.computed !== undefined && param.computed !== null) &&
                (param.experimental !== undefined && param.experimental !== null)) {

                // Use provided sigma if available, otherwise calculate
                let deviation, deviationText;
                if (param.sigma !== undefined && param.sigma !== null) {
                    deviation = param.sigma;
                    deviationText = `${deviation.toFixed(2)}σ`;
                } else if (param.sigmaAgreement !== undefined) {
                    deviation = param.sigmaAgreement;
                    deviationText = `${deviation.toFixed(2)}σ`;
                } else if (param.deviationPercent !== undefined) {
                    deviation = param.deviationPercent / 10; // Rough estimate
                    deviationText = `${param.deviationPercent.toFixed(1)}% deviation`;
                } else {
                    // Simple calculation if no sigma provided
                    const diff = Math.abs(param.computed - param.experimental);
                    const avg = (Math.abs(param.computed) + Math.abs(param.experimental)) / 2;
                    deviation = avg > 0 ? diff / avg : 0;
                    deviationText = `${(deviation * 100).toFixed(1)}% difference`;
                }

                const deviationClass = deviation < 1 ? 'deviation-good' : deviation < 3 ? 'deviation-moderate' : 'deviation-high';

                html += `
                    <div class="param-comparison">
                        <div class="comparison-header">PM Prediction vs Experimental</div>
                        <div class="comparison-values">
                            <div class="comparison-item">
                                <span class="comparison-label">PM Computed</span>
                                <span class="comparison-value">${formatValue(param.computed)} ${param.units || ''}</span>
                            </div>
                            <div class="comparison-item">
                                <span class="comparison-label">Experimental</span>
                                <span class="comparison-value">${formatValue(param.experimental)} ${param.units || ''}</span>
                            </div>
                        </div>
                        <div class="deviation-indicator ${deviationClass}">
                            ${deviation < 1 ? '✓ Excellent (< 1σ)' : deviation < 2 ? '✓ Good (< 2σ)' : deviation < 3 ? '~ Moderate (< 3σ)' : '⚠ Weak (≥ 3σ)'} - ${deviationText}
                        </div>
                    </div>
                `;
            } else if (param.predicted !== undefined && param.predicted !== null &&
                       (param.experimental !== undefined && param.experimental !== null)) {
                // Fallback for old data structure with 'predicted' field
                const deviation = param.sigma ?? 0;
                const deviationClass = deviation < 1 ? 'deviation-good' : deviation < 3 ? 'deviation-moderate' : 'deviation-high';

                html += `
                    <div class="param-comparison">
                        <div class="comparison-header">PM Prediction vs Experimental</div>
                        <div class="comparison-values">
                            <div class="comparison-item">
                                <span class="comparison-label">Predicted</span>
                                <span class="comparison-value">${formatValue(param.predicted)} ${param.units || ''}</span>
                            </div>
                            <div class="comparison-item">
                                <span class="comparison-label">Experimental</span>
                                <span class="comparison-value">${formatValue(param.experimental)} ${param.units || ''}</span>
                            </div>
                        </div>
                        <div class="deviation-indicator ${deviationClass}">
                            ${deviation < 1 ? '✓ Excellent' : deviation < 3 ? '~ Good' : '⚠ Moderate'} (${deviation.toFixed(2)}σ)
                        </div>
                    </div>
                `;
            }

            // Metadata
            const metadata = [];
            if (param.derivation) metadata.push(`<span class="metadata-item"><span class="metadata-label">Derivation:</span> ${param.derivation}</span>`);
            if (param.source) metadata.push(`<span class="metadata-item"><span class="metadata-label">Source:</span> ${param.source}</span>`);

            if (metadata.length > 0) {
                html += `<div class="param-metadata">${metadata.join('')}</div>`;
            }

            // Related formulas
            if (param.relatedFormulas && param.relatedFormulas.length > 0) {
                html += `
                    <div class="formula-links">
                        <div class="formula-links-header">Used in formulas:</div>
                        <div class="formula-link-list">
                            ${param.relatedFormulas.map(f =>
                                `<a href="formulas.html#${f.id}" class="formula-link">${f.label}</a>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }

            card.innerHTML = html;
            return card;
        }

        function calculateDeviation(predicted, experimental) {
            // Simple sigma calculation (would need uncertainty for proper calculation)
            const diff = Math.abs(predicted - experimental);
            const avg = (Math.abs(predicted) + Math.abs(experimental)) / 2;
            return avg > 0 ? (diff / avg) * 10 : 0; // Rough estimate
        }

        function setupEventListeners() {
            // Search
            document.getElementById('search-input').addEventListener('input', applyFilters);

            // Filters
            document.getElementById('category-filter').addEventListener('change', applyFilters);
            document.getElementById('status-filter').addEventListener('change', applyFilters);
        }

        function applyFilters() {
            const searchText = document.getElementById('search-input').value.toLowerCase();
            const categoryFilter = document.getElementById('category-filter').value;
            const statusFilter = document.getElementById('status-filter').value;

            // Filter cards in card view
            const cards = document.querySelectorAll('.parameter-card');
            let visibleCount = 0;

            cards.forEach(card => {
                const category = card.dataset.category;
                const status = card.dataset.status;
                const key = card.dataset.key;
                const param = allParameters.find(p => p.key === key && p.category === category);

                let visible = true;

                // Search filter
                if (searchText) {
                    const matchKey = key.toLowerCase().includes(searchText);
                    const matchDesc = param?.description?.toLowerCase().includes(searchText) || false;
                    const matchCategory = category.toLowerCase().includes(searchText);
                    const matchName = param?.displayName?.toLowerCase().includes(searchText) || false;
                    visible = visible && (matchKey || matchDesc || matchCategory || matchName);
                }

                // Category filter
                if (categoryFilter && category !== categoryFilter) {
                    visible = false;
                }

                // Status filter
                if (statusFilter && status !== statusFilter) {
                    visible = false;
                }

                if (visible) {
                    card.classList.remove('filtered-out');
                    visibleCount++;
                } else {
                    card.classList.add('filtered-out');
                }
            });

            // Filter table rows in table view
            const rows = document.querySelectorAll('#oom-table-body tr');
            let visibleRows = 0;

            rows.forEach(row => {
                const category = row.dataset.category;
                const status = row.dataset.status;
                const key = row.dataset.key;
                const param = allParameters.find(p => p.key === key && p.category === category);

                let visible = true;

                // Search filter
                if (searchText) {
                    const matchKey = key.toLowerCase().includes(searchText);
                    const matchDesc = param?.description?.toLowerCase().includes(searchText) || false;
                    const matchCategory = category.toLowerCase().includes(searchText);
                    const matchName = param?.displayName?.toLowerCase().includes(searchText) || false;
                    visible = visible && (matchKey || matchDesc || matchCategory || matchName);
                }

                // Category filter
                if (categoryFilter && category !== categoryFilter) {
                    visible = false;
                }

                // Status filter
                if (statusFilter && status !== statusFilter) {
                    visible = false;
                }

                if (visible) {
                    row.style.display = '';
                    visibleRows++;
                } else {
                    row.style.display = 'none';
                }
            });

            // Hide empty category sections in card view
            document.querySelectorAll('.category-section').forEach(section => {
                const visibleCards = section.querySelectorAll('.parameter-card:not(.filtered-out)');
                section.style.display = visibleCards.length > 0 ? 'block' : 'none';
            });

            // Update visible count (use card count or row count depending on active view)
            const isTableView = document.getElementById('oom-table-container').classList.contains('active');
            const displayCount = isTableView ? visibleRows : visibleCount;
            document.getElementById('stat-visible').textContent = displayCount;

            // Show/hide no results
            document.getElementById('no-results').style.display = displayCount === 0 ? 'block' : 'none';
        }

        // Render OOM Gap Table
        function renderOOMTable() {
            const tbody = document.getElementById('oom-table-body');
            tbody.innerHTML = '';

            // Filter parameters with both computed and experimental values (or sigma)
            const validParams = allParameters.filter(p =>
                (p.computed !== undefined && p.computed !== null) ||
                (p.experimental !== undefined && p.experimental !== null) ||
                (p.sigma !== null && p.sigma !== undefined)
            );

            // Sort by sigma descending (highest deviation first = weakest predictions)
            const sortedParams = [...validParams].sort((a, b) => {
                const sigmaA = a.sigma ?? -1;
                const sigmaB = b.sigma ?? -1;
                return sigmaB - sigmaA;
            });

            sortedParams.forEach(param => {
                const tr = document.createElement('tr');
                tr.dataset.key = param.key;
                tr.dataset.category = param.category;
                tr.dataset.status = param.status;

                const sigmaClass = getSigmaClass(param.sigma);
                const sigmaDisplay = param.sigma !== null && param.sigma !== undefined ? param.sigma.toFixed(2) : '—';

                // Use computed or value field
                const computedValue = param.computed ?? param.value;
                const computedDisplay = formatValue(computedValue);
                const expDisplay = formatValue(param.experimental);

                // Format units display
                const unitsDisplay = param.units || '—';

                tr.innerHTML = `
                    <td class="param-name-cell" title="${param.description || param.key}">${param.displayName || param.key}</td>
                    <td>${CATEGORY_DISPLAY_NAMES[param.category] || param.category}</td>
                    <td><span class="param-status-badge status-${param.status}">${param.status}</span></td>
                    <td class="sigma-cell ${sigmaClass}">${sigmaDisplay}</td>
                    <td>${computedDisplay}</td>
                    <td>${expDisplay}</td>
                    <td>${unitsDisplay}</td>
                `;
                tbody.appendChild(tr);
            });

            console.log(`Rendered OOM table with ${sortedParams.length} parameters (filtered from ${allParameters.length} total)`);
        }

        function getSigmaClass(sigma) {
            if (sigma === null || sigma === undefined) return '';
            if (sigma < 1) return 'sigma-good';
            if (sigma < 2) return 'sigma-moderate';
            if (sigma < 3) return 'sigma-warning';
            return 'sigma-high';
        }

        // View Toggle
        function setupViewToggle() {
            const cardViewBtn = document.getElementById('card-view-btn');
            const tableViewBtn = document.getElementById('table-view-btn');
            const cardContainer = document.getElementById('parameters-container');
            const tableContainer = document.getElementById('oom-table-container');

            cardViewBtn.addEventListener('click', () => {
                cardViewBtn.classList.add('active');
                tableViewBtn.classList.remove('active');
                cardContainer.style.display = 'block';
                tableContainer.classList.remove('active');
            });

            tableViewBtn.addEventListener('click', () => {
                tableViewBtn.classList.add('active');
                cardViewBtn.classList.remove('active');
                cardContainer.style.display = 'none';
                tableContainer.classList.add('active');
            });
        }

        // Table Sorting
        let currentSort = { column: 'sigma', direction: 'desc' };

        function setupTableSorting() {
            const headers = document.querySelectorAll('.oom-table th[data-sort]');
            headers.forEach(th => {
                th.addEventListener('click', () => {
                    const column = th.dataset.sort;

                    // Toggle direction if same column
                    if (currentSort.column === column) {
                        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentSort.column = column;
                        currentSort.direction = 'desc';
                    }

                    // Update header classes
                    headers.forEach(h => h.classList.remove('sort-asc', 'sort-desc'));
                    th.classList.add(`sort-${currentSort.direction}`);

                    // Sort the table
                    sortTable();
                });
            });
        }

        function sortTable() {
            const tbody = document.getElementById('oom-table-body');
            const rows = Array.from(tbody.querySelectorAll('tr'));

            rows.sort((a, b) => {
                let valA, valB;

                switch (currentSort.column) {
                    case 'name':
                        valA = a.dataset.key.toLowerCase();
                        valB = b.dataset.key.toLowerCase();
                        break;
                    case 'category':
                        valA = a.dataset.category.toLowerCase();
                        valB = b.dataset.category.toLowerCase();
                        break;
                    case 'status':
                        valA = a.cells[2].textContent.toLowerCase();
                        valB = b.cells[2].textContent.toLowerCase();
                        break;
                    case 'sigma':
                        valA = parseFloat(a.cells[3].textContent) || -1;
                        valB = parseFloat(b.cells[3].textContent) || -1;
                        break;
                    case 'computed':
                        valA = parseFloat(a.cells[4].textContent) || 0;
                        valB = parseFloat(b.cells[4].textContent) || 0;
                        break;
                    case 'experimental':
                        valA = parseFloat(a.cells[5].textContent) || 0;
                        valB = parseFloat(b.cells[5].textContent) || 0;
                        break;
                    default:
                        valA = a.cells[6].textContent;
                        valB = b.cells[6].textContent;
                }

                if (typeof valA === 'string') {
                    return currentSort.direction === 'asc'
                        ? valA.localeCompare(valB)
                        : valB.localeCompare(valA);
                } else {
                    return currentSort.direction === 'asc'
                        ? valA - valB
                        : valB - valA;
                }
            });

            rows.forEach(row => tbody.appendChild(row));
        }

        function updateStatistics() {
            const total = allParameters.length;
            const categories = Object.keys(parametersByCategory).length;
            const validated = allParameters.filter(p =>
                p.experimental !== undefined ||
                p.observed !== undefined ||
                p.sigma !== null ||
                p.status === 'MEASURED' ||
                p.status === 'INPUT'
            ).length;
            const within1sigma = allParameters.filter(p => p.sigma !== null && p.sigma < 1).length;

            document.getElementById('stat-total').textContent = total;
            document.getElementById('stat-visible').textContent = total;
            document.getElementById('stat-categories').textContent = categories;
            document.getElementById('stat-validated').textContent = validated;
            document.getElementById('stat-within-1sigma').textContent = within1sigma;
        }

        function hideLoading() {
            document.getElementById('loading-indicator').style.display = 'none';
            document.getElementById('parameters-container').style.display = 'block';
        }

        function showError(message) {
            document.getElementById('loading-indicator').style.display = 'none';
            document.getElementById('error-indicator').style.display = 'block';
            document.getElementById('error-message').textContent = message;
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializePage);
        } else {
            initializePage();
        }
    </script>
</body>
</html>
