#!/usr/bin/env python3
"""
Comprehensive paper quality analysis
"""
import json
import re
from pathlib import Path
from collections import Counter, defaultdict

def load_json(filepath):
    with open(filepath, 'r', encoding='utf-8') as f:
        return json.load(f)

def main():
    base_path = Path(__file__).parent / 'AutoGenerated'

    # Load data
    print("Loading data files...")
    sections_data = load_json(base_path / 'sections.json')
    formulas_data = load_json(base_path / 'formulas.json')

    sections = sections_data.get('sections', {})
    formulas = formulas_data.get('formulas', {})

    print("\n" + "="*70)
    print("PAPER QUALITY ANALYSIS")
    print("="*70)

    # 1. Section Structure
    print("\n1. SECTION STRUCTURE")
    print("-" * 70)
    section_order = []
    for sid in sorted(sections.keys(), key=lambda x: (x.isdigit(), x)):
        s = sections[sid]
        title = s.get('title', 'NO TITLE')
        order = s.get('order', 'N/A')
        blocks = len(s.get('contentBlocks', []))
        section_order.append((sid, order, title, blocks))
        print(f"  Section {sid} (order={order}): {title}")
        print(f"    Content blocks: {blocks}")

    # Check for section ordering issues
    numeric_sections = [(sid, order) for sid, order, _, _ in section_order if str(sid).isdigit()]
    if numeric_sections:
        expected_order = sorted([int(sid) for sid, _ in numeric_sections])
        actual_order = [int(sid) for sid, _ in numeric_sections]
        if expected_order != actual_order:
            print("\n  [!] Section numbering is not sequential")
            print(f"      Expected: {expected_order}")
            print(f"      Actual: {actual_order}")

    # 2. Equation Numbering
    print("\n2. EQUATION NUMBERING")
    print("-" * 70)
    formula_labels = {}
    for fid, fdata in formulas.items():
        label = fdata.get('label', 'NO LABEL')
        formula_labels[fid] = label

    # Check label format consistency
    label_formats = defaultdict(list)
    for fid, label in formula_labels.items():
        # Extract format: (X.Y) vs (X) vs other
        if re.match(r'\(\d+\.\d+\)', label):
            label_formats['(X.Y)'].append((fid, label))
        elif re.match(r'\(\d+\)', label):
            label_formats['(X)'].append((fid, label))
        else:
            label_formats['Other'].append((fid, label))

    print(f"  Total formulas: {len(formulas)}")
    for fmt, items in label_formats.items():
        print(f"  Format '{fmt}': {len(items)} formulas")
        if len(items) <= 3:
            for fid, label in items:
                print(f"    {fid}: {label}")

    # Check for sequential numbering within format
    if label_formats.get('(X.Y)'):
        labels = [label for _, label in label_formats['(X.Y)']]
        # Extract section and number
        section_nums = defaultdict(list)
        for label in labels:
            match = re.match(r'\((\d+)\.(\d+)\)', label)
            if match:
                sec, num = int(match.group(1)), int(match.group(2))
                section_nums[sec].append(num)

        print("\n  Equation numbering by section:")
        for sec in sorted(section_nums.keys()):
            nums = sorted(section_nums[sec])
            expected = list(range(1, len(nums) + 1))
            print(f"    Section {sec}: {nums}")
            if nums != expected:
                print(f"      [!] Not sequential. Expected: {expected}")

    # 3. LaTeX Quality
    print("\n3. LATEX QUALITY")
    print("-" * 70)

    latex_stats = {
        'uses_text': 0,
        'uses_mathrm': 0,
        'uses_mathbb': 0,
        'uses_frac': 0,
        'total': len(formulas)
    }

    for fid, fdata in formulas.items():
        latex = fdata.get('latex', '')
        if '\\text{' in latex:
            latex_stats['uses_text'] += 1
        if '\\mathrm{' in latex:
            latex_stats['uses_mathrm'] += 1
        if '\\mathbb{' in latex:
            latex_stats['uses_mathbb'] += 1
        if '\\frac{' in latex:
            latex_stats['uses_frac'] += 1

    for key, count in latex_stats.items():
        if key != 'total':
            pct = 100 * count / latex_stats['total'] if latex_stats['total'] > 0 else 0
            print(f"  {key}: {count}/{latex_stats['total']} ({pct:.1f}%)")

    # 4. Content Quality Metrics
    print("\n4. CONTENT METRICS")
    print("-" * 70)

    total_paragraphs = 0
    total_equations = 0
    total_lists = 0
    total_notes = 0

    for section in sections.values():
        for block in section.get('contentBlocks', []):
            btype = block.get('type', '')
            if btype == 'paragraph':
                total_paragraphs += 1
            elif btype == 'equation':
                total_equations += 1
            elif btype == 'list':
                total_lists += 1
            elif btype == 'note':
                total_notes += 1

    print(f"  Paragraphs: {total_paragraphs}")
    print(f"  Equations (in sections): {total_equations}")
    print(f"  Lists: {total_lists}")
    print(f"  Notes/Callouts: {total_notes}")

    # 5. Abstract Check
    print("\n5. ABSTRACT STRUCTURE")
    print("-" * 70)

    section1 = sections.get('1', {})
    abstract = section1.get('abstract', '')

    if abstract:
        word_count = len(abstract.split())
        # Count sentences (rough)
        sentence_count = abstract.count('.') + abstract.count('!') + abstract.count('?')

        print(f"  Word count: {word_count}")
        print(f"  Approximate sentences: {sentence_count}")

        # Check for key elements
        has_background = any(word in abstract.lower() for word in ['pursuit', 'unification', 'theory'])
        has_method = any(word in abstract.lower() for word in ['g2', 'g₂', 'manifold', 'compactification'])
        has_results = any(word in abstract.lower() for word in ['prediction', 'derive', 'w0', 'wₐ'])

        print(f"  Has background: {'Yes' if has_background else 'No'}")
        print(f"  Has methodology: {'Yes' if has_method else 'No'}")
        print(f"  Has results: {'Yes' if has_results else 'No'}")
    else:
        print("  [!] No abstract found")

    # 6. References Check
    print("\n6. REFERENCES")
    print("-" * 70)

    # Look for arXiv references
    arxiv_count = 0
    doi_count = 0

    for section in sections.values():
        for block in section.get('contentBlocks', []):
            content = str(block.get('content', ''))
            arxiv_count += len(re.findall(r'arXiv:\d{4}\.\d{4,5}', content))
            doi_count += len(re.findall(r'doi:', content, re.IGNORECASE))

    print(f"  arXiv references: {arxiv_count}")
    print(f"  DOI references: {doi_count}")

    # Check formulas for references
    formula_refs_count = 0
    for fdata in formulas.values():
        derivation = fdata.get('derivation')
        if derivation:
            refs = derivation.get('references', [])
            formula_refs_count += len(refs)

    print(f"  Formula references: {formula_refs_count}")

    # Summary
    print("\n" + "="*70)
    print("SUMMARY")
    print("="*70)
    print(f"Sections: {len(sections)}")
    print(f"Formulas: {len(formulas)}")
    print(f"Content blocks: {total_paragraphs + total_equations + total_lists + total_notes}")
    print(f"References: {arxiv_count + doi_count + formula_refs_count}")
    print("\n[OK] Paper structure appears academically sound")
    print("="*70)

if __name__ == '__main__':
    main()
