#!/usr/bin/env python3
"""
Check citation format consistency in sections.json
Expected format: [Author Year] or [Author et al. Year]
"""
import json
import re
from pathlib import Path
from collections import defaultdict

def load_json(filepath):
    """Load JSON file with UTF-8 encoding"""
    with open(filepath, 'r', encoding='utf-8') as f:
        return json.load(f)

def extract_citations(text):
    """Extract all citations from text"""
    if not text:
        return []

    # Pattern for citations: [Author Year], [Author et al. Year], [Author and Author Year]
    # Also handles multiple citations like [Author1 Year1; Author2 Year2]
    pattern = r'\[([A-Z][A-Za-z\s,\.&]+\s+\d{4}[a-z]?(?:;\s*[A-Z][A-Za-z\s,\.&]+\s+\d{4}[a-z]?)*)\]'
    matches = re.findall(pattern, str(text))

    citations = []
    for match in matches:
        # Split multiple citations
        for cite in match.split(';'):
            cite = cite.strip()
            if cite:
                citations.append(cite)

    return citations

def validate_citation_format(citation):
    """Check if citation follows standard format"""
    # Standard formats:
    # "Author Year"
    # "Author et al. Year"
    # "Author and Author Year"
    # "Author, Author, and Author Year"

    # Pattern: Author names followed by year
    pattern = r'^[A-Z][A-Za-z\s,\.&]+\s+\d{4}[a-z]?$'

    if not re.match(pattern, citation):
        return False, "Does not match standard format"

    # Check for common issues
    if citation.count('(') != citation.count(')'):
        return False, "Unbalanced parentheses"

    if '..' in citation:
        return False, "Double periods"

    return True, "OK"

def main():
    base_path = Path(__file__).parent / 'AutoGenerated'

    # Load sections
    print("Loading sections.json...")
    sections_data = load_json(base_path / 'sections.json')
    sections = sections_data.get('sections', {})

    all_citations = defaultdict(list)
    citation_issues = []

    # Extract citations from each section
    for section_id, section in sections.items():
        section_title = section.get('title', section_id)

        # Check abstract
        abstract = section.get('abstract', '')
        for cite in extract_citations(abstract):
            all_citations[cite].append(f"Section {section_id} abstract")

        # Check content blocks
        for i, block in enumerate(section.get('contentBlocks', [])):
            content = str(block.get('content', ''))
            for cite in extract_citations(content):
                all_citations[cite].append(f"Section {section_id}, block {i}")

                # Validate format
                is_valid, msg = validate_citation_format(cite)
                if not is_valid:
                    citation_issues.append({
                        'citation': cite,
                        'location': f"Section {section_id} ({section_title})",
                        'issue': msg
                    })

    # Report results
    print("\n" + "="*70)
    print("CITATION ANALYSIS")
    print("="*70)

    print(f"\nTotal unique citations found: {len(all_citations)}")

    # Show most common citations
    if all_citations:
        print("\nMost frequently cited works:")
        sorted_citations = sorted(all_citations.items(), key=lambda x: len(x[1]), reverse=True)
        for cite, locations in sorted_citations[:10]:
            print(f"  {cite} ({len(locations)} times)")

    # Show citation issues
    if citation_issues:
        print(f"\n[!] CITATION FORMAT ISSUES: {len(citation_issues)}")
        for issue in citation_issues[:10]:
            print(f"  Location: {issue['location']}")
            print(f"    Citation: [{issue['citation']}]")
            print(f"    Issue: {issue['issue']}")
            print()
        if len(citation_issues) > 10:
            print(f"  ... and {len(citation_issues) - 10} more")
    else:
        print("\n[OK] All citations follow standard format")

    # Check for arXiv references (should be formatted consistently)
    arxiv_pattern = r'arXiv:\d{4}\.\d{4,5}'
    arxiv_refs = []
    for section_id, section in sections.items():
        for block in section.get('contentBlocks', []):
            content = str(block.get('content', ''))
            matches = re.findall(arxiv_pattern, content)
            for match in matches:
                arxiv_refs.append({
                    'section': section_id,
                    'ref': match
                })

    if arxiv_refs:
        print(f"\nFound {len(arxiv_refs)} arXiv references")
        for ref in arxiv_refs[:5]:
            print(f"  Section {ref['section']}: {ref['ref']}")

    print("\n" + "="*70)

if __name__ == '__main__':
    main()
