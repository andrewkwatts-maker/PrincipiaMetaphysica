"""
Sterility Reporter v17.1 - Sovereign Audit Certificate Generator
=================================================================
Generates formal verification reports that prove the manifold state
is sterile and geometrically sovereign.

This file produces "Proof of Stasis" certificates that compare the
live manifold state against theoretical geometric targets.

Usage:
    from core.verify_sterility_report import SterilityReporter
    reporter = SterilityReporter()
    report = reporter.generate_report()

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
"""

import json
import sys
from datetime import datetime
from decimal import Decimal
from pathlib import Path
from typing import Dict, Any, Optional

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    from core.FormulasRegistry import get_registry, FormulasRegistry
except ImportError:
    sys.path.insert(0, str(Path(__file__).parent))
    from FormulasRegistry import get_registry, FormulasRegistry


class SterilityReporter:
    """
    Generates formal verification reports for the Sovereign Manifold.

    Produces:
    - JSON audit certificates with sovereign hash
    - Markdown summary for documentation
    - Console output for immediate feedback
    """

    def __init__(self, registry: FormulasRegistry = None, output_dir: str = None):
        """
        Initialize the sterility reporter.

        Args:
            registry: FormulasRegistry instance (creates new if not provided)
            output_dir: Directory for output files (defaults to AutoGenerated)
        """
        self.registry = registry or get_registry()
        self.output_dir = Path(output_dir) if output_dir else Path(__file__).parent.parent / "AutoGenerated"
        self.timestamp = datetime.now()

    def generate_report(self) -> Dict[str, Any]:
        """
        Produces a formal verification of the current manifold state.

        Returns:
            Dictionary containing the complete audit report.
        """
        reg = self.registry

        # Define geometric targets for verification
        targets = {
            "h0_target": 71.55,
            "parity_target": 1.6402,
            "closure_target": 288,
            "bulk_pressure_target": 163,
            "pressure_divisor_target": 144,
        }

        # Calculate actual values
        h0_actual = reg.h0_local
        parity_actual = reg.parity_sum
        closure_actual = reg.shadow_sector + reg.christ_constant
        bulk_actual = reg.odowd_bulk_derived
        divisor_actual = reg.pressure_divisor

        # Build the report
        report = {
            "metadata": {
                "version": reg.VERSION,
                "status": reg.STATUS,
                "timestamp": self.timestamp.isoformat() + "Z",
                "session_id": f"PM{self.timestamp.strftime('%Y%m%d%H%M%S')}",
                "manifold_base": reg.b3,
                "sovereign_hash": reg.get_sovereign_hash(),
            },
            "checks": {
                "h0_resolution": {
                    "description": "Hubble Constant from O'Dowd Formula",
                    "value": round(h0_actual, 4),
                    "target": targets["h0_target"],
                    "tolerance": 0.01,
                    "status": "PASS" if abs(h0_actual - targets["h0_target"]) < 0.01 else "FAIL"
                },
                "parity_invariant": {
                    "description": "Sophian Drag + Tzimtzum Pressure",
                    "value": round(parity_actual, 4),
                    "target": targets["parity_target"],
                    "tolerance": 0.0001,
                    "status": "PASS" if abs(parity_actual - targets["parity_target"]) < 0.0001 else "FAIL"
                },
                "logic_closure": {
                    "description": "Shadow (135) + Christ (153) = 288",
                    "value": closure_actual,
                    "target": targets["closure_target"],
                    "status": "PASS" if closure_actual == targets["closure_target"] else "FAIL"
                },
                "bulk_pressure_derivation": {
                    "description": "(7 * B3) - 5 = 163",
                    "value": bulk_actual,
                    "target": targets["bulk_pressure_target"],
                    "status": "PASS" if bulk_actual == targets["bulk_pressure_target"] else "FAIL"
                },
                "pressure_divisor_derivation": {
                    "description": "B3^2 / 4 = 144",
                    "value": divisor_actual,
                    "target": targets["pressure_divisor_target"],
                    "status": "PASS" if divisor_actual == targets["pressure_divisor_target"] else "FAIL"
                },
                "sterile_equals_bulk": {
                    "description": "ROOTS - VISIBLE = (7 * B3) - 5",
                    "value": reg.sterile_sector_derived,
                    "target": reg.odowd_bulk_derived,
                    "status": "PASS" if reg.verify_sterile_equals_bulk() else "FAIL"
                },
                "tzimtzum_fraction": {
                    "description": "sigma_T = 23/24 exactly",
                    "value": float(reg.tzimtzum_pressure),
                    "target": 23/24,
                    "status": "PASS" if reg.verify_tzimtzum_fraction() else "FAIL"
                },
                "watts_guard_rail": {
                    "description": "Omega_W = 1.0 exactly",
                    "value": reg.watts_constant,
                    "target": 1.0,
                    "status": "PASS" if reg.verify_watts_constant() else "FAIL"
                }
            },
            "geometric_integrity": {
                "manifold_area": reg.manifold_area_bulk,
                "pressure_divisor": reg.pressure_divisor,
                "bulk_pressure": reg.odowd_bulk_derived,
                "sterile_sector": reg.sterile_sector_derived,
                "is_derived": True,
                "derivation_formulas": {
                    "manifold_area": "B3^2 = 24^2 = 576",
                    "pressure_divisor": "B3^2 / 4 = 576 / 4 = 144",
                    "bulk_pressure": "(7 * B3) - 5 = (7 * 24) - 5 = 163",
                    "sterile_sector": "ROOTS - VISIBLE = 288 - 125 = 163"
                }
            },
            "overall_status": "PENDING"  # Updated below after checks dict is complete
        }

        # Set overall status now that checks dict is accessible
        report["overall_status"] = "STERILE" if self._all_checks_pass(report["checks"]) else "COMPROMISED"

        return report

    def _all_checks_pass(self, checks: Dict[str, Any]) -> bool:
        """Check if all verification checks passed."""
        return all(check.get("status") == "PASS" for check in checks.values())

    def write_report(self, filename: str = None) -> str:
        """
        Write the audit report to a JSON file.

        Args:
            filename: Optional filename (defaults to timestamped name)

        Returns:
            Path to the written file.
        """
        report = self.generate_report()

        if filename is None:
            filename = f"audit_report_{self.timestamp.strftime('%Y%m%d_%H%M%S')}.json"

        output_path = self.output_dir / filename
        output_path.parent.mkdir(parents=True, exist_ok=True)

        with open(output_path, "w", encoding="utf-8") as f:
            json.dump(report, f, indent=2)

        print(f"[AUDIT] Report written to: {output_path}")
        return str(output_path)

    def print_report(self) -> None:
        """Print a formatted report to the console."""
        report = self.generate_report()

        print("\n" + "=" * 70)
        print(" PRINCIPIA METAPHYSICA v17.1 - SOVEREIGN AUDIT REPORT")
        print("=" * 70)
        print(f" Timestamp: {report['metadata']['timestamp']}")
        print(f" Sovereign Hash: {report['metadata']['sovereign_hash'][:16]}...")
        print("-" * 70)

        print("\n VERIFICATION CHECKS:")
        for name, check in report["checks"].items():
            status_icon = "[PASS]" if check["status"] == "PASS" else "[FAIL]"
            print(f"   {status_icon} {check['description']}: {check['value']}")

        print("\n GEOMETRIC INTEGRITY:")
        geo = report["geometric_integrity"]
        print(f"   Manifold Area (B3^2): {geo['manifold_area']}")
        print(f"   Pressure Divisor (B3^2/4): {geo['pressure_divisor']}")
        print(f"   Bulk Pressure ((7*B3)-5): {geo['bulk_pressure']}")
        print(f"   All values derived: {geo['is_derived']}")

        print("\n" + "=" * 70)
        if report["overall_status"] == "STERILE":
            print(" VERDICT: MANIFOLD IS STERILE - ALL CHECKS PASSED")
        else:
            print(" VERDICT: MANIFOLD COMPROMISED - STERILITY VIOLATIONS DETECTED")
        print("=" * 70 + "\n")


def main():
    """Run the sterility reporter as a standalone script."""
    reporter = SterilityReporter()
    reporter.print_report()
    reporter.write_report()


if __name__ == "__main__":
    main()
