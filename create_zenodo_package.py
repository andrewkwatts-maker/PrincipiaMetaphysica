#!/usr/bin/env python3
"""
Zenodo Package Creator for Principia Metaphysica v16.2
Creates a complete upload package ready for Zenodo archival

DOI: 10.5281/zenodo.18079602
"""

import os
import json
import shutil
import zipfile
from pathlib import Path
from datetime import datetime
import hashlib

# ANSI color codes for terminal output
class Colors:
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    RESET = '\033[0m'
    BOLD = '\033[1m'

def print_step(msg):
    print(f"{Colors.BLUE}{Colors.BOLD}[STEP]{Colors.RESET} {msg}")

def print_success(msg):
    print(f"{Colors.GREEN}[OK]{Colors.RESET} {msg}")

def print_warning(msg):
    print(f"{Colors.YELLOW}[WARN]{Colors.RESET} {msg}")

def print_error(msg):
    print(f"{Colors.RED}[ERROR]{Colors.RESET} {msg}")

def print_info(msg):
    print(f"{Colors.CYAN}[INFO]{Colors.RESET} {msg}")

class ZenodoPackageCreator:
    def __init__(self, root_dir=None):
        self.root_dir = Path(root_dir) if root_dir else Path(__file__).parent
        self.package_dir = self.root_dir / "zenodo_package"
        self.version = "v16.2"
        self.doi = "10.5281/zenodo.18079602"
        self.errors = []
        self.warnings = []
        self.file_manifest = []

    def calculate_file_hash(self, filepath):
        """Calculate SHA-256 hash of a file"""
        sha256_hash = hashlib.sha256()
        with open(filepath, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()

    def get_file_size(self, filepath):
        """Get file size in bytes"""
        return os.path.getsize(filepath)

    def format_size(self, size_bytes):
        """Format file size in human-readable format"""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.2f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.2f} TB"

    def validate_required_files(self):
        """Validate that all required files exist"""
        print_step("Validating required files...")

        required_files = {
            "Core Documentation": [
                "README.md",
                "LICENSE",
                "CITATION.cff",
                "config.py",
            ],
            "Main Paper": [
                "index.html",
                "Pages/paper.html",
                "Pages/sections.html",
            ],
            "Generated Data": [
                "AutoGenerated/theory_output.json",
                "AutoGenerated/formulas.json",
                "AutoGenerated/parameters.json",
                "AutoGenerated/sections.json",
                "AutoGenerated/metadata.json",
            ],
            "JavaScript": [
                "js/formula-registry.js",
                "js/pm-paper-renderer.js",
                "js/pm-section-renderer.js",
            ],
            "CSS": [
                "css/styles.css",
                "css/pm-common.css",
                "css/pm-section-paper.css",
            ],
        }

        all_valid = True
        for category, files in required_files.items():
            print_info(f"Checking {category}...")
            for file in files:
                filepath = self.root_dir / file
                if filepath.exists():
                    print_success(f"  {file}")
                else:
                    print_error(f"  {file} - MISSING")
                    self.errors.append(f"Missing required file: {file}")
                    all_valid = False

        return all_valid

    def create_directory_structure(self):
        """Create the package directory structure"""
        print_step("Creating directory structure...")

        # Clean up existing package directory
        if self.package_dir.exists():
            print_warning(f"Removing existing package directory...")
            shutil.rmtree(self.package_dir)

        # Create main directories
        directories = [
            self.package_dir,
            self.package_dir / "data",
            self.package_dir / "code",
            self.package_dir / "docs",
            self.package_dir / "web",
            self.package_dir / "web/js",
            self.package_dir / "web/css",
            self.package_dir / "web/Pages",
            self.package_dir / "metadata",
        ]

        for directory in directories:
            directory.mkdir(parents=True, exist_ok=True)
            print_success(f"Created {directory.relative_to(self.root_dir)}")

    def copy_core_files(self):
        """Copy core documentation and configuration files"""
        print_step("Copying core files...")

        files_to_copy = [
            ("README.md", "docs/README.md"),
            ("LICENSE", "LICENSE"),
            ("CITATION.cff", "CITATION.cff"),
            ("config.py", "code/config.py"),
            ("ARCHITECTURE.md", "docs/ARCHITECTURE.md"),
            ("FORMAL_ABSTRACT.md", "docs/FORMAL_ABSTRACT.md"),
        ]

        for src, dest in files_to_copy:
            src_path = self.root_dir / src
            dest_path = self.package_dir / dest
            if src_path.exists():
                shutil.copy2(src_path, dest_path)
                self.file_manifest.append({
                    'path': dest,
                    'size': self.get_file_size(dest_path),
                    'sha256': self.calculate_file_hash(dest_path),
                    'category': 'documentation'
                })
                print_success(f"  {src} -> {dest}")
            else:
                print_warning(f"  {src} not found, skipping")

    def copy_generated_data(self):
        """Copy AutoGenerated data files"""
        print_step("Copying generated data files...")

        data_files = [
            "theory_output.json",
            "formulas.json",
            "parameters.json",
            "sections.json",
            "metadata.json",
            "beginner-guide.json",
            "statistics.json",
        ]

        src_dir = self.root_dir / "AutoGenerated"
        dest_dir = self.package_dir / "data"

        for file in data_files:
            src_path = src_dir / file
            dest_path = dest_dir / file
            if src_path.exists():
                shutil.copy2(src_path, dest_path)
                self.file_manifest.append({
                    'path': f"data/{file}",
                    'size': self.get_file_size(dest_path),
                    'sha256': self.calculate_file_hash(dest_path),
                    'category': 'data'
                })
                print_success(f"  {file}")
            else:
                print_warning(f"  {file} not found")

    def copy_web_files(self):
        """Copy web interface files"""
        print_step("Copying web interface files...")

        # Copy main HTML files
        html_files = [
            ("index.html", "web/index.html"),
            ("Pages/paper.html", "web/Pages/paper.html"),
            ("Pages/sections.html", "web/Pages/sections.html"),
            ("Pages/formulas.html", "web/Pages/formulas.html"),
            ("Pages/parameters.html", "web/Pages/parameters.html"),
            ("validation.html", "web/validation.html"),
        ]

        for src, dest in html_files:
            src_path = self.root_dir / src
            dest_path = self.package_dir / dest
            if src_path.exists():
                dest_path.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(src_path, dest_path)
                self.file_manifest.append({
                    'path': dest,
                    'size': self.get_file_size(dest_path),
                    'sha256': self.calculate_file_hash(dest_path),
                    'category': 'web'
                })
                print_success(f"  {src}")

        # Copy JavaScript files
        print_info("Copying JavaScript files...")
        js_files = [
            "formula-registry.js",
            "pm-paper-renderer.js",
            "pm-section-renderer.js",
            "pm-formula-renderer.js",
            "theory-constants.js",
        ]

        for file in js_files:
            src_path = self.root_dir / "js" / file
            dest_path = self.package_dir / "web/js" / file
            if src_path.exists():
                shutil.copy2(src_path, dest_path)
                self.file_manifest.append({
                    'path': f"web/js/{file}",
                    'size': self.get_file_size(dest_path),
                    'sha256': self.calculate_file_hash(dest_path),
                    'category': 'web'
                })
                print_success(f"  js/{file}")

        # Copy CSS files
        print_info("Copying CSS files...")
        css_files = [
            "styles.css",
            "pm-common.css",
            "pm-section-paper.css",
            "pm-header.css",
            "formula-metadata.css",
        ]

        for file in css_files:
            src_path = self.root_dir / "css" / file
            dest_path = self.package_dir / "web/css" / file
            if src_path.exists():
                shutil.copy2(src_path, dest_path)
                self.file_manifest.append({
                    'path': f"web/css/{file}",
                    'size': self.get_file_size(dest_path),
                    'sha256': self.calculate_file_hash(dest_path),
                    'category': 'web'
                })
                print_success(f"  css/{file}")

    def copy_simulation_data(self):
        """Copy simulation data if available"""
        print_step("Copying simulation data...")

        sim_dir = self.root_dir / "simulations"
        if sim_dir.exists() and sim_dir.is_dir():
            dest_sim_dir = self.package_dir / "data/simulations"
            dest_sim_dir.mkdir(parents=True, exist_ok=True)

            # Copy key simulation files
            for file in sim_dir.glob("*.csv"):
                dest_path = dest_sim_dir / file.name
                shutil.copy2(file, dest_path)
                self.file_manifest.append({
                    'path': f"data/simulations/{file.name}",
                    'size': self.get_file_size(dest_path),
                    'sha256': self.calculate_file_hash(dest_path),
                    'category': 'simulations'
                })
                print_success(f"  {file.name}")
        else:
            print_warning("No simulations directory found")

    def generate_manifest_files(self):
        """Generate all manifest and metadata files"""
        print_step("Generating manifest files...")

        # Calculate total size
        total_size = sum(f['size'] for f in self.file_manifest)

        # Generate FILE_MANIFEST.json
        manifest = {
            "package_version": self.version,
            "doi": self.doi,
            "created": datetime.now().isoformat(),
            "total_files": len(self.file_manifest),
            "total_size_bytes": total_size,
            "total_size_human": self.format_size(total_size),
            "files": self.file_manifest
        }

        manifest_path = self.package_dir / "metadata/FILE_MANIFEST.json"
        with open(manifest_path, 'w', encoding='utf-8') as f:
            json.dump(manifest, f, indent=2)
        print_success(f"Created FILE_MANIFEST.json ({len(self.file_manifest)} files)")

        # Generate CHECKSUMS.txt
        checksums_path = self.package_dir / "metadata/CHECKSUMS.txt"
        with open(checksums_path, 'w', encoding='utf-8') as f:
            f.write(f"# SHA-256 Checksums for Principia Metaphysica {self.version}\n")
            f.write(f"# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"# DOI: {self.doi}\n\n")
            for file_info in sorted(self.file_manifest, key=lambda x: x['path']):
                f.write(f"{file_info['sha256']}  {file_info['path']}\n")
        print_success("Created CHECKSUMS.txt")

        # Generate PACKAGE_INFO.txt
        info_path = self.package_dir / "PACKAGE_INFO.txt"
        with open(info_path, 'w', encoding='utf-8') as f:
            f.write(f"""Principia Metaphysica - Zenodo Upload Package
==============================================

Version: {self.version}
DOI: {self.doi}
Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Total Files: {len(self.file_manifest)}
Total Size: {self.format_size(total_size)}

DIRECTORY STRUCTURE
-------------------
data/           - Generated theory data (JSON files)
code/           - Python configuration and scripts
docs/           - Documentation files
web/            - Web interface files (HTML, JS, CSS)
metadata/       - Package manifests and checksums

IMPORTANT FILES
--------------
LICENSE         - Copyright and licensing information
CITATION.cff    - Citation metadata in CFF format
README.md       - Project overview and documentation
config.py       - Master configuration file

DATA FILES
----------
data/theory_output.json  - Complete theory calculations
data/formulas.json       - All 109 formulas with metadata
data/parameters.json     - All 58 parameters with values
data/sections.json       - Paper section content

VERIFICATION
-----------
Use metadata/CHECKSUMS.txt to verify file integrity:
  sha256sum -c metadata/CHECKSUMS.txt

CITATION
--------
Please cite this work as:
Watts, A. K. (2025). Principia Metaphysica: A Unified Theory of Gravity,
Gauge Forces, and Time (Version {self.version}). Zenodo. {self.doi}

For more information, visit:
https://principiametaphysica.com
https://github.com/andrewkwatts/PrincipiaMetaphysica
""")
        print_success("Created PACKAGE_INFO.txt")

        # Generate zenodo_metadata.json
        zenodo_meta = {
            "title": "Principia Metaphysica: A Unified Theory of Gravity, Gauge Forces, and Time",
            "upload_type": "publication",
            "publication_type": "article",
            "description": "Complete theoretical framework and computational implementation for Principia Metaphysica v16.2, including all formulas, parameters, and validation data.",
            "creators": [
                {
                    "name": "Watts, Andrew Keith",
                    "affiliation": "Independent Researcher",
                    "orcid": "0000-0000-0000-0000"  # Update with actual ORCID if available
                }
            ],
            "keywords": [
                "unified field theory",
                "grand unified theory",
                "higher-dimensional geometry",
                "dark energy",
                "SO(10) GUT",
                "G2 manifold",
                "extra dimensions",
                "thermal time hypothesis"
            ],
            "access_right": "open",
            "license": "other-open",
            "version": self.version,
            "language": "eng",
            "related_identifiers": [
                {
                    "relation": "isSupplementTo",
                    "identifier": "https://principiametaphysica.com"
                },
                {
                    "relation": "isSupplementTo",
                    "identifier": "https://github.com/andrewkwatts/PrincipiaMetaphysica"
                }
            ]
        }

        zenodo_path = self.package_dir / "metadata/zenodo_metadata.json"
        with open(zenodo_path, 'w', encoding='utf-8') as f:
            json.dump(zenodo_meta, f, indent=2)
        print_success("Created zenodo_metadata.json")

    def create_readme(self):
        """Create README for the package"""
        print_step("Creating package README...")

        readme_content = f"""# Principia Metaphysica {self.version} - Zenodo Archive

**DOI:** {self.doi}
**Date:** {datetime.now().strftime('%Y-%m-%d')}
**Author:** Andrew Keith Watts

## Overview

This archive contains the complete computational framework and data for Principia Metaphysica version {self.version}, a theoretical framework unifying gravity, gauge forces, and the origin of time through higher-dimensional geometry.

## Contents

### Data Files (`data/`)
- `theory_output.json` - Complete theory calculations and predictions
- `formulas.json` - All 109 formulas with full metadata
- `parameters.json` - All 58 parameters with values and uncertainties
- `sections.json` - Complete paper content in structured format
- `metadata.json` - Theory metadata and statistics

### Code (`code/`)
- `config.py` - Master configuration file (single source of truth)

### Documentation (`docs/`)
- `README.md` - Project overview
- `ARCHITECTURE.md` - System architecture
- `FORMAL_ABSTRACT.md` - Formal technical abstract

### Web Interface (`web/`)
- HTML files for interactive paper viewing
- JavaScript renderers for formulas and sections
- CSS styling files

### Metadata (`metadata/`)
- `FILE_MANIFEST.json` - Complete file listing with checksums
- `CHECKSUMS.txt` - SHA-256 checksums for verification
- `zenodo_metadata.json` - Zenodo upload metadata

## Key Features

- **109 Mathematical Formulas** - Fully documented with derivations
- **58 Parameters** - Including 14 testable predictions
- **88% Validation Rate** - 51 of 58 parameters pass consistency checks
- **10 of 14 Predictions** - Within experimental error bars

## Quick Start

1. Extract the archive
2. Open `web/index.html` in a browser for the interactive paper
3. View `data/theory_output.json` for complete calculations
4. Read `docs/README.md` for detailed documentation

## Verification

Verify file integrity using checksums:
```bash
sha256sum -c metadata/CHECKSUMS.txt
```

## Citation

```
Watts, A. K. (2025). Principia Metaphysica: A Unified Theory of Gravity,
Gauge Forces, and Time (Version {self.version}). Zenodo. {self.doi}
```

Or use `CITATION.cff` for automated citation tools.

## License

Copyright (c) 2025 Andrew Keith Watts. All rights reserved.
See LICENSE file for details.

## Links

- **Website:** https://principiametaphysica.com
- **GitHub:** https://github.com/andrewkwatts/PrincipiaMetaphysica
- **DOI:** {self.doi}

## Contact

For inquiries: AndrewKWatts@Gmail.com
"""

        readme_path = self.package_dir / "README.md"
        with open(readme_path, 'w', encoding='utf-8') as f:
            f.write(readme_content)
        print_success("Created package README.md")

    def create_zip_archive(self):
        """Create the final ZIP archive"""
        print_step("Creating ZIP archive...")

        zip_path = self.root_dir / f"PM_GUT_{self.version}.zip"

        # Remove existing ZIP if present
        if zip_path.exists():
            zip_path.unlink()

        total_files = 0
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for root, dirs, files in os.walk(self.package_dir):
                for file in files:
                    file_path = Path(root) / file
                    arcname = file_path.relative_to(self.package_dir)
                    zipf.write(file_path, arcname)
                    total_files += 1

        zip_size = self.get_file_size(zip_path)
        print_success(f"Created {zip_path.name}")
        print_info(f"  Files: {total_files}")
        print_info(f"  Size: {self.format_size(zip_size)}")

        return zip_path, zip_size

    def generate_upload_checklist(self, zip_path, zip_size):
        """Generate the upload checklist"""
        print_step("Generating upload checklist...")

        checklist_content = f"""# Zenodo Upload Checklist for Principia Metaphysica {self.version}

**DOI:** {self.doi}
**Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Package:** {zip_path.name}
**Size:** {self.format_size(zip_size)}

## Pre-Upload Checklist

- [ ] Verify ZIP archive integrity
- [ ] Review all file checksums
- [ ] Confirm all required files are included
- [ ] Test extraction of ZIP archive
- [ ] Review package README
- [ ] Verify LICENSE file is included

## Upload Instructions

### Step 1: Access Zenodo
1. Go to https://zenodo.org
2. Log in to your account
3. Navigate to "Upload" -> "New Upload"

### Step 2: Upload File
1. Click "Choose files" or drag and drop
2. Upload: `{zip_path.name}`
3. Wait for upload to complete
4. Verify file size matches: {self.format_size(zip_size)}

### Step 3: Fill Metadata

**Basic Information:**
- **Upload type:** Publication → Article
- **Publication date:** {datetime.now().strftime('%Y-%m-%d')}
- **Title:** Principia Metaphysica: A Unified Theory of Gravity, Gauge Forces, and Time
- **Authors:** Watts, Andrew Keith (add ORCID if available)
- **Description:**

```
Complete theoretical framework and computational implementation for Principia
Metaphysica v16.2, presenting a unified theory of gravity, gauge forces, and
time through higher-dimensional geometry. Includes 109 formulas, 58 parameters,
validation data, and interactive web interface.

Key features:
- 26D spacetime reducing to 4D via Sp(2,R) gauge projection and G2 compactification
- Predicts 3 fermion generations from χ_eff = 144
- Dark energy w₀ = -11/13 matching DESI 2024
- SO(10) grand unification with 3% coupling precision
- 88% parameter validation rate (51/58)
- 10 of 14 predictions within experimental bounds
```

**License & Access:**
- **License:** Other (Open) - specify custom license
- **Access right:** Open Access

**Communities:**
- [ ] Add to relevant communities (e.g., "Physics", "Theoretical Physics")

**Keywords:**
```
unified field theory
grand unified theory
higher-dimensional geometry
dark energy
SO(10) GUT
G2 manifold
extra dimensions
thermal time hypothesis
quantum gravity
cosmology
```

**Version:** {self.version}

**Language:** English

**Related/alternate identifiers:**
- **Relation:** is supplement to
- **Identifier:** https://principiametaphysica.com
- **Relation:** is supplement to
- **Identifier:** https://github.com/andrewkwatts/PrincipiaMetaphysica

### Step 4: Reserve DOI
1. Click "Reserve DOI" (if creating new record)
2. Note the DOI: **{self.doi}**
3. Verify DOI matches expected value

### Step 5: Save and Publish
1. Review all metadata fields
2. Click "Save" (draft)
3. Review preview
4. Click "Publish" when ready
5. **WARNING:** Publishing is irreversible!

## Post-Upload Checklist

- [ ] Verify DOI resolves correctly
- [ ] Check all files are accessible
- [ ] Download and verify checksums
- [ ] Test web interface files
- [ ] Update GitHub README with DOI badge
- [ ] Update website with Zenodo link
- [ ] Announce release (if applicable)

## Package Contents Summary

**Total Files:** {len(self.file_manifest)}
**Categories:**
- Documentation: README, LICENSE, CITATION
- Data: theory_output.json, formulas.json, parameters.json
- Code: config.py
- Web: HTML, JavaScript, CSS files
- Metadata: manifests and checksums

**File Breakdown:**
"""

        # Add file breakdown by category
        categories = {}
        for file_info in self.file_manifest:
            cat = file_info['category']
            if cat not in categories:
                categories[cat] = {'count': 0, 'size': 0}
            categories[cat]['count'] += 1
            categories[cat]['size'] += file_info['size']

        for cat, info in sorted(categories.items()):
            checklist_content += f"- {cat.title()}: {info['count']} files, {self.format_size(info['size'])}\n"

        checklist_content += f"""

## Verification Commands

**Verify ZIP integrity:**
```bash
unzip -t {zip_path.name}
```

**Extract and verify checksums:**
```bash
unzip {zip_path.name}
cd PM_GUT_{self.version}
sha256sum -c metadata/CHECKSUMS.txt
```

## DOI Badge for README

Add this badge to your GitHub README:

```markdown
[![DOI](https://zenodo.org/badge/DOI/{self.doi}.svg)](https://doi.org/{self.doi})
```

## Citation

**BibTeX:**
```bibtex
@article{{watts2025principia,
  title={{Principia Metaphysica: A Unified Theory of Gravity, Gauge Forces, and Time}},
  author={{Watts, Andrew Keith}},
  year={{2025}},
  version={{{self.version}}},
  doi={{{self.doi}}},
  url={{https://doi.org/{self.doi}}},
  publisher={{Zenodo}}
}}
```

**APA:**
```
Watts, A. K. (2025). Principia Metaphysica: A Unified Theory of Gravity,
Gauge Forces, and Time (Version {self.version}). Zenodo.
https://doi.org/{self.doi}
```

## Troubleshooting

**If upload fails:**
- Check file size limits (Zenodo max: 50GB per file)
- Verify internet connection
- Try uploading via API if web interface fails
- Contact Zenodo support if needed

**If DOI doesn't match:**
- You may need to request a specific DOI
- Contact Zenodo support with your preference
- Update all references after confirmation

## Contact Information

**For technical issues:**
- Zenodo Support: https://zenodo.org/support
- Email: support@zenodo.org

**For content questions:**
- Author: Andrew Keith Watts
- Email: AndrewKWatts@Gmail.com

## Notes

- Keep this checklist for your records
- Save Zenodo record URL once published
- Update all references to point to new DOI
- Archive this version in institutional repository if applicable

---

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Package Version:** {self.version}
**Target DOI:** {self.doi}
"""

        checklist_path = self.root_dir / "ZENODO_UPLOAD_CHECKLIST.md"
        with open(checklist_path, 'w', encoding='utf-8') as f:
            f.write(checklist_content)

        print_success(f"Created ZENODO_UPLOAD_CHECKLIST.md")
        return checklist_path

    def print_summary(self, zip_path, zip_size):
        """Print final summary"""
        print(f"\n{Colors.BOLD}{Colors.GREEN}{'='*70}{Colors.RESET}")
        print(f"{Colors.BOLD}{Colors.GREEN}Zenodo Package Creation Complete!{Colors.RESET}")
        print(f"{Colors.BOLD}{Colors.GREEN}{'='*70}{Colors.RESET}\n")

        print(f"{Colors.BOLD}Package Information:{Colors.RESET}")
        print(f"  Version: {self.version}")
        print(f"  DOI: {self.doi}")
        print(f"  Files: {len(self.file_manifest)}")
        print(f"  Total Size: {self.format_size(sum(f['size'] for f in self.file_manifest))}")
        print(f"  ZIP Archive: {zip_path.name}")
        print(f"  ZIP Size: {self.format_size(zip_size)}")

        print(f"\n{Colors.BOLD}Created Files:{Colors.RESET}")
        print(f"  [OK] {zip_path.relative_to(self.root_dir)}")
        print(f"  [OK] ZENODO_UPLOAD_CHECKLIST.md")
        print(f"  [OK] zenodo_package/ (directory)")

        if self.warnings:
            print(f"\n{Colors.YELLOW}{Colors.BOLD}Warnings ({len(self.warnings)}):{Colors.RESET}")
            for warning in self.warnings[:10]:
                print(f"  {Colors.YELLOW}[WARN]{Colors.RESET} {warning}")
            if len(self.warnings) > 10:
                print(f"  ... and {len(self.warnings) - 10} more")

        if self.errors:
            print(f"\n{Colors.RED}{Colors.BOLD}Errors ({len(self.errors)}):{Colors.RESET}")
            for error in self.errors:
                print(f"  {Colors.RED}[ERROR]{Colors.RESET} {error}")

        print(f"\n{Colors.BOLD}Next Steps:{Colors.RESET}")
        print(f"  1. Review ZENODO_UPLOAD_CHECKLIST.md")
        print(f"  2. Verify {zip_path.name} integrity")
        print(f"  3. Upload to Zenodo at https://zenodo.org")
        print(f"  4. Update README.md with DOI badge")
        print(f"\n{Colors.CYAN}Ready for upload!{Colors.RESET}\n")

    def run(self):
        """Run the complete package creation process"""
        print(f"\n{Colors.BOLD}{Colors.CYAN}{'='*70}{Colors.RESET}")
        print(f"{Colors.BOLD}{Colors.CYAN}Principia Metaphysica Zenodo Package Creator{Colors.RESET}")
        print(f"{Colors.BOLD}{Colors.CYAN}Version: {self.version} | DOI: {self.doi}{Colors.RESET}")
        print(f"{Colors.BOLD}{Colors.CYAN}{'='*70}{Colors.RESET}\n")

        try:
            # Step 1: Validate
            if not self.validate_required_files():
                print_error("Validation failed! Please fix missing files.")
                return False

            # Step 2: Create structure
            self.create_directory_structure()

            # Step 3: Copy files
            self.copy_core_files()
            self.copy_generated_data()
            self.copy_web_files()
            self.copy_simulation_data()

            # Step 4: Generate manifests
            self.generate_manifest_files()
            self.create_readme()

            # Step 5: Create ZIP
            zip_path, zip_size = self.create_zip_archive()

            # Step 6: Create checklist
            self.generate_upload_checklist(zip_path, zip_size)

            # Step 7: Summary
            self.print_summary(zip_path, zip_size)

            return True

        except Exception as e:
            print_error(f"Fatal error: {e}")
            import traceback
            traceback.print_exc()
            return False

def main():
    """Main entry point"""
    creator = ZenodoPackageCreator()
    success = creator.run()
    return 0 if success else 1

if __name__ == "__main__":
    import sys
    sys.exit(main())
