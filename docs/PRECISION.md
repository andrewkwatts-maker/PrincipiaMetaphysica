# Precision Requirements for Principia Metaphysica v16.2

## Overview

The Principia Metaphysica framework derives 125 physical parameters from pure G2 manifold geometry. To maintain the 0.48 sigma global tension with experimental data, strict numerical precision requirements must be observed.

## Precision Levels

### Minimum Requirements (Development)

- **Float precision**: IEEE 754 double precision (`float64`)
- **Significant digits**: 15-16 decimal places
- **Suitable for**: Local development, quick iterations

### Recommended Requirements (Production)

- **Float precision**: Arbitrary precision / `BigInt`
- **Significant digits**: 50+ decimal places
- **Suitable for**: Publication-quality results, certificate validation

### Critical Parameters

These parameters require maximum precision due to their sensitivity:

| Parameter | Precision Required | Reason |
|-----------|-------------------|--------|
| `topology.k_gimel` | 10+ digits | Appears in multiple derivations |
| `topology.c_kaf` | Exact fraction (136/5) | Topological invariant |
| `cosmology.w0` | Exact fraction (-23/24) | Dark energy EoS |
| `neutrino.sum_m_nu` | 8+ digits | Sub-eV measurements |

## Runtime Enforcement

### Observer Heartbeat (CERT-OBSV-041)

The Observer Heartbeat module (`js/observer-heartbeat.js`) performs runtime parity checks at configurable epoch intervals (default: every 10,000 iterations).

```javascript
// Configuration
ObserverHeartbeat.config = {
    epoch_interval: 10000,      // Check every 10k iterations
    tolerance: 1e-12,           // Maximum allowed drift
    strict_mode: true,          // Throw on violation if true
};
```

### Topological Guardrail

The Topological Guardrail prevents accidental modification of locked G2-residue values:

```javascript
// Create a protected registry
const protectedRegistry = ObserverHeartbeat.createTopologicalGuardrail(registry);

// This will throw an error:
protectedRegistry['topology.b3'] = 25;  // Error: Topological Lock Violation
```

### Hysteresis Detection (CERT-HYST-042)

If floating-point drift is detected, values are automatically snapped back to their locked residue values:

```javascript
// At the end of every epoch
const result = ObserverHeartbeat.runIntegrityCheck(currentResidues);
if (result.corrected) {
    console.log('Numerical drift corrected');
}
```

## Node.js Requirements

For high-precision calculations in Node.js:

```bash
# Install required packages
npm install bignumber.js  # Arbitrary precision arithmetic
npm install decimal.js    # High-precision decimal operations
```

### Example Usage

```javascript
const Decimal = require('decimal.js');

// Configure for high precision
Decimal.set({ precision: 50 });

// Exact calculation of k_gimel
const b3 = new Decimal(24);
const k_gimel = b3.dividedBy(2).plus(Decimal.acos(-1).pow(-1));
console.log(k_gimel.toString());  // 12.318309886183790671537767526745028724068919291480...
```

## Python Requirements

For high-precision calculations in Python:

```bash
# Install required packages
pip install mpmath         # Arbitrary precision mathematics
pip install sympy          # Symbolic computation
```

### Example Usage

```python
from mpmath import mp, mpf, pi

# Set precision to 50 decimal places
mp.dps = 50

# Exact calculation of k_gimel
b3 = mpf(24)
k_gimel = b3 / 2 + 1 / pi
print(k_gimel)  # 12.318309886183790671537767526745028724068919291480...
```

## Validation

To verify that your environment meets precision requirements:

```bash
# Run the Omega Seal generator
python scripts/finalize_lockdown.py

# Verify the master hash
cat simulations/AutoGenerated/OMEGA_SEAL.hash
```

The Omega Seal verifies:
1. All 42 certificates are present and valid
2. Certificate hashes match expected values
3. The combined master hash is stable

## Floating-Point Pitfalls

### Avoid These Common Errors

1. **Chained arithmetic with intermediate rounding**
   ```python
   # Bad: Loses precision at each step
   x = 1/3
   y = x * 3  # Not exactly 1.0

   # Good: Use exact fractions
   from fractions import Fraction
   x = Fraction(1, 3)
   y = x * 3  # Exactly 1
   ```

2. **Comparing floats for equality**
   ```python
   # Bad: May fail due to rounding
   if w0 == -23/24:

   # Good: Use tolerance
   if abs(w0 - (-23/24)) < 1e-12:
   ```

3. **Accumulated drift in loops**
   ```python
   # Bad: Drift accumulates
   total = 0.0
   for _ in range(1000000):
       total += 0.1

   # Good: Use Kahan summation or integer scaling
   total = sum_kahan([0.1] * 1000000)
   ```

## Certificate Precision

Each certificate specifies its precision requirements in the `expected_result` field:

```json
{
  "proof_id": "c_kaf_derivation",
  "expected_result": "{27.2, 136/5, True, \"LOCKED\"}",
  "validation_code": "c_kaf = 24 * 17 / 15; return abs(c_kaf - 27.2) < 0.001"
}
```

The `validation_code` field shows the acceptable tolerance for verification.

## Reporting Precision Issues

If you encounter numerical drift or precision issues:

1. Check your environment meets minimum requirements
2. Run `python scripts/finalize_lockdown.py` to verify certificate integrity
3. Report issues at: https://github.com/andrewkwatts-maker/PrincipiaMetaphysica/issues

Include:
- Your platform and Python/Node.js version
- The Omega Seal hash from your build
- The specific parameter showing drift

---

**Version**: 16.2
**Last Updated**: 2026-01-01
**Framework**: Principia Metaphysica - Pure Geometry
