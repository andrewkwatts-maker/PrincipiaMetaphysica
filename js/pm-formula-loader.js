/**
 * PM Formula Loader
 * =================
 *
 * Loads formulas from AUTO_GENERATED/json/formulas.json (or theory_output.json).
 * This provides a single source of truth from Python config.py to JavaScript.
 *
 * The loader caches formulas, provides lookup by ID, and automatically renders
 * formulas into the DOM.
 *
 * Usage:
 *   // Auto-loads on page load and renders all formulas
 *   await PMFormulaLoader.load();
 *
 *   // Get formula data
 *   const formula = PMFormulaLoader.get('generation-number');
 *
 *   // Render formulas in HTML:
 *   <div data-formula-id="generation-number"></div>
 *   <pm-formula data-id="generation-number"></pm-formula>
 *
 *   // Manual rendering
 *   PMFormulaLoader.render(element, 'generation-number', { showLabel: true });
 *
 * Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
 */

class PMFormulaLoader {
    static _formulas = null;
    static _loaded = false;
    static _loading = null;
    static _version = null;

    /**
     * Load formulas from theory_output.json
     * @param {string} path - Path to theory_output.json (default: auto-detect)
     * @returns {Promise<boolean>} - True if loaded successfully
     */
    static async load(path = null) {
        if (this._loaded) return true;
        if (this._loading) return this._loading;

        this._loading = (async () => {
            try {
                const pathPrefixes = [
                    'AutoGenerated/',            // AutoGenerated folder (primary)
                    '',                          // Root directory (fallback)
                    '../AutoGenerated/',         // From subdirectory
                    '../',                       // Parent directory (from subdirs)
                    '../../AutoGenerated/',      // From nested subdirectory
                    '../../',                    // Two levels up
                ];

                const triedPaths = [];

                // ================================================================
                // STRATEGY 1: Try to load unified theory_output.json
                // ================================================================
                if (!path) {
                    for (const prefix of pathPrefixes) {
                        const testPath = prefix + 'theory_output.json';
                        triedPaths.push(testPath);
                        try {
                            const response = await fetch(testPath);
                            if (response.ok) {
                                path = testPath;
                                break;
                            }
                        } catch (e) {
                            if (window.PM_DEBUG) {
                                console.debug(`  - Failed to load ${testPath}: ${e.message}`);
                            }
                            continue;
                        }
                    }
                }

                // If we found theory_output.json, load it
                if (path) {
                    const response = await fetch(path);
                    if (response.ok) {
                        const data = await response.json();

                        if (data.formulas && data.formulas.formulas) {
                            this._formulas = data.formulas.formulas;
                            this._version = data.formulas.version || data.version || 'unknown';
                            this._loaded = true;

                            console.log(`%cPMFormulaLoader: Successfully loaded from ${path}`, 'color: green; font-weight: bold');
                            console.log(`  Formulas: ${Object.keys(this._formulas).length} (v${this._version})`);

                            // Expose globally for debugging
                            window.PM_FORMULAS = this._formulas;

                            // Merge with global FORMULA_REGISTRY if exists
                            if (window.FORMULA_REGISTRY) {
                                this._mergeWithRegistry();
                            }

                            // Render any formulas in the DOM
                            this.renderAll();

                            return true;
                        }
                    }
                }

                // ================================================================
                // STRATEGY 2: Try to load AUTO_GENERATED/json/formulas.json
                // ================================================================
                console.log('%cPMFormulaLoader: theory_output.json not found, trying formulas.json...', 'color: orange');

                for (const prefix of pathPrefixes) {
                    try {
                        const formulasPath = prefix + 'AUTO_GENERATED/json/formulas.json';
                        triedPaths.push(formulasPath);

                        const response = await fetch(formulasPath);
                        if (response.ok) {
                            const formulasData = await response.json();

                            // Handle both formats:
                            // 1. Direct formulas object: { "formula-id": {...}, ... }
                            // 2. Wrapped format: { formulas: {...}, version: "...", count: N }
                            let formulas;
                            if (formulasData.formulas && typeof formulasData.formulas === 'object') {
                                formulas = formulasData.formulas;
                                this._version = formulasData.version || 'unknown';
                            } else {
                                formulas = formulasData;
                                this._version = 'individual-file';
                            }

                            this._formulas = formulas;
                            this._loaded = true;

                            console.log(`%cPMFormulaLoader: Successfully loaded from ${formulasPath}`, 'color: green; font-weight: bold');
                            console.log(`  Formulas: ${Object.keys(this._formulas).length} (v${this._version})`);

                            // Expose globally for debugging
                            window.PM_FORMULAS = this._formulas;

                            // Merge with global FORMULA_REGISTRY if exists
                            if (window.FORMULA_REGISTRY) {
                                this._mergeWithRegistry();
                            }

                            // Render any formulas in the DOM
                            this.renderAll();

                            return true;
                        }
                    } catch (e) {
                        if (window.PM_DEBUG) {
                            console.debug(`  - Failed to load ${prefix}AUTO_GENERATED/json/formulas.json: ${e.message}`);
                        }
                        continue;
                    }
                }

                // ================================================================
                // FAILURE: Could not load formulas
                // ================================================================
                console.error('%cPMFormulaLoader: Failed to load formulas!', 'color: red; font-weight: bold');
                console.error('  Tried paths:', triedPaths);
                console.error('  ');
                console.error('  SOLUTIONS:');
                console.error('  1. Run: python run_all_simulations.py --export');
                console.error('  2. Check that theory_output.json or AUTO_GENERATED/json/formulas.json exists');
                console.error('  3. If using file:// protocol, you may need to run a local web server');
                console.error('     Try: python -m http.server 8000');
                console.error('  ');
                console.error('  Set window.PM_DEBUG = true for verbose logging');

                return false;
            } catch (error) {
                console.error('%cPMFormulaLoader: Error during loading:', 'color: red; font-weight: bold', error);
                return false;
            }
        })();

        return this._loading;
    }

    /**
     * Merge loaded formulas with existing FORMULA_REGISTRY
     */
    static _mergeWithRegistry() {
        if (!this._formulas || !window.FORMULA_REGISTRY) return;

        for (const [id, formula] of Object.entries(this._formulas)) {
            const category = formula.category || 'DERIVED';

            // Create category if doesn't exist
            if (!window.FORMULA_REGISTRY[category]) {
                window.FORMULA_REGISTRY[category] = {};
            }

            // Add/update formula in registry
            window.FORMULA_REGISTRY[category][id] = {
                id: formula.id,
                html: formula.html,
                latex: formula.latex,
                plainText: formula.plainText,
                label: formula.label,
                category: category,
                description: formula.description,
                attribution: formula.attribution || 'Principia Metaphysica',
                status: formula.status,
                section: formula.section,
                terms: formula.terms || {},
                derivation: formula.derivation,
                computedValue: formula.computedValue,
                units: formula.units,
                experimentalValue: formula.experimentalValue,
                sigmaDeviation: formula.sigmaDeviation,
                simulationFile: formula.simulationFile,
                relatedFormulas: formula.relatedFormulas,
                notes: formula.notes,
                testability: formula.testability
            };
        }

        console.log('PMFormulaLoader: Merged with FORMULA_REGISTRY');
    }

    /**
     * Get a formula by ID
     * @param {string} id - Formula ID
     * @returns {Object|null} - Formula object or null
     */
    static get(id) {
        if (!this._formulas) return null;
        return this._formulas[id] || null;
    }

    /**
     * Get all formulas
     * @returns {Object} - All formulas keyed by ID
     */
    static getAll() {
        return this._formulas || {};
    }

    /**
     * Get formulas by category
     * @param {string} category - Category name (THEORY, DERIVED, PREDICTIONS)
     * @returns {Array} - Array of formulas in that category
     */
    static getByCategory(category) {
        if (!this._formulas) return [];
        return Object.values(this._formulas).filter(f => f.category === category);
    }

    /**
     * Get formulas by section
     * @param {string} section - Section number (e.g., "2", "4.1")
     * @returns {Array} - Array of formulas in that section
     */
    static getBySection(section) {
        if (!this._formulas) return [];
        return Object.values(this._formulas).filter(f =>
            f.section && f.section.startsWith(section)
        );
    }

    /**
     * Get related formulas for a given formula ID
     * @param {string} id - Formula ID
     * @returns {Array} - Array of related formula objects
     */
    static getRelated(id) {
        const formula = this.get(id);
        if (!formula || !formula.relatedFormulas) return [];
        return formula.relatedFormulas
            .map(relId => this.get(relId))
            .filter(f => f !== null);
    }

    /**
     * Search formulas by description or label
     * @param {string} query - Search query
     * @returns {Array} - Matching formulas
     */
    static search(query) {
        if (!this._formulas) return [];
        const q = query.toLowerCase();
        return Object.values(this._formulas).filter(f =>
            (f.description && f.description.toLowerCase().includes(q)) ||
            (f.label && f.label.toLowerCase().includes(q)) ||
            (f.id && f.id.includes(q))
        );
    }

    /**
     * Get statistics about loaded formulas
     * @returns {Object} - Statistics
     */
    static getStats() {
        if (!this._formulas) return { loaded: false };

        const all = Object.values(this._formulas);
        const categories = {};
        for (const f of all) {
            const cat = f.category || 'UNKNOWN';
            categories[cat] = (categories[cat] || 0) + 1;
        }

        return {
            loaded: true,
            version: this._version,
            total: all.length,
            categories,
            withExperimental: all.filter(f => f.experimentalValue !== undefined).length,
            withSimulations: all.filter(f => f.simulationFile).length
        };
    }

    /**
     * Render a formula with full interactive features
     * @param {HTMLElement} element - Target element
     * @param {string} formulaId - Formula ID from theory_output.json
     * @param {Object} options - Rendering options
     * @returns {boolean} - True if rendered successfully
     */
    static render(element, formulaId, options = {}) {
        // Ensure styles are loaded
        this._ensureStyles();

        if (!element) {
            console.error('PMFormulaLoader.render: No element provided');
            return false;
        }

        const formula = this.get(formulaId);
        if (!formula) {
            element.innerHTML = `<div class="pm-formula-error">Formula not found: ${formulaId}</div>`;
            return false;
        }

        const {
            showTitle = true,
            showPlainText = true,
            expandable = true,
            interactive = true,
            compact = false
        } = options;

        // Build enhanced formula card
        element.classList.add('pm-formula-container');
        element.dataset.formulaId = formulaId;

        // Get input/output params info
        const inputs = formula.inputParams || [];
        const outputs = formula.outputParams || [];
        const derivedFrom = formula.derivedFrom || [];
        const terms = formula.terms || {};
        const section = formula.section || '';
        const sectionId = formula.sectionId || '';
        const category = formula.category || 'DERIVED';

        // Format title from ID
        const formattedTitle = formula.id.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

        element.innerHTML = `
            <div class="pm-formula-card${compact ? ' compact' : ''}${interactive ? ' interactive' : ''}">
                ${showTitle ? `
                    <div class="pm-formula-header">
                        <div class="pm-formula-title-row">
                            <span class="pm-formula-eq-num">${formula.equationNumber || ''}</span>
                            <h4 class="pm-formula-title">${formattedTitle}</h4>
                            <div class="pm-formula-badges">
                                <span class="pm-formula-category">${category}</span>
                                ${section ? `<span class="pm-formula-section-badge">${section}</span>` : ''}
                            </div>
                        </div>
                        ${formula.description ? `<p class="pm-formula-subtitle">${formula.description}</p>` : ''}
                    </div>
                ` : ''}

                <div class="pm-formula-display">
                    <div class="pm-formula-latex">$$${formula.latex || 'No LaTeX available'}$$</div>
                    ${showPlainText && formula.plainText ? `
                        <div class="pm-formula-plaintext-section">
                            <div class="pm-plaintext-label">Plain Text:</div>
                            <code class="pm-plaintext-code">${formula.plainText}</code>
                        </div>
                    ` : ''}
                </div>

                ${(inputs.length || outputs.length) ? `
                    <div class="pm-formula-params-row">
                        ${inputs.length ? `
                            <div class="pm-param-panel pm-param-input">
                                <div class="pm-param-panel-header">
                                    <span class="pm-param-icon">ðŸ“¥</span>
                                    <span class="pm-param-label">Inputs</span>
                                </div>
                                <div class="pm-param-list">
                                    ${inputs.map(p => `<span class="pm-param-chip pm-param-chip-input">${p}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}
                        ${outputs.length ? `
                            <div class="pm-param-panel pm-param-output">
                                <div class="pm-param-panel-header">
                                    <span class="pm-param-icon">ðŸ“¤</span>
                                    <span class="pm-param-label">Outputs</span>
                                </div>
                                <div class="pm-param-list">
                                    ${outputs.map(p => `<span class="pm-param-chip pm-param-chip-output">${p}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                ` : ''}

                ${expandable && (derivedFrom.length || Object.keys(terms).length) ? `
                    <div class="pm-formula-expandable">
                        <button class="pm-expand-btn" onclick="this.closest('.pm-formula-card').classList.toggle('expanded')">
                            <span class="expand-icon">â–¸</span> Details
                        </button>
                        <div class="pm-formula-details">
                            ${derivedFrom.length ? `
                                <div class="pm-formula-derived">
                                    <h5>ðŸ”— Derived From</h5>
                                    <div class="pm-derived-list">
                                        ${derivedFrom.map(f => `<a href="#" class="pm-formula-link" data-formula-id="${f}">${f}</a>`).join('')}
                                    </div>
                                </div>
                            ` : ''}
                            ${Object.keys(terms).length ? `
                                <div class="pm-formula-terms">
                                    <h5>ðŸ“– Terms</h5>
                                    <dl>
                                        ${Object.entries(terms).map(([sym, desc]) =>
                                            `<dt>${sym}</dt><dd>${desc}</dd>`
                                        ).join('')}
                                    </dl>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                ` : ''}
            </div>
        `;

        this._triggerMathJax(element);
        return true;
    }

    /**
     * Render all elements with data-formula-id or data-id attributes
     */
    static renderAll() {
        if (!this._loaded) {
            console.warn('PMFormulaLoader.renderAll: Formulas not loaded yet');
            return;
        }

        // Ensure DOM is ready before attempting to render
        if (typeof document === 'undefined') {
            console.warn('PMFormulaLoader.renderAll: Document not available');
            return;
        }

        // Find all elements with data-formula-id attribute
        const elementsWithFormulaId = document.querySelectorAll('[data-formula-id]:not(.pm-formula-container)');
        let renderedCount = 0;

        elementsWithFormulaId.forEach(element => {
            const formulaId = element.getAttribute('data-formula-id');
            if (formulaId) {
                // Read options from data attributes
                const options = {
                    showTitle: element.getAttribute('data-show-title') !== 'false',
                    showPlainText: element.getAttribute('data-show-plaintext') !== 'false',
                    expandable: element.getAttribute('data-expandable') !== 'false',
                    interactive: element.getAttribute('data-interactive') !== 'false',
                    compact: element.getAttribute('data-compact') === 'true'
                };

                if (this.render(element, formulaId, options)) {
                    renderedCount++;
                }
            }
        });

        // Find all pm-formula elements with data-id attribute (if not using web component)
        const pmFormulaElements = document.querySelectorAll('pm-formula[data-id]:not(.pm-formula-container)');
        pmFormulaElements.forEach(element => {
            const formulaId = element.getAttribute('data-id');
            if (formulaId) {
                // Read options from data attributes
                const options = {
                    showTitle: element.getAttribute('data-show-title') !== 'false',
                    showPlainText: element.getAttribute('data-show-plaintext') !== 'false',
                    expandable: element.getAttribute('data-expandable') !== 'false',
                    interactive: element.getAttribute('data-interactive') !== 'false',
                    compact: element.getAttribute('data-compact') === 'true'
                };

                if (this.render(element, formulaId, options)) {
                    renderedCount++;
                }
            }
        });

        if (renderedCount > 0) {
            console.log(`PMFormulaLoader: Rendered ${renderedCount} formulas`);
        }
    }

    /**
     * Ensure formula styles are loaded
     * @private
     */
    static _ensureStyles() {
        if (document.getElementById('pm-formula-styles')) return;

        const style = document.createElement('style');
        style.id = 'pm-formula-styles';
        style.textContent = `
            .pm-formula-container {
                margin: 1rem 0;
            }

            .pm-formula-card {
                background: rgba(255, 255, 255, 0.03);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                overflow: hidden;
                transition: all 0.3s ease;
                position: relative;
            }

            .pm-formula-card.interactive:hover {
                border-color: rgba(139, 127, 255, 0.4);
                box-shadow: 0 4px 20px rgba(139, 127, 255, 0.15);
            }

            .pm-formula-header {
                padding: 1rem 1.25rem;
                border-bottom: 1px solid rgba(255, 255, 255, 0.05);
                background: rgba(139, 127, 255, 0.05);
            }

            .pm-formula-title-row {
                display: flex;
                align-items: center;
                gap: 0.75rem;
                flex-wrap: wrap;
            }

            .pm-formula-eq-num {
                color: #8b7fff;
                font-weight: 600;
                font-size: 0.9rem;
            }

            .pm-formula-title {
                margin: 0;
                font-size: 1.1rem;
                color: #f8f9fa;
                flex: 1;
            }

            .pm-formula-badges {
                display: flex;
                gap: 0.5rem;
                align-items: center;
                flex-shrink: 0;
            }

            .pm-formula-category {
                font-size: 0.65rem;
                padding: 0.2rem 0.5rem;
                background: rgba(139, 127, 255, 0.2);
                border: 1px solid rgba(139, 127, 255, 0.3);
                border-radius: 4px;
                color: #a394ff;
                text-transform: uppercase;
                letter-spacing: 0.05em;
            }

            .pm-formula-section-badge {
                font-size: 0.65rem;
                padding: 0.2rem 0.5rem;
                background: rgba(74, 222, 128, 0.15);
                border: 1px solid rgba(74, 222, 128, 0.3);
                border-radius: 4px;
                color: #4ade80;
                text-transform: uppercase;
                letter-spacing: 0.03em;
            }

            .pm-formula-subtitle {
                margin: 0.5rem 0 0 0;
                font-size: 0.9rem;
                color: rgba(255, 255, 255, 0.6);
                font-style: italic;
            }

            .pm-formula-display {
                padding: 1.25rem;
            }

            .pm-formula-latex {
                font-size: 1.2rem;
                text-align: center;
                padding: 0.5rem 0;
            }

            /* Plain text shown below LaTeX, not expandable */
            .pm-formula-plaintext-section {
                margin-top: 1rem;
                padding-top: 1rem;
                border-top: 1px dashed rgba(255, 255, 255, 0.1);
            }

            .pm-plaintext-label {
                font-size: 0.75rem;
                color: rgba(255, 255, 255, 0.4);
                margin-bottom: 0.5rem;
                text-transform: uppercase;
                letter-spacing: 0.05em;
            }

            .pm-plaintext-code {
                display: block;
                padding: 0.75rem 1rem;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 6px;
                font-family: 'Source Code Pro', 'Fira Code', monospace;
                font-size: 0.8rem;
                color: #a3e635;
                overflow-x: auto;
                white-space: pre-wrap;
                word-break: break-all;
            }

            /* Input/Output Parameter Panels - Color coded */
            .pm-formula-params-row {
                display: flex;
                gap: 1rem;
                padding: 1rem 1.25rem;
                border-top: 1px solid rgba(255, 255, 255, 0.05);
                background: rgba(0, 0, 0, 0.15);
            }

            .pm-param-panel {
                flex: 1;
                padding: 0.75rem;
                border-radius: 8px;
                min-width: 0;
            }

            .pm-param-panel.pm-param-input {
                background: rgba(59, 130, 246, 0.1);
                border: 1px solid rgba(59, 130, 246, 0.25);
            }

            .pm-param-panel.pm-param-output {
                background: rgba(251, 146, 60, 0.1);
                border: 1px solid rgba(251, 146, 60, 0.25);
            }

            .pm-param-panel-header {
                display: flex;
                align-items: center;
                gap: 0.4rem;
                margin-bottom: 0.5rem;
            }

            .pm-param-icon {
                font-size: 0.9rem;
            }

            .pm-param-label {
                font-size: 0.7rem;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.05em;
            }

            .pm-param-input .pm-param-label { color: #60a5fa; }
            .pm-param-output .pm-param-label { color: #fb923c; }

            .pm-param-list {
                display: flex;
                flex-wrap: wrap;
                gap: 0.35rem;
            }

            .pm-param-chip {
                font-size: 0.75rem;
                padding: 0.2rem 0.5rem;
                border-radius: 4px;
                font-family: 'Source Code Pro', monospace;
            }

            .pm-param-chip-input {
                background: rgba(59, 130, 246, 0.2);
                color: #93c5fd;
                border: 1px solid rgba(59, 130, 246, 0.3);
            }

            .pm-param-chip-output {
                background: rgba(251, 146, 60, 0.2);
                color: #fdba74;
                border: 1px solid rgba(251, 146, 60, 0.3);
            }

            /* Expandable details section */
            .pm-formula-expandable {
                border-top: 1px solid rgba(255, 255, 255, 0.05);
            }

            .pm-expand-btn {
                width: 100%;
                background: transparent;
                border: none;
                color: rgba(255, 255, 255, 0.5);
                padding: 0.6rem;
                cursor: pointer;
                font-size: 0.8rem;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 0.4rem;
            }

            .pm-expand-btn:hover {
                background: rgba(139, 127, 255, 0.1);
                color: #f8f9fa;
            }

            .expand-icon {
                transition: transform 0.2s ease;
                font-size: 0.7rem;
            }

            .pm-formula-card.expanded .expand-icon {
                transform: rotate(90deg);
            }

            .pm-formula-details {
                display: none;
                padding: 1rem 1.25rem;
                border-top: 1px solid rgba(255, 255, 255, 0.05);
                background: rgba(0, 0, 0, 0.2);
            }

            .pm-formula-card.expanded .pm-formula-details {
                display: block;
            }

            .pm-formula-derived, .pm-formula-terms {
                margin-bottom: 1rem;
            }

            .pm-formula-derived:last-child, .pm-formula-terms:last-child {
                margin-bottom: 0;
            }

            .pm-formula-details h5 {
                margin: 0 0 0.5rem 0;
                font-size: 0.8rem;
                color: #8b7fff;
            }

            .pm-derived-list {
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .pm-formula-link {
                color: #8b7fff;
                text-decoration: none;
                font-size: 0.85rem;
                padding: 0.2rem 0.5rem;
                background: rgba(139, 127, 255, 0.1);
                border-radius: 4px;
                transition: all 0.2s ease;
            }

            .pm-formula-link:hover {
                background: rgba(139, 127, 255, 0.2);
                text-decoration: none;
            }

            .pm-formula-terms dl {
                display: grid;
                grid-template-columns: auto 1fr;
                gap: 0.5rem 1rem;
                margin: 0;
            }

            .pm-formula-terms dt {
                color: #a394ff;
                font-weight: 600;
            }

            .pm-formula-terms dd {
                margin: 0;
                color: rgba(255, 255, 255, 0.7);
            }

            .pm-formula-card.compact .pm-formula-header {
                padding: 0.75rem 1rem;
            }

            .pm-formula-card.compact .pm-formula-display {
                padding: 1rem;
            }

            .pm-formula-card.compact .pm-formula-latex {
                font-size: 1rem;
            }

            .pm-formula-error {
                background: rgba(248, 113, 113, 0.1);
                border: 1px solid rgba(248, 113, 113, 0.3);
                border-radius: 8px;
                padding: 1rem;
                color: #f87171;
            }
        `;
        document.head.appendChild(style);
    }

    /**
     * Trigger MathJax typesetting on an element
     * @private
     */
    static _triggerMathJax(element) {
        if (typeof window === 'undefined') return;

        // Check for MathJax v3
        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise([element]).catch(err => {
                console.warn('MathJax typesetting failed:', err);
            });
        }
        // Check for MathJax v2
        else if (window.MathJax && window.MathJax.Hub) {
            window.MathJax.Hub.Queue(['Typeset', window.MathJax.Hub, element]);
        }
    }
}

// Auto-load on page load
if (typeof window !== 'undefined') {
    window.PMFormulaLoader = PMFormulaLoader;

    // Load when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => PMFormulaLoader.load());
    } else {
        PMFormulaLoader.load();
    }
}

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { PMFormulaLoader };
}
