/**
 * PM Formula Loader
 * =================
 *
 * Loads formulas from AutoGenerated/formulas.json (or theory_output.json).
 * This provides a single source of truth from Python config.py to JavaScript.
 *
 * The loader caches formulas, provides lookup by ID, and automatically renders
 * formulas into the DOM.
 *
 * Usage:
 *   // Auto-loads on page load and renders all formulas
 *   await PMFormulaLoader.load();
 *
 *   // Get formula data
 *   const formula = PMFormulaLoader.get('generation-number');
 *
 *   // Render formulas in HTML:
 *   <div data-formula-id="generation-number"></div>
 *   <pm-formula data-id="generation-number"></pm-formula>
 *
 *   // Manual rendering
 *   PMFormulaLoader.render(element, 'generation-number', { showLabel: true });
 *
 * Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
 */

class PMFormulaLoader {
    static _formulas = null;
    static _loaded = false;
    static _loading = null;
    static _version = null;

    // Cache configuration
    static CACHE_KEY = 'pm_formulas_cache';
    static CACHE_VERSION = '16.2';
    static CACHE_TTL = 3600000; // 1 hour in ms

    /**
     * Get cached formulas from localStorage
     */
    static _getCached() {
        try {
            const cached = localStorage.getItem(this.CACHE_KEY);
            if (!cached) return null;

            const { data, timestamp, version } = JSON.parse(cached);
            if (version !== this.CACHE_VERSION) return null;
            if (Date.now() - timestamp > this.CACHE_TTL) return null;

            return data;
        } catch (e) {
            return null;
        }
    }

    /**
     * Cache formulas to localStorage
     */
    static _setCache(data) {
        try {
            localStorage.setItem(this.CACHE_KEY, JSON.stringify({
                data,
                timestamp: Date.now(),
                version: this.CACHE_VERSION
            }));
        } catch (e) {
            console.warn('[PMFormulaLoader] Could not cache:', e.message);
        }
    }

    /**
     * Load formulas from split formulas.json or theory_output.json
     * @param {string} path - Path to data file (default: auto-detect)
     * @returns {Promise<boolean>} - True if loaded successfully
     */
    static async load(path = null) {
        if (this._loaded) return true;
        if (this._loading) return this._loading;

        this._loading = (async () => {
            // ================================================================
            // STRATEGY 0: Check localStorage cache first (fast path)
            // ================================================================
            const cached = this._getCached();
            if (cached) {
                this._formulas = cached.formulas;
                this._version = cached.version || '16.0';
                this._loaded = true;

                console.log('[PMFormulaLoader] Loaded from cache');
                window.PM_FORMULAS = this._formulas;
                this.renderAll();
                return true;
            }

            try {
                // Determine base path based on current location
                const loc = window.location.pathname;
                let basePath = 'AutoGenerated/';
                if (loc.includes('/foundations/') || loc.includes('/sections/') ||
                    loc.includes('/docs/') || loc.includes('/diagrams/')) {
                    basePath = '../AutoGenerated/';
                }

                // ================================================================
                // STRATEGY 1: Try split formulas.json (preferred)
                // ================================================================
                const formulasPaths = [
                    `${basePath}formulas.json`,
                    'AutoGenerated/formulas.json',
                    '../AutoGenerated/formulas.json',
                    '../../AutoGenerated/formulas.json'
                ];

                for (const formulasPath of formulasPaths) {
                    try {
                        const response = await fetch(formulasPath);
                        if (response.ok) {
                            const data = await response.json();

                            // Handle format: { formulas: {...}, version: "...", count: N }
                            if (data.formulas && typeof data.formulas === 'object') {
                                this._formulas = data.formulas;
                                this._version = data.version || '16.0';
                            } else {
                                this._formulas = data;
                                this._version = '16.0';
                            }

                            this._loaded = true;
                            this._setCache({ formulas: this._formulas, version: this._version });

                            console.log(`%c[PMFormulaLoader] Loaded from ${formulasPath}`, 'color: green; font-weight: bold');
                            console.log(`  Formulas: ${Object.keys(this._formulas).length} (v${this._version})`);

                            window.PM_FORMULAS = this._formulas;
                            if (window.FORMULA_REGISTRY) this._mergeWithRegistry();
                            this.renderAll();

                            return true;
                        }
                    } catch (e) {
                        continue;
                    }
                }

                // ================================================================
                // STRATEGY 2: Fallback to unified theory_output.json
                // ================================================================
                const unifiedPaths = [
                    `${basePath}theory_output.json`,
                    'AutoGenerated/theory_output.json',
                    '../AutoGenerated/theory_output.json',
                    'theory_output.json'
                ];

                for (const testPath of unifiedPaths) {
                    try {
                        const response = await fetch(testPath);
                        if (response.ok) {
                            const data = await response.json();

                            if (data.formulas && data.formulas.formulas) {
                                this._formulas = data.formulas.formulas;
                                this._version = data.formulas.version || data.version || '16.0';
                                this._loaded = true;

                                this._setCache({ formulas: this._formulas, version: this._version });

                                console.log(`%c[PMFormulaLoader] Loaded from ${testPath}`, 'color: green; font-weight: bold');
                                console.log(`  Formulas: ${Object.keys(this._formulas).length} (v${this._version})`);

                                window.PM_FORMULAS = this._formulas;
                                if (window.FORMULA_REGISTRY) this._mergeWithRegistry();
                                this.renderAll();

                                return true;
                            }
                        }
                    } catch (e) {
                        continue;
                    }
                }

                // ================================================================
                // FAILURE: Could not load formulas
                // ================================================================
                console.error('%c[PMFormulaLoader] Failed to load formulas!', 'color: red; font-weight: bold');
                console.error('  Run: python simulations/Constants/split_theory_output.py');
                return false;
            } catch (error) {
                console.error('%cPMFormulaLoader: Error during loading:', 'color: red; font-weight: bold', error);
                return false;
            }
        })();

        return this._loading;
    }

    /**
     * Merge loaded formulas with existing FORMULA_REGISTRY
     */
    static _mergeWithRegistry() {
        if (!this._formulas || !window.FORMULA_REGISTRY) return;

        for (const [id, formula] of Object.entries(this._formulas)) {
            const category = formula.category || 'DERIVED';

            // Create category if doesn't exist
            if (!window.FORMULA_REGISTRY[category]) {
                window.FORMULA_REGISTRY[category] = {};
            }

            // Add/update formula in registry
            window.FORMULA_REGISTRY[category][id] = {
                id: formula.id,
                html: formula.html,
                latex: formula.latex,
                plainText: formula.plainText,
                label: formula.label,
                category: category,
                description: formula.description,
                attribution: formula.attribution || 'Principia Metaphysica',
                status: formula.status,
                section: formula.section,
                terms: formula.terms || {},
                derivation: formula.derivation,
                computedValue: formula.computedValue,
                units: formula.units,
                experimentalValue: formula.experimentalValue,
                sigmaDeviation: formula.sigmaDeviation,
                simulationFile: formula.simulationFile,
                relatedFormulas: formula.relatedFormulas,
                notes: formula.notes,
                testability: formula.testability
            };
        }

        console.log('PMFormulaLoader: Merged with FORMULA_REGISTRY');
    }

    /**
     * Get a formula by ID
     * @param {string} id - Formula ID
     * @returns {Object|null} - Formula object or null
     */
    static get(id) {
        if (!this._formulas) return null;
        return this._formulas[id] || null;
    }

    /**
     * Get all formulas
     * @returns {Object} - All formulas keyed by ID
     */
    static getAll() {
        return this._formulas || {};
    }

    /**
     * Get formulas by category
     * @param {string} category - Category name (THEORY, DERIVED, PREDICTIONS)
     * @returns {Array} - Array of formulas in that category
     */
    static getByCategory(category) {
        if (!this._formulas) return [];
        return Object.values(this._formulas).filter(f => f.category === category);
    }

    /**
     * Get formulas by section
     * @param {string} section - Section number (e.g., "2", "4.1")
     * @returns {Array} - Array of formulas in that section
     */
    static getBySection(section) {
        if (!this._formulas) return [];
        return Object.values(this._formulas).filter(f =>
            f.section && f.section.startsWith(section)
        );
    }

    /**
     * Get related formulas for a given formula ID
     * @param {string} id - Formula ID
     * @returns {Array} - Array of related formula objects
     */
    static getRelated(id) {
        const formula = this.get(id);
        if (!formula || !formula.relatedFormulas) return [];
        return formula.relatedFormulas
            .map(relId => this.get(relId))
            .filter(f => f !== null);
    }

    /**
     * Search formulas by description or label
     * @param {string} query - Search query
     * @returns {Array} - Matching formulas
     */
    static search(query) {
        if (!this._formulas) return [];
        const q = query.toLowerCase();
        return Object.values(this._formulas).filter(f =>
            (f.description && f.description.toLowerCase().includes(q)) ||
            (f.label && f.label.toLowerCase().includes(q)) ||
            (f.id && f.id.includes(q))
        );
    }

    /**
     * Get statistics about loaded formulas
     * @returns {Object} - Statistics
     */
    static getStats() {
        if (!this._formulas) return { loaded: false };

        const all = Object.values(this._formulas);
        const categories = {};
        for (const f of all) {
            const cat = f.category || 'UNKNOWN';
            categories[cat] = (categories[cat] || 0) + 1;
        }

        return {
            loaded: true,
            version: this._version,
            total: all.length,
            categories,
            withExperimental: all.filter(f => f.experimentalValue !== undefined).length,
            withSimulations: all.filter(f => f.simulationFile).length
        };
    }

    /**
     * Render a formula with full interactive features
     * @param {HTMLElement} element - Target element
     * @param {string} formulaId - Formula ID from theory_output.json
     * @param {Object} options - Rendering options
     * @returns {boolean} - True if rendered successfully
     */
    static render(element, formulaId, options = {}) {
        // Ensure styles are loaded
        this._ensureStyles();

        if (!element) {
            console.error('PMFormulaLoader.render: No element provided');
            return false;
        }

        const formula = this.get(formulaId);
        if (!formula) {
            element.innerHTML = `<div class="pm-formula-error">Formula not found: ${formulaId}</div>`;
            return false;
        }

        const {
            showTitle = true,
            showPlainText = true,
            expandable = true,
            interactive = true,
            compact = false
        } = options;

        // Build enhanced formula card
        element.classList.add('pm-formula-container');
        element.dataset.formulaId = formulaId;

        // Get input/output params info
        const inputs = formula.inputParams || [];
        const outputs = formula.outputParams || [];
        const derivedFrom = formula.derivedFrom || [];
        const terms = formula.terms || {};
        const section = formula.section || '';
        const sectionId = formula.sectionId || '';
        const category = formula.category || 'DERIVED';

        // Format title from ID
        const formattedTitle = formula.id.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

        element.innerHTML = `
            <div class="pm-formula-card${compact ? ' compact' : ''}${interactive ? ' interactive' : ''}">
                ${showTitle ? `
                    <div class="pm-formula-header">
                        <div class="pm-formula-title-row">
                            <span class="pm-formula-eq-num">${formula.equationNumber || ''}</span>
                            <h4 class="pm-formula-title">${formattedTitle}</h4>
                            <div class="pm-formula-badges">
                                <span class="pm-formula-category">${category}</span>
                                ${section ? `<span class="pm-formula-section-badge">${section}</span>` : ''}
                            </div>
                        </div>
                        ${formula.description ? `<p class="pm-formula-subtitle">${formula.description}</p>` : ''}
                    </div>
                ` : ''}

                <div class="pm-formula-display">
                    <div class="pm-formula-latex">$$${formula.latex || 'No LaTeX available'}$$</div>
                    ${showPlainText && formula.plainText ? `
                        <div class="pm-formula-plaintext-section">
                            <div class="pm-plaintext-label">Plain Text:</div>
                            <code class="pm-plaintext-code">${formula.plainText}</code>
                        </div>
                    ` : ''}
                </div>

                ${(inputs.length || outputs.length) ? `
                    <div class="pm-formula-params-inline">
                        ${inputs.length ? `
                            <div class="pm-param-line pm-param-input-line">
                                <span class="pm-param-label-inline">Inputs:</span>
                                <span class="pm-param-values">${inputs.join(', ')}</span>
                            </div>
                        ` : ''}
                        ${outputs.length ? `
                            <div class="pm-param-line pm-param-output-line">
                                <span class="pm-param-label-inline">Outputs:</span>
                                <span class="pm-param-values">${outputs.join(', ')}</span>
                            </div>
                        ` : ''}
                    </div>
                ` : ''}

                ${derivedFrom.length ? `
                    <div class="pm-formula-derivations">
                        <ul class="pm-derived-list-inline">
                            ${derivedFrom.map(f => `<li><a href="#" class="pm-formula-link" data-formula-id="${f}">${f}</a></li>`).join('')}
                        </ul>
                    </div>
                ` : ''}
            </div>
        `;

        this._triggerMathJax(element);
        return true;
    }

    /**
     * Render all elements with data-formula-id or data-id attributes
     */
    static renderAll() {
        if (!this._loaded) {
            console.warn('PMFormulaLoader.renderAll: Formulas not loaded yet');
            return;
        }

        // Ensure DOM is ready before attempting to render
        if (typeof document === 'undefined') {
            console.warn('PMFormulaLoader.renderAll: Document not available');
            return;
        }

        // Find all elements with data-formula-id attribute
        const elementsWithFormulaId = document.querySelectorAll('[data-formula-id]:not(.pm-formula-container)');
        let renderedCount = 0;

        elementsWithFormulaId.forEach(element => {
            const formulaId = element.getAttribute('data-formula-id');
            if (formulaId) {
                // Read options from data attributes
                const options = {
                    showTitle: element.getAttribute('data-show-title') !== 'false',
                    showPlainText: element.getAttribute('data-show-plaintext') !== 'false',
                    expandable: element.getAttribute('data-expandable') !== 'false',
                    interactive: element.getAttribute('data-interactive') !== 'false',
                    compact: element.getAttribute('data-compact') === 'true'
                };

                if (this.render(element, formulaId, options)) {
                    renderedCount++;
                }
            }
        });

        // Find all pm-formula elements with data-id attribute (if not using web component)
        const pmFormulaElements = document.querySelectorAll('pm-formula[data-id]:not(.pm-formula-container)');
        pmFormulaElements.forEach(element => {
            const formulaId = element.getAttribute('data-id');
            if (formulaId) {
                // Read options from data attributes
                const options = {
                    showTitle: element.getAttribute('data-show-title') !== 'false',
                    showPlainText: element.getAttribute('data-show-plaintext') !== 'false',
                    expandable: element.getAttribute('data-expandable') !== 'false',
                    interactive: element.getAttribute('data-interactive') !== 'false',
                    compact: element.getAttribute('data-compact') === 'true'
                };

                if (this.render(element, formulaId, options)) {
                    renderedCount++;
                }
            }
        });

        if (renderedCount > 0) {
            console.log(`PMFormulaLoader: Rendered ${renderedCount} formulas`);
        }
    }

    /**
     * Ensure formula styles are loaded
     * @private
     */
    static _ensureStyles() {
        if (document.getElementById('pm-formula-styles')) return;

        const style = document.createElement('style');
        style.id = 'pm-formula-styles';
        style.textContent = `
            .pm-formula-container {
                margin: 1rem 0;
            }

            .pm-formula-card {
                background: rgba(255, 255, 255, 0.03);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                overflow: hidden;
                transition: all 0.3s ease;
                position: relative;
                /* Ensure frosted glass effects are clipped to card boundaries */
                isolation: isolate;
                contain: paint;
            }

            .pm-formula-card.interactive:hover {
                border-color: rgba(139, 127, 255, 0.4);
                box-shadow: 0 4px 20px rgba(139, 127, 255, 0.15);
                /* Frosted glass shimmer effect - clipped to panel */
                background: linear-gradient(
                    135deg,
                    rgba(139, 127, 255, 0.08) 0%,
                    rgba(255, 255, 255, 0.05) 50%,
                    rgba(139, 127, 255, 0.08) 100%
                );
            }

            .pm-formula-header {
                padding: 1rem 1.25rem;
                border-bottom: 1px solid rgba(255, 255, 255, 0.05);
                background: rgba(139, 127, 255, 0.05);
            }

            .pm-formula-title-row {
                display: flex;
                align-items: center;
                gap: 0.75rem;
                flex-wrap: wrap;
            }

            .pm-formula-eq-num {
                color: #8b7fff;
                font-weight: 600;
                font-size: 0.9rem;
            }

            .pm-formula-title {
                margin: 0;
                font-size: 1.1rem;
                color: #f8f9fa;
                flex: 1;
            }

            .pm-formula-badges {
                display: flex;
                gap: 0.5rem;
                align-items: center;
                flex-shrink: 0;
            }

            .pm-formula-category {
                font-size: 0.65rem;
                padding: 0.2rem 0.5rem;
                background: rgba(139, 127, 255, 0.2);
                border: 1px solid rgba(139, 127, 255, 0.3);
                border-radius: 4px;
                color: #a394ff;
                text-transform: uppercase;
                letter-spacing: 0.05em;
            }

            .pm-formula-section-badge {
                font-size: 0.65rem;
                padding: 0.2rem 0.5rem;
                background: rgba(74, 222, 128, 0.15);
                border: 1px solid rgba(74, 222, 128, 0.3);
                border-radius: 4px;
                color: #4ade80;
                text-transform: uppercase;
                letter-spacing: 0.03em;
            }

            .pm-formula-subtitle {
                margin: 0.5rem 0 0 0;
                font-size: 0.9rem;
                color: rgba(255, 255, 255, 0.6);
                font-style: italic;
            }

            .pm-formula-display {
                padding: 1.25rem;
            }

            .pm-formula-latex {
                font-size: 1.2rem;
                text-align: center;
                padding: 0.5rem 0;
            }

            /* Plain text shown below LaTeX, not expandable */
            .pm-formula-plaintext-section {
                margin-top: 1rem;
                padding-top: 1rem;
                border-top: 1px dashed rgba(255, 255, 255, 0.1);
            }

            .pm-plaintext-label {
                font-size: 0.75rem;
                color: rgba(255, 255, 255, 0.4);
                margin-bottom: 0.5rem;
                text-transform: uppercase;
                letter-spacing: 0.05em;
            }

            .pm-plaintext-code {
                display: block;
                padding: 0.75rem 1rem;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 6px;
                font-family: 'Source Code Pro', 'Fira Code', monospace;
                font-size: 0.8rem;
                color: #a3e635;
                overflow-x: auto;
                white-space: pre-wrap;
                word-break: break-all;
            }

            /* Input/Output Parameter Lines - Inline format */
            .pm-formula-params-inline {
                padding: 0.75rem 1.25rem;
                border-top: 1px solid rgba(255, 255, 255, 0.05);
                background: rgba(0, 0, 0, 0.1);
            }

            .pm-param-line {
                display: flex;
                align-items: baseline;
                gap: 0.5rem;
                padding: 0.25rem 0;
                font-size: 0.85rem;
            }

            .pm-param-label-inline {
                font-weight: 600;
                color: rgba(255, 255, 255, 0.7);
                min-width: 60px;
            }

            .pm-param-input-line .pm-param-label-inline { color: #60a5fa; }
            .pm-param-output-line .pm-param-label-inline { color: #fb923c; }

            .pm-param-values {
                font-family: 'Source Code Pro', 'Fira Code', monospace;
                color: rgba(255, 255, 255, 0.9);
            }

            /* Derivations list - shown directly without toggle */
            .pm-formula-derivations {
                padding: 0.75rem 1.25rem;
                border-top: 1px solid rgba(255, 255, 255, 0.05);
                background: rgba(0, 0, 0, 0.1);
            }

            .pm-derived-list-inline {
                list-style: none;
                margin: 0;
                padding: 0;
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .pm-derived-list-inline li {
                margin: 0;
            }

            .pm-derived-list-inline .pm-formula-link {
                color: #8b7fff;
                text-decoration: none;
                font-size: 0.85rem;
                padding: 0.2rem 0.5rem;
                background: rgba(139, 127, 255, 0.1);
                border-radius: 4px;
                transition: all 0.2s ease;
            }

            .pm-derived-list-inline .pm-formula-link:hover {
                background: rgba(139, 127, 255, 0.2);
                text-decoration: none;
            }

            .pm-formula-latex-full {
                margin-bottom: 1rem;
            }

            .pm-latex-source {
                background: rgba(0, 0, 0, 0.4);
                padding: 0.75rem 1rem;
                border-radius: 6px;
                font-family: 'Source Code Pro', 'Fira Code', monospace;
                font-size: 0.75rem;
                color: #93c5fd;
                overflow-x: auto;
                white-space: pre-wrap;
                word-break: break-all;
                margin: 0.5rem 0 0 0;
                border: 1px solid rgba(139, 127, 255, 0.2);
            }

            .expand-icon {
                transition: transform 0.2s ease;
                font-size: 0.7rem;
            }

            .pm-formula-card.expanded .expand-icon {
                transform: rotate(90deg);
            }

            .pm-formula-details {
                display: none;
                padding: 1rem 1.25rem;
                border-top: 1px solid rgba(255, 255, 255, 0.05);
                background: rgba(0, 0, 0, 0.2);
            }

            .pm-formula-card.expanded .pm-formula-details {
                display: block;
            }

            .pm-formula-derived, .pm-formula-terms {
                margin-bottom: 1rem;
            }

            .pm-formula-derived:last-child, .pm-formula-terms:last-child {
                margin-bottom: 0;
            }

            .pm-formula-details h5 {
                margin: 0 0 0.5rem 0;
                font-size: 0.8rem;
                color: #8b7fff;
            }

            .pm-derived-list {
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .pm-formula-link {
                color: #8b7fff;
                text-decoration: none;
                font-size: 0.85rem;
                padding: 0.2rem 0.5rem;
                background: rgba(139, 127, 255, 0.1);
                border-radius: 4px;
                transition: all 0.2s ease;
            }

            .pm-formula-link:hover {
                background: rgba(139, 127, 255, 0.2);
                text-decoration: none;
            }

            .pm-formula-terms dl {
                display: grid;
                grid-template-columns: auto 1fr;
                gap: 0.5rem 1rem;
                margin: 0;
            }

            .pm-formula-terms dt {
                color: #a394ff;
                font-weight: 600;
            }

            .pm-formula-terms dd {
                margin: 0;
                color: rgba(255, 255, 255, 0.7);
            }

            .pm-formula-card.compact .pm-formula-header {
                padding: 0.75rem 1rem;
            }

            .pm-formula-card.compact .pm-formula-display {
                padding: 1rem;
            }

            .pm-formula-card.compact .pm-formula-latex {
                font-size: 1rem;
            }

            .pm-formula-error {
                background: rgba(248, 113, 113, 0.1);
                border: 1px solid rgba(248, 113, 113, 0.3);
                border-radius: 8px;
                padding: 1rem;
                color: #f87171;
            }
        `;
        document.head.appendChild(style);
    }

    /**
     * Trigger MathJax typesetting on an element
     * @private
     */
    static _triggerMathJax(element) {
        if (typeof window === 'undefined') return;

        // Check for MathJax v3
        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise([element]).catch(err => {
                console.warn('MathJax typesetting failed:', err);
            });
        }
        // Check for MathJax v2
        else if (window.MathJax && window.MathJax.Hub) {
            window.MathJax.Hub.Queue(['Typeset', window.MathJax.Hub, element]);
        }
    }
}

// Auto-load on page load
if (typeof window !== 'undefined') {
    window.PMFormulaLoader = PMFormulaLoader;

    // Load when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => PMFormulaLoader.load());
    } else {
        PMFormulaLoader.load();
    }
}

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { PMFormulaLoader };
}
