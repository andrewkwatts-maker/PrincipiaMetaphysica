/**
 * Principia Metaphysica - Foundations Loader
 * Dynamically loads and renders foundational physics concepts
 *
 * Copyright (c) 2025 Andrew Keith Watts. All rights reserved.
 */

/**
 * Fetch foundations data from foundations_data.json
 * @returns {Promise<Object>} The foundations data object
 */
async function fetchFoundationsData() {
    const pathsToTry = [
        '../AutoGenerated/foundations_data.json',
        'AutoGenerated/foundations_data.json',
        '../foundations_data.json',
        'foundations_data.json',
        '../../AutoGenerated/foundations_data.json'
    ];

    for (const path of pathsToTry) {
        try {
            const response = await fetch(path);
            if (response.ok) {
                const data = await response.json();
                console.log(`Foundations data loaded from: ${path}`);
                return data;
            }
        } catch (error) {
            // Try next path
            continue;
        }
    }

    console.error('Error fetching foundations data: Could not find foundations_data.json');
    return null;
}

/**
 * Group foundations by category
 * @param {Object} data - The foundations data
 * @returns {Object} Grouped foundations by category
 */
function groupByCategory(data) {
    if (!data || !data.foundations) {
        return {};
    }
    return data.foundations;
}

/**
 * Get all unique categories
 * @param {Object} groupedData - Foundations grouped by category
 * @returns {Array} Array of category objects with metadata
 */
function getCategories(groupedData) {
    const categories = [];
    for (const [key, value] of Object.entries(groupedData)) {
        categories.push({
            id: key,
            name: value.category,
            description: value.description,
            count: value.items ? value.items.length : 0
        });
    }
    return categories;
}

/**
 * Create a foundation card element
 * @param {Object} foundation - Foundation item data
 * @returns {HTMLElement} The foundation card element
 */
function createFoundationCard(foundation) {
    const card = document.createElement('a');
    card.href = foundation.link;
    card.className = 'section-card';

    // Badge styling based on type
    const badgeClasses = {
        'established': 'established',
        'derived': 'derived',
        'pm-specific': 'pm-specific'
    };
    const badgeClass = badgeClasses[foundation.badge] || 'established';

    const badgeLabels = {
        'established': 'Established',
        'derived': 'Derived',
        'pm-specific': 'PM-Specific'
    };
    const badgeLabel = badgeLabels[foundation.badge] || 'Established';

    card.innerHTML = `
        <span class="foundation-badge ${badgeClass}">${badgeLabel}</span>
        <h3 style="margin-top: 0.75rem;">${foundation.title}</h3>
        ${foundation.year ? `<p style="color: var(--text-muted); font-size: 0.85rem; margin: 0.25rem 0;">${foundation.year}</p>` : ''}
        <p style="font-family: 'Crimson Text', serif; margin: 0.75rem 0; font-size: 1rem; color: var(--text-primary);">
            ${foundation.equation}
        </p>
        <p style="font-size: 0.9rem; color: var(--text-secondary); margin: 0;">
            ${foundation.summary}
        </p>
    `;

    return card;
}

/**
 * Render foundations for a specific category
 * @param {Object} categoryData - The category data with items
 * @param {HTMLElement} container - The container element to render into
 */
function renderFoundations(categoryData, container) {
    container.innerHTML = '';

    if (!categoryData || !categoryData.items || categoryData.items.length === 0) {
        container.innerHTML = '<p style="grid-column: 1/-1; text-align: center; padding: 2rem; color: var(--text-muted);">No foundations found in this category.</p>';
        return;
    }

    categoryData.items.forEach(foundation => {
        const card = createFoundationCard(foundation);
        container.appendChild(card);
    });
}

/**
 * Setup tab switching functionality
 * @param {Object} groupedData - Foundations grouped by category
 * @param {Array} categories - Array of category objects
 */
function setupTabs(groupedData, categories) {
    const tabList = document.querySelector('.tab-list');
    const tabContentContainer = document.querySelector('.tabs-container');

    if (!tabList || !tabContentContainer) {
        console.error('Tab elements not found');
        return;
    }

    // Clear existing tabs and content
    tabList.innerHTML = '';

    // Remove old tab content sections if they exist
    const oldTabContents = tabContentContainer.querySelectorAll('.tab-content');
    oldTabContents.forEach(content => content.remove());

    // Create tabs and content for each category
    categories.forEach((category, index) => {
        // Create tab button
        const tab = document.createElement('button');
        tab.className = 'tab' + (index === 0 ? ' active' : '');
        tab.setAttribute('role', 'tab');
        tab.setAttribute('data-tab', category.id);
        tab.setAttribute('aria-selected', index === 0 ? 'true' : 'false');
        tab.setAttribute('aria-controls', category.id);
        tab.id = category.id;
        tab.textContent = category.name;
        tabList.appendChild(tab);

        // Create tab content
        const tabContent = document.createElement('div');
        tabContent.className = 'tab-content' + (index === 0 ? ' active' : '');
        tabContent.id = 'tab-' + category.id;
        tabContent.setAttribute('role', 'tabpanel');
        tabContent.setAttribute('aria-labelledby', category.id);

        tabContent.innerHTML = `
            <h2 class="group-header">${category.name}</h2>
            <p class="group-description">${category.description}</p>
            <div class="section-grid" id="grid-${category.id}"></div>
        `;

        tabContentContainer.appendChild(tabContent);

        // Render foundations for this category
        const grid = tabContent.querySelector(`#grid-${category.id}`);
        const categoryData = groupedData[category.id];
        renderFoundations(categoryData, grid);
    });

    // Setup tab click handlers
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
            const tabId = tab.getAttribute('data-tab');
            const tabsContainer = tab.closest('.tabs-container');

            // Remove active from all tabs and content
            tabsContainer.querySelectorAll('.tab').forEach(t => {
                t.classList.remove('active');
                t.setAttribute('aria-selected', 'false');
            });
            tabsContainer.querySelectorAll('.tab-content').forEach(c => {
                c.classList.remove('active');
            });

            // Add active to selected tab and content
            tab.classList.add('active');
            tab.setAttribute('aria-selected', 'true');
            document.getElementById('tab-' + tabId).classList.add('active');
        });
    });
}

/**
 * Handle hash navigation
 */
function handleHash() {
    const hash = window.location.hash.substring(1);
    if (hash) {
        const tab = document.querySelector(`.tab[data-tab="${hash}"]`);
        if (tab) {
            tab.click();
        }
    }
}

/**
 * Initialize the foundations loader
 */
async function initFoundationsLoader() {
    const data = await fetchFoundationsData();

    if (!data) {
        console.error('Failed to load foundations data');
        return;
    }

    const groupedData = groupByCategory(data);
    const categories = getCategories(groupedData);

    if (categories.length === 0) {
        console.error('No categories found');
        return;
    }

    // Setup tabs and render content
    setupTabs(groupedData, categories);

    // Setup hash navigation
    window.addEventListener('hashchange', handleHash);
    handleHash();
}

// Export for use in HTML
if (typeof window !== 'undefined') {
    window.initFoundationsLoader = initFoundationsLoader;
}
