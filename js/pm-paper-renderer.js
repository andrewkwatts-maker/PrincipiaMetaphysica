/**
 * PM Paper Renderer
 * =================
 *
 * Dynamically renders the complete Principia Metaphysica paper from theory_output.json.
 * Loads sections, renders formulas, populates parameters, and triggers MathJax.
 *
 * Features:
 * - Loads all sections from theory_output.json
 * - Renders title, abstract, and sections dynamically
 * - Replaces inline formulas with data-formula-id references
 * - Uses PM.get() for parameter values
 * - Coordinates MathJax typesetting
 * - Supports loading section HTML files
 *
 * Usage:
 *   import { renderPaper } from './pm-paper-renderer.js';
 *   await renderPaper('paper-container');
 *
 * Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
 * Version: 1.0.0
 */

(function() {
    'use strict';

    // ========================================================================
    // STATE MANAGEMENT
    // ========================================================================

    const PaperRenderer = {
        _data: null,
        _loaded: false,
        _loading: null,
        _sectionsCache: new Map(),
        _debug: false
    };

    // ========================================================================
    // MAIN RENDERING FUNCTIONS
    // ========================================================================

    /**
     * Render the complete paper into a container
     * @param {string} containerId - ID of the container element
     * @param {Object} options - Rendering options
     * @returns {Promise<boolean>} - True if rendered successfully
     */
    async function renderPaper(containerId, options = {}) {
        const {
            loadSections = true,
            loadFormulas = true,
            loadParameters = true,
            renderAbstract = true,
            renderTOC = true,
            debug = false
        } = options;

        PaperRenderer._debug = debug;

        // 1. Load theory_output.json
        const loaded = await loadTheoryData();
        if (!loaded) {
            console.error('PMPaperRenderer: Failed to load theory_output.json');
            return false;
        }

        // 2. Get container
        const container = document.getElementById(containerId);
        if (!container) {
            console.error(`PMPaperRenderer: Container not found: ${containerId}`);
            return false;
        }

        // 3. Clear container
        container.innerHTML = '';
        container.classList.add('pm-paper-container');

        // 4. Render paper components
        try {
            // Title and metadata
            if (PaperRenderer._data.metadata) {
                renderTitle(container, PaperRenderer._data.metadata);
            }

            // Abstract
            if (renderAbstract && PaperRenderer._data.sections?.['1']?.abstract) {
                renderAbstractSection(container, PaperRenderer._data.sections['1'].abstract);
            }

            // Table of Contents
            if (renderTOC) {
                renderTableOfContents(container, PaperRenderer._data.sections);
            }

            // Main sections
            if (loadSections && PaperRenderer._data.sections) {
                await renderAllSections(container, PaperRenderer._data.sections, { loadFormulas, loadParameters });
            }

            // Trigger MathJax
            if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                console.log('PMPaperRenderer: Triggering MathJax...');
                await MathJax.typesetPromise([container]);
            }

            console.log('%cPMPaperRenderer: Paper rendered successfully', 'color: green; font-weight: bold');
            return true;

        } catch (error) {
            console.error('PMPaperRenderer: Error during rendering:', error);
            return false;
        }
    }

    /**
     * Load theory_output.json data
     * @private
     */
    async function loadTheoryData() {
        if (PaperRenderer._loaded) return true;
        if (PaperRenderer._loading) return PaperRenderer._loading;

        PaperRenderer._loading = (async () => {
            const pathPrefixes = [
                '/AutoGenerated/',          // Absolute path (for live site)
                'AutoGenerated/',
                './AutoGenerated/',
                '../AutoGenerated/',
                '../../AutoGenerated/'
            ];

            // Strategy 1: Try theory_output.json (full unified file)
            for (const prefix of pathPrefixes) {
                try {
                    const path = prefix + 'theory_output.json';
                    const response = await fetch(path);
                    if (response.ok) {
                        PaperRenderer._data = await response.json();
                        PaperRenderer._loaded = true;
                        PaperRenderer._basePath = prefix;
                        console.log(`PMPaperRenderer: Loaded theory_output.json from ${path}`);
                        return true;
                    }
                } catch (e) {
                    if (PaperRenderer._debug) {
                        console.debug(`PMPaperRenderer: Failed to load from ${prefix}theory_output.json`);
                    }
                }
            }

            // Strategy 2: Try loading split component files
            for (const prefix of pathPrefixes) {
                try {
                    const sectionsPath = prefix + 'sections.json';
                    const sectionsResponse = await fetch(sectionsPath);
                    if (sectionsResponse.ok) {
                        const sectionsData = await sectionsResponse.json();
                        PaperRenderer._data = {
                            sections: sectionsData.sections || sectionsData,
                            formulas: {},
                            parameters: {}
                        };

                        // Try to load formulas and parameters too
                        try {
                            const formulasResponse = await fetch(prefix + 'formulas.json');
                            if (formulasResponse.ok) {
                                const formulasData = await formulasResponse.json();
                                PaperRenderer._data.formulas = formulasData.formulas || formulasData;
                            }
                        } catch (e) { /* Optional */ }

                        try {
                            const paramsResponse = await fetch(prefix + 'parameters.json');
                            if (paramsResponse.ok) {
                                const paramsData = await paramsResponse.json();
                                PaperRenderer._data.parameters = paramsData.parameters || paramsData;
                            }
                        } catch (e) { /* Optional */ }

                        PaperRenderer._loaded = true;
                        PaperRenderer._basePath = prefix;
                        console.log(`PMPaperRenderer: Loaded from split files at ${prefix}`);
                        return true;
                    }
                } catch (e) {
                    if (PaperRenderer._debug) {
                        console.debug(`PMPaperRenderer: Failed to load split files from ${prefix}`);
                    }
                }
            }

            console.error('PMPaperRenderer: Could not load data files');
            return false;
        })();

        return PaperRenderer._loading;
    }

    /**
     * Load a single section from individual file (lazy loading)
     * @private
     */
    async function loadIndividualSection(sectionId) {
        const prefix = PaperRenderer._basePath || '/AutoGenerated/';
        const isAppendix = /^[A-N]$/.test(sectionId);
        const fileName = isAppendix ? `appendix-${sectionId}.json` : `section-${sectionId}.json`;
        const path = `${prefix}sections/${fileName}`;

        try {
            const response = await fetch(path);
            if (response.ok) {
                const section = await response.json();
                // Cache the loaded section
                if (!PaperRenderer._data.sections) {
                    PaperRenderer._data.sections = {};
                }
                PaperRenderer._data.sections[sectionId] = section;
                console.log(`PMPaperRenderer: Lazy loaded section ${sectionId} from ${path}`);
                return section;
            }
        } catch (e) {
            if (PaperRenderer._debug) {
                console.debug(`PMPaperRenderer: Failed to load ${path}`);
            }
        }
        return null;
    }

    // ========================================================================
    // COMPONENT RENDERERS
    // ========================================================================

    /**
     * Render paper title and metadata
     * @private
     */
    function renderTitle(container, metadata) {
        const titleSection = document.createElement('div');
        titleSection.className = 'paper-title-section';
        titleSection.innerHTML = `
            <h1 class="paper-title">${metadata.title || 'Principia Metaphysica'}</h1>
            ${metadata.subtitle ? `<h2 class="paper-subtitle">${metadata.subtitle}</h2>` : ''}
            ${metadata.author ? `<div class="paper-author">${metadata.author}</div>` : ''}
            ${metadata.date ? `<div class="paper-date">${metadata.date}</div>` : ''}
            ${metadata.version ? `<div class="paper-version">Version ${metadata.version}</div>` : ''}
        `;
        container.appendChild(titleSection);
    }

    /**
     * Render abstract section
     * @private
     */
    function renderAbstractSection(container, abstractText) {
        const abstractDiv = document.createElement('div');
        abstractDiv.className = 'paper-abstract';
        abstractDiv.innerHTML = `
            <h2>Abstract</h2>
            <p>${abstractText}</p>
        `;
        container.appendChild(abstractDiv);
    }

    /**
     * Render table of contents
     * @private
     */
    function renderTableOfContents(container, sections) {
        if (!sections || Object.keys(sections).length === 0) return;

        const tocDiv = document.createElement('div');
        tocDiv.className = 'paper-toc';
        tocDiv.innerHTML = '<h2>Table of Contents</h2>';

        const tocList = document.createElement('ol');
        tocList.className = 'toc-list';

        // Sort sections by order or ID
        const sortedSections = Object.values(sections).sort((a, b) => {
            const orderA = a.order || parseInt(a.id) || 0;
            const orderB = b.order || parseInt(b.id) || 0;
            return orderA - orderB;
        });

        for (const section of sortedSections) {
            const li = document.createElement('li');
            li.innerHTML = `
                <a href="#section-${section.id}" class="toc-link">
                    <span class="toc-number">${section.id}</span>
                    <span class="toc-title">${section.title}</span>
                </a>
            `;
            tocList.appendChild(li);

            // Subsections (if any)
            if (section.subsections && section.subsections.length > 0) {
                const subList = document.createElement('ol');
                subList.className = 'toc-sublist';
                for (const subsection of section.subsections) {
                    const subLi = document.createElement('li');
                    subLi.innerHTML = `
                        <a href="#section-${subsection.id}" class="toc-link">
                            <span class="toc-number">${subsection.id}</span>
                            <span class="toc-title">${subsection.title}</span>
                        </a>
                    `;
                    subList.appendChild(subLi);
                }
                li.appendChild(subList);
            }
        }

        tocDiv.appendChild(tocList);
        container.appendChild(tocDiv);
    }

    /**
     * Render all sections
     * @private
     */
    async function renderAllSections(container, sections, options) {
        if (!sections || Object.keys(sections).length === 0) return;

        const sectionsDiv = document.createElement('div');
        sectionsDiv.className = 'paper-sections';

        // Sort sections by order
        const sortedSections = Object.values(sections).sort((a, b) => {
            const orderA = a.order || parseInt(a.id) || 0;
            const orderB = b.order || parseInt(b.id) || 0;
            return orderA - orderB;
        });

        for (const section of sortedSections) {
            const sectionEl = await renderSection(section, options);
            if (sectionEl) {
                sectionsDiv.appendChild(sectionEl);
            }
        }

        container.appendChild(sectionsDiv);
    }

    /**
     * Render a single section with subsections
     * @param {Object} section - Section data from theory_output.json
     * @param {Object} options - Rendering options
     * @returns {Promise<HTMLElement>} - Rendered section element
     */
    async function renderSection(section, options = {}) {
        const { loadFormulas = true, loadParameters = true, useJsonContent = true } = options;

        // Handle both flat structure and metadata/content wrapper
        const sectionId = section.metadata?.id || section.id;
        const sectionTitle = section.metadata?.title || section.title;
        const sectionAbstract = section.metadata?.abstract || section.abstract;
        const subsections = section.content?.subsections || section.subsections || [];
        const contentBlocks = section.contentBlocks || section.content_blocks || [];

        const sectionDiv = document.createElement('section');
        sectionDiv.id = `section-${sectionId}`;
        sectionDiv.className = 'paper-section';
        sectionDiv.setAttribute('data-section-id', sectionId);

        // Add appendix alias for letter-based section IDs (e.g., B -> appendix-b)
        if (/^[A-Za-z]$/.test(sectionId)) {
            const appendixAlias = document.createElement('a');
            appendixAlias.id = `appendix-${sectionId.toLowerCase()}`;
            appendixAlias.className = 'appendix-anchor';
            sectionDiv.insertBefore(appendixAlias, sectionDiv.firstChild);
        }

        // Section header
        const header = document.createElement('div');
        header.className = 'section-header';
        header.innerHTML = `
            <h2 class="section-title">
                <span class="section-number">${sectionId}</span>
                ${sectionTitle}
            </h2>
        `;
        sectionDiv.appendChild(header);

        // Section abstract (if available)
        if (sectionAbstract) {
            const abstractDiv = document.createElement('div');
            abstractDiv.className = 'section-abstract';
            abstractDiv.innerHTML = `<p>${sectionAbstract}</p>`;
            sectionDiv.appendChild(abstractDiv);
        }

        // Render subsections from JSON
        if (useJsonContent && subsections.length > 0) {
            const subsectionsDiv = document.createElement('div');
            subsectionsDiv.className = 'section-subsections';

            for (const subsection of subsections) {
                const subDiv = renderSubsection(subsection);
                subsectionsDiv.appendChild(subDiv);
            }

            sectionDiv.appendChild(subsectionsDiv);

            // Process formulas, parameters, and equation references
            if (loadFormulas) {
                processFormulas(subsectionsDiv);
            }
            if (loadParameters) {
                processParameters(subsectionsDiv);
            }
            // Always process equation cross-references in paper mode
            processEquationReferences(subsectionsDiv);
        }
        // Fallback: Try to load section HTML file if no JSON content
        else if (section.sectionFile) {
            const content = await loadSectionFile(section.sectionFile);
            if (content) {
                const contentDiv = document.createElement('div');
                contentDiv.className = 'section-content';
                contentDiv.innerHTML = content;
                sectionDiv.appendChild(contentDiv);

                if (loadFormulas) {
                    processFormulas(contentDiv);
                }
                if (loadParameters) {
                    processParameters(contentDiv);
                }
                processEquationReferences(contentDiv);
            } else {
                // No HTML file found - show placeholder
                if (PaperRenderer._debug) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'empty-section-placeholder';
                    placeholder.style.cssText = 'padding: 1rem; color: rgba(255,255,255,0.4); font-style: italic; background: rgba(255,255,255,0.02); border-radius: 4px; margin: 1rem 0;';
                    placeholder.textContent = `[Section content for "${sectionTitle}" is being developed - referenced file: ${section.sectionFile}]`;
                    sectionDiv.appendChild(placeholder);
                }
            }
        }
        // No subsections and no section file - completely empty
        else if (subsections.length === 0 && contentBlocks.length === 0) {
            if (PaperRenderer._debug) {
                const placeholder = document.createElement('div');
                placeholder.className = 'empty-section-placeholder';
                placeholder.style.cssText = 'padding: 1rem; color: rgba(255,255,255,0.4); font-style: italic; background: rgba(255,255,255,0.02); border-radius: 4px; margin: 1rem 0;';
                placeholder.textContent = `[Content for this section is being developed]`;
                sectionDiv.appendChild(placeholder);
            }
        }

        // Render top-level content blocks (if any)
        if (contentBlocks.length > 0) {
            const blocksDiv = renderContentBlocks(contentBlocks);
            sectionDiv.appendChild(blocksDiv);
        }

        // Key takeaways (if available)
        if (section.keyTakeaways && section.keyTakeaways.length > 0) {
            const takeawaysDiv = document.createElement('div');
            takeawaysDiv.className = 'section-takeaways';
            takeawaysDiv.innerHTML = `
                <h3>Key Takeaways</h3>
                <ul>
                    ${section.keyTakeaways.map(item => `<li>${item}</li>`).join('')}
                </ul>
            `;
            sectionDiv.appendChild(takeawaysDiv);
        }

        return sectionDiv;
    }

    /**
     * Render a subsection with its content blocks
     * @private
     */
    function renderSubsection(subsection) {
        const subDiv = document.createElement('div');
        subDiv.className = 'paper-subsection';
        subDiv.id = `subsection-${subsection.id || subsection.number || 'unknown'}`;

        // Subsection header
        const header = document.createElement('h3');
        header.className = 'subsection-title';
        header.innerHTML = `
            <span class="subsection-number">${subsection.number || ''}</span>
            ${subsection.title}
        `;
        subDiv.appendChild(header);

        // Render content blocks (support camelCase, snake_case, and plain content)
        let blocks = subsection.contentBlocks || subsection.content_blocks || subsection.content || [];

        // Handle string content (convert to single paragraph block)
        if (typeof blocks === 'string') {
            blocks = [{ type: 'paragraph', text: blocks }];
        }

        if (Array.isArray(blocks) && blocks.length > 0) {
            for (const block of blocks) {
                const blockEl = renderContentBlock(block);
                if (blockEl) {
                    subDiv.appendChild(blockEl);
                }
            }
        } else if (!Array.isArray(blocks) && blocks) {
            // Object content - treat as single block
            const blockEl = renderContentBlock(blocks);
            if (blockEl) {
                subDiv.appendChild(blockEl);
            }
        } else {
            // Empty subsection - add placeholder message
            if (PaperRenderer._debug) {
                const placeholder = document.createElement('p');
                placeholder.className = 'empty-subsection-placeholder';
                placeholder.style.cssText = 'color: rgba(255,255,255,0.3); font-style: italic; padding: 0.5rem;';
                placeholder.textContent = '[Content for this subsection is being developed]';
                subDiv.appendChild(placeholder);
            }
        }

        // Handle nested subsections
        if (subsection.subsections && subsection.subsections.length > 0) {
            for (const nested of subsection.subsections) {
                const nestedDiv = renderSubsection(nested);
                subDiv.appendChild(nestedDiv);
            }
        }

        return subDiv;
    }

    /**
     * Load section HTML file
     * @private
     */
    async function loadSectionFile(filePath) {
        // Check cache first
        if (PaperRenderer._sectionsCache.has(filePath)) {
            return PaperRenderer._sectionsCache.get(filePath);
        }

        const pathPrefixes = ['', '../', '../../'];

        for (const prefix of pathPrefixes) {
            try {
                const fullPath = prefix + filePath;
                const response = await fetch(fullPath);
                if (response.ok) {
                    const html = await response.text();

                    // Extract content from the <body> tag
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const body = doc.querySelector('body');

                    if (body) {
                        const content = body.innerHTML;
                        PaperRenderer._sectionsCache.set(filePath, content);
                        return content;
                    }
                }
            } catch (e) {
                if (PaperRenderer._debug) {
                    console.debug(`PMPaperRenderer: Failed to load ${filePath} from ${prefix}`);
                }
            }
        }

        console.warn(`PMPaperRenderer: Could not load section file: ${filePath}`);
        return null;
    }

    /**
     * Render content blocks
     * @private
     */
    function renderContentBlocks(blocks) {
        const container = document.createElement('div');
        container.className = 'content-blocks';

        for (const block of blocks) {
            const blockEl = renderContentBlock(block);
            if (blockEl) {
                container.appendChild(blockEl);
            }
        }

        return container;
    }

    /**
     * Render a single content block
     * @private
     */
    function renderContentBlock(block) {
        // Helper function to safely convert values to strings
        const safeStringify = (value, fieldName = 'content') => {
            if (value === null || value === undefined) return '';
            if (typeof value === 'object') {
                console.warn(`PMPaperRenderer: Found object in ${fieldName} field of ${block.type} block, converting to JSON:`, value);
                return JSON.stringify(value);
            }
            return String(value);
        };

        const blockDiv = document.createElement('div');
        blockDiv.className = `content-block content-block-${block.type}`;

        switch (block.type) {
            case 'paragraph':
            case 'text':
                blockDiv.innerHTML = `<p>${safeStringify(block.content || block.text, 'text/content')}</p>`;
                break;

            case 'heading':
                const level = block.level || 3;
                blockDiv.innerHTML = `<h${level}>${safeStringify(block.content, 'heading.content')}</h${level}>`;
                break;

            case 'formula':
            case 'equation':
                // Render equation in academic paper style
                const formulaHtml = renderEquation(block);
                if (formulaHtml) {
                    blockDiv.innerHTML = formulaHtml;
                } else {
                    // Fallback for simple formula blocks
                    blockDiv.innerHTML = `
                        <div class="formula-block" data-formula-id="${block.formulaId || block.id || block.label}">
                            ${block.latex ? `$$${block.latex}$$` : (block.content || '')}
                        </div>
                    `;
                }
                break;

            case 'list':
                const listType = block.ordered ? 'ol' : 'ul';
                const listItems = (block.items || []).map((item, idx) =>
                    `<li>${safeStringify(item, `list.items[${idx}]`)}</li>`
                ).join('');
                blockDiv.innerHTML = `<${listType}>${listItems}</${listType}>`;
                break;

            case 'code':
                const lang = block.language ? ` class="language-${block.language}"` : '';
                blockDiv.innerHTML = `<pre><code${lang}>${escapeHtml(block.content || '')}</code></pre>`;
                break;

            case 'quote':
            case 'blockquote':
                blockDiv.innerHTML = `<blockquote>${safeStringify(block.content, 'quote.content')}</blockquote>`;
                break;

            case 'table':
                blockDiv.innerHTML = renderTable(block);
                break;

            case 'derivation':
            case 'derivation_box':
                blockDiv.className = 'derivation-box';
                blockDiv.innerHTML = `
                    <div class="derivation-title">${block.title || 'Derivation'}</div>
                    <div class="derivation-content">${block.content || ''}</div>
                `;
                break;

            case 'callout':
            case 'info_box':
            case 'highlight':
                const calloutType = block.calloutType || block.variant || 'info';
                blockDiv.className = `callout callout-${calloutType}`;
                blockDiv.innerHTML = `
                    ${block.title ? `<div class="callout-title">${block.title}</div>` : ''}
                    <div class="callout-content">${block.content || ''}</div>
                `;
                break;

            case 'subsection':
                // Nested subsection - recursively render
                if (block.subsection) {
                    return renderSubsection(block.subsection);
                }
                blockDiv.innerHTML = safeStringify(block.content, 'subsection.content');
                break;

            default:
                // Handle unknown types gracefully - ensure content is a string
                blockDiv.innerHTML = safeStringify(block.content || block.text, 'unknown.content');
        }

        return blockDiv;
    }

    /**
     * Render a table from block data
     * @private
     */
    function renderTable(block) {
        const headers = block.headers || [];
        const rows = block.rows || [];

        // Helper to safely stringify table values
        const safeTableValue = (value, type, index) => {
            if (value === null || value === undefined) return '';
            if (typeof value === 'object') {
                console.warn(`PMPaperRenderer: Found object in table ${type}[${index}], converting to JSON:`, value);
                return JSON.stringify(value);
            }
            return String(value);
        };

        let html = '<table class="pm-table">';

        if (headers.length > 0) {
            html += '<thead><tr>';
            headers.forEach((header, idx) => {
                html += `<th>${safeTableValue(header, 'header', idx)}</th>`;
            });
            html += '</tr></thead>';
        }

        if (rows.length > 0) {
            html += '<tbody>';
            rows.forEach((row, rowIdx) => {
                html += '<tr>';
                row.forEach((cell, cellIdx) => {
                    html += `<td>${safeTableValue(cell, `row[${rowIdx}].cell`, cellIdx)}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody>';
        }

        html += '</table>';
        return html;
    }

    // ========================================================================
    // FORMULA AND PARAMETER PROCESSING
    // ========================================================================

    /**
     * Render an equation in academic paper style
     * @param {Object} block - Formula/equation content block
     * @returns {string|null} - HTML string for academic-style equation
     * @private
     */
    function renderEquation(block) {
        // Get formula ID from various possible fields
        const formulaId = block.formulaId || block.id || block.label;
        if (!formulaId) return null;

        // Try to get full formula metadata from global data
        let formulaData = null;
        if (PaperRenderer._data?.formulas?.formulas) {
            formulaData = PaperRenderer._data.formulas.formulas[formulaId];
        }

        // Extract equation number from label (e.g., "(4.2)" from label or formulaData)
        const label = block.label || formulaData?.label || '';
        const equationNumber = extractEquationNumber(label);

        // Get LaTeX code
        let latex = block.latex || formulaData?.latex || '';

        // Build the equation HTML with anchor ID
        const anchorId = equationNumber ? `eq-${equationNumber}` : `eq-${formulaId}`;
        let html = `<div class="equation-wrapper academic-equation" id="${anchorId}">`;

        // Main equation with number
        html += '<div class="equation-line">';
        html += `<div class="equation-content">$$${latex}$$</div>`;
        if (equationNumber) {
            html += `<div class="equation-number">(${equationNumber})</div>`;
        }
        html += '</div>';

        // Parameter definitions (from terms)
        if (formulaData?.terms) {
            html += '<div class="equation-terms">';
            const termsList = renderTermsDefinition(formulaData.terms);
            if (termsList) {
                html += `<p class="terms-intro">where ${termsList}</p>`;
            }
            html += '</div>';
        }

        // Discussion/description
        if (formulaData?.description || block.description) {
            const description = formulaData?.description || block.description;
            html += `<div class="equation-discussion"><p>${description}</p></div>`;
        }

        // Derivation reference
        if (formulaData?.derivation?.parentFormulas) {
            const parents = formulaData.derivation.parentFormulas;
            if (parents.length > 0) {
                const refs = parents.map(pid => {
                    const parentFormula = PaperRenderer._data?.formulas?.formulas?.[pid];
                    return parentFormula ? formatFormulaReference(parentFormula) : pid;
                }).join(', ');
                html += `<div class="equation-derivation"><p class="derived-from">Derived from ${refs}</p></div>`;
            }
        }

        // Custom derivation note
        if (formulaData?.derivation?.note || block.derivationNote) {
            const note = formulaData?.derivation?.note || block.derivationNote;
            html += `<div class="equation-derivation"><p>${note}</p></div>`;
        }

        html += '</div>';
        return html;
    }

    /**
     * Extract equation number from label string
     * @param {string} label - Formula label like "(4.2) Three Generations"
     * @returns {string|null} - Equation number like "4.2"
     * @private
     */
    function extractEquationNumber(label) {
        if (!label) return null;

        // Match patterns like "(4.2)" or "(Eq. 4.2)" at the start
        const match = label.match(/^\((?:Eq\.\s*)?([0-9]+\.[0-9]+)\)/);
        if (match) return match[1];

        // Match patterns like "4.2" or "Eq. 4.2"
        const simpleMatch = label.match(/^(?:Eq\.\s*)?([0-9]+\.[0-9]+)/);
        if (simpleMatch) return simpleMatch[1];

        return null;
    }

    /**
     * Render terms as inline definition list
     * @param {Object} terms - Terms object with parameter definitions
     * @returns {string} - Formatted "X is..., Y represents..." string
     * @private
     */
    function renderTermsDefinition(terms) {
        if (!terms || Object.keys(terms).length === 0) return '';

        const definitions = [];
        for (const [symbol, termData] of Object.entries(terms)) {
            const desc = termData.description || termData.name || '';
            if (desc) {
                // Format: "X is the description" or "X represents the description"
                const verb = definitions.length === 0 ? 'is' : 'is';
                const cleanDesc = desc.replace(/^(is|represents|denotes)\s+/i, '');
                definitions.push(`<i>${symbol}</i> ${verb} ${cleanDesc}`);
            }
        }

        return definitions.join(', ');
    }

    /**
     * Format a formula reference for citation
     * @param {Object} formula - Formula data object
     * @returns {string} - Formatted reference like "[Section 2.3, Eq. (2.7)]"
     * @private
     */
    function formatFormulaReference(formula) {
        const eqNum = extractEquationNumber(formula.label);
        const section = formula.section || '';

        if (eqNum && section) {
            return `[${section}, Eq. (${eqNum})]`;
        } else if (eqNum) {
            return `[Eq. (${eqNum})]`;
        } else if (section) {
            return `[${section}]`;
        } else {
            return `[${formula.label || formula.id}]`;
        }
    }

    /**
     * Process formulas in a container
     * Replaces inline formula references with proper data-formula-id elements
     * @private
     */
    function processFormulas(container) {
        // Find all elements with data-formula-id that are empty
        const formulaElements = container.querySelectorAll('[data-formula-id]');

        formulaElements.forEach(el => {
            const formulaId = el.getAttribute('data-formula-id');

            // Skip if already has content
            if (el.innerHTML.trim() && !el.classList.contains('pm-formula-auto')) {
                return;
            }

            // Try to get formula from PM
            if (window.PM && typeof window.PM.formula === 'function') {
                const formula = window.PM.formula(formulaId);
                if (formula) {
                    el.innerHTML = formula.html || formula.latex || formula.plainText || '';
                    el.classList.add('pm-formula-loaded');

                    // Add tooltip with description
                    if (formula.description) {
                        el.setAttribute('title', formula.description);
                    }
                }
            }
        });
    }

    /**
     * Process equation cross-references in text
     * Converts "Eq. (4.2)" to clickable links
     * @param {HTMLElement} container - Container to process
     * @private
     */
    function processEquationReferences(container) {
        // Find all text nodes
        const walker = document.createTreeWalker(
            container,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );

        const textNodes = [];
        let node;
        while (node = walker.nextNode()) {
            // Skip if parent is script, style, or already a link
            const parent = node.parentElement;
            if (parent && !['SCRIPT', 'STYLE', 'A', 'CODE', 'PRE'].includes(parent.tagName)) {
                textNodes.push(node);
            }
        }

        // Process each text node
        for (const textNode of textNodes) {
            const text = textNode.textContent;

            // Match patterns like "Eq. (4.2)", "equation (4.2)", "(4.2)"
            const pattern = /\b(?:Eq\.|equation)\s*\(([0-9]+\.[0-9]+)\)|\(([0-9]+\.[0-9]+)\)/gi;

            if (pattern.test(text)) {
                // Create a temporary container to build the replacement HTML
                const tempDiv = document.createElement('div');
                let lastIndex = 0;
                let match;
                pattern.lastIndex = 0; // Reset regex

                while ((match = pattern.exec(text)) !== null) {
                    const eqNum = match[1] || match[2];
                    const fullMatch = match[0];

                    // Add text before match
                    if (match.index > lastIndex) {
                        tempDiv.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                    }

                    // Create link to equation
                    const link = document.createElement('a');
                    link.href = `#eq-${eqNum}`;
                    link.className = 'equation-ref';
                    link.textContent = fullMatch;
                    tempDiv.appendChild(link);

                    lastIndex = match.index + fullMatch.length;
                }

                // Add remaining text
                if (lastIndex < text.length) {
                    tempDiv.appendChild(document.createTextNode(text.substring(lastIndex)));
                }

                // Replace the text node with the new content
                if (tempDiv.childNodes.length > 0) {
                    const parent = textNode.parentNode;
                    while (tempDiv.firstChild) {
                        parent.insertBefore(tempDiv.firstChild, textNode);
                    }
                    parent.removeChild(textNode);
                }
            }
        }
    }

    /**
     * Process parameters in a container
     * Replaces data-pm-value elements with actual values
     * @private
     */
    function processParameters(container) {
        // Process data-pm-value elements
        const pmValueElements = container.querySelectorAll('[data-pm-value]');

        pmValueElements.forEach(el => {
            const path = el.getAttribute('data-pm-value');
            const format = el.getAttribute('data-format');

            if (window.PM && typeof window.PM.get === 'function') {
                const value = window.PM.get(path);
                if (value !== null && value !== undefined) {
                    el.textContent = formatValue(value, format);
                    el.classList.add('pm-loaded');
                    el.classList.remove('pm-loading', 'pm-error');
                }
            }
        });

        // Process data-category + data-param elements
        const categoryElements = container.querySelectorAll('[data-category][data-param]');

        categoryElements.forEach(el => {
            const category = el.getAttribute('data-category');
            const param = el.getAttribute('data-param');
            const format = el.getAttribute('data-format');

            if (window.PM && typeof window.PM.get === 'function') {
                // Try multiple paths
                const paths = [
                    `simulations.${param}`,
                    `simulations.${category}.${param}`,
                    `parameters.${category}.${param}`,
                    `${category}.${param}`
                ];

                for (const path of paths) {
                    let value = window.PM.get(path);

                    // Auto-extract .value property if present
                    if (value !== null && value !== undefined && typeof value === 'object' && 'value' in value) {
                        value = value.value;
                    }

                    if (value !== null && value !== undefined) {
                        el.textContent = formatValue(value, format);
                        el.classList.add('pm-loaded');
                        el.classList.remove('pm-loading', 'pm-error');
                        break;
                    }
                }
            }
        });
    }

    /**
     * Render a formula by ID
     * @param {string} formulaId - Formula ID
     * @returns {string|null} - HTML/LaTeX string
     */
    function renderFormula(formulaId) {
        if (!window.PM || typeof window.PM.formula !== 'function') {
            console.error('PMPaperRenderer: PM.formula() not available');
            return null;
        }

        const formula = window.PM.formula(formulaId);
        if (!formula) {
            console.warn(`PMPaperRenderer: Formula not found: ${formulaId}`);
            return null;
        }

        return formula.html || formula.latex || formula.plainText || null;
    }

    // ========================================================================
    // UTILITY FUNCTIONS
    // ========================================================================

    /**
     * Format a value for display
     * @private
     */
    function formatValue(value, format) {
        if (value === null || value === undefined) return '?';

        if (typeof value === 'number') {
            if (format) {
                if (format.startsWith('scientific:')) {
                    const decimals = parseInt(format.split(':')[1]) || 2;
                    return value.toExponential(decimals);
                }
                if (format.startsWith('fixed:')) {
                    const decimals = parseInt(format.split(':')[1]) || 2;
                    return value.toFixed(decimals);
                }
                if (format === 'percent') {
                    return (value * 100).toFixed(1) + '%';
                }
                if (format === 'integer') {
                    return Math.round(value).toString();
                }
            }

            // Auto-format based on magnitude
            if (Math.abs(value) >= 1e10 || (Math.abs(value) < 0.001 && value !== 0)) {
                return value.toExponential(2);
            } else if (Number.isInteger(value)) {
                return value.toString();
            } else {
                return value.toFixed(3);
            }
        }

        if (typeof value === 'boolean') {
            return value ? 'Yes' : 'No';
        }

        return String(value);
    }

    /**
     * Escape HTML special characters
     * @private
     */
    function escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }

    /**
     * Trigger MathJax typesetting on a specific element
     * @param {HTMLElement} element - Element to typeset
     */
    function typesetMathJax(element) {
        if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
            MathJax.typesetPromise([element]).catch(err => {
                console.warn('PMPaperRenderer: MathJax typesetting failed:', err);
            });
        } else if (typeof MathJax !== 'undefined' && MathJax.Hub) {
            MathJax.Hub.Queue(['Typeset', MathJax.Hub, element]);
        }
    }

    // ========================================================================
    // PUBLIC API
    // ========================================================================

    const API = {
        renderPaper,
        renderSection,
        renderFormula,
        renderEquation,
        processFormulas,
        processParameters,
        processEquationReferences,
        typesetMathJax,
        get data() { return PaperRenderer._data; },
        get loaded() { return PaperRenderer._loaded; }
    };

    // Export globally
    window.PMPaperRenderer = API;

    // Export for ES modules
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = API;
    }

    console.log('PMPaperRenderer: Ready (v1.0.0)');

})();
