/**
 * PM Paper Renderer
 * =================
 *
 * Dynamically renders the complete Principia Metaphysica paper from theory_output.json.
 * Loads sections, renders formulas, populates parameters, and triggers MathJax.
 *
 * Features:
 * - Loads all sections from theory_output.json
 * - Renders title, abstract, and sections dynamically
 * - Replaces inline formulas with data-formula-id references
 * - Uses PM.get() for parameter values
 * - Coordinates MathJax typesetting
 * - Supports loading section HTML files
 *
 * Usage:
 *   import { renderPaper } from './pm-paper-renderer.js';
 *   await renderPaper('paper-container');
 *
 * Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
 * Version: 1.0.0
 */

(function() {
    'use strict';

    // ========================================================================
    // STATE MANAGEMENT
    // ========================================================================

    const PaperRenderer = {
        _data: null,
        _loaded: false,
        _loading: null,
        _sectionsCache: new Map(),
        _debug: false
    };

    // ========================================================================
    // MAIN RENDERING FUNCTIONS
    // ========================================================================

    /**
     * Render the complete paper into a container
     * @param {string} containerId - ID of the container element
     * @param {Object} options - Rendering options
     * @returns {Promise<boolean>} - True if rendered successfully
     */
    async function renderPaper(containerId, options = {}) {
        const {
            loadSections = true,
            loadFormulas = true,
            loadParameters = true,
            renderAbstract = true,
            renderTOC = true,
            debug = false
        } = options;

        PaperRenderer._debug = debug;

        // 1. Load theory_output.json
        const loaded = await loadTheoryData();
        if (!loaded) {
            console.error('PMPaperRenderer: Failed to load theory_output.json');
            return false;
        }

        // 2. Get container
        const container = document.getElementById(containerId);
        if (!container) {
            console.error(`PMPaperRenderer: Container not found: ${containerId}`);
            return false;
        }

        // 3. Clear container
        container.innerHTML = '';
        container.classList.add('pm-paper-container');

        // 4. Render paper components
        try {
            // Title and metadata
            if (PaperRenderer._data.metadata) {
                renderTitle(container, PaperRenderer._data.metadata);
            }

            // Abstract
            if (renderAbstract && PaperRenderer._data.sections?.['1']?.abstract) {
                renderAbstractSection(container, PaperRenderer._data.sections['1'].abstract);
            }

            // Table of Contents
            if (renderTOC) {
                renderTableOfContents(container, PaperRenderer._data.sections);
            }

            // Main sections
            if (loadSections && PaperRenderer._data.sections) {
                await renderAllSections(container, PaperRenderer._data.sections, { loadFormulas, loadParameters });
            }

            // Trigger MathJax
            if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                console.log('PMPaperRenderer: Triggering MathJax...');
                await MathJax.typesetPromise([container]);
            }

            console.log('%cPMPaperRenderer: Paper rendered successfully', 'color: green; font-weight: bold');
            return true;

        } catch (error) {
            console.error('PMPaperRenderer: Error during rendering:', error);
            return false;
        }
    }

    /**
     * Load theory_output.json data
     * @private
     */
    async function loadTheoryData() {
        if (PaperRenderer._loaded) return true;
        if (PaperRenderer._loading) return PaperRenderer._loading;

        PaperRenderer._loading = (async () => {
            const pathPrefixes = [
                '/AutoGenerated/',          // Absolute path (for live site)
                'AutoGenerated/',
                './AutoGenerated/',
                '../AutoGenerated/',
                '../../AutoGenerated/'
            ];

            // Strategy 1: Try theory_output.json (full unified file)
            for (const prefix of pathPrefixes) {
                try {
                    const path = prefix + 'theory_output.json';
                    const response = await fetch(path);
                    if (response.ok) {
                        PaperRenderer._data = await response.json();
                        PaperRenderer._loaded = true;
                        PaperRenderer._basePath = prefix;
                        console.log(`PMPaperRenderer: Loaded theory_output.json from ${path}`);
                        return true;
                    }
                } catch (e) {
                    if (PaperRenderer._debug) {
                        console.debug(`PMPaperRenderer: Failed to load from ${prefix}theory_output.json`);
                    }
                }
            }

            // Strategy 2: Try loading split component files
            for (const prefix of pathPrefixes) {
                try {
                    const sectionsPath = prefix + 'sections.json';
                    const sectionsResponse = await fetch(sectionsPath);
                    if (sectionsResponse.ok) {
                        const sectionsData = await sectionsResponse.json();
                        PaperRenderer._data = {
                            sections: sectionsData.sections || sectionsData,
                            formulas: {},
                            parameters: {}
                        };

                        // Try to load formulas and parameters too
                        try {
                            const formulasResponse = await fetch(prefix + 'formulas.json');
                            if (formulasResponse.ok) {
                                const formulasData = await formulasResponse.json();
                                PaperRenderer._data.formulas = formulasData.formulas || formulasData;
                            }
                        } catch (e) { /* Optional */ }

                        try {
                            const paramsResponse = await fetch(prefix + 'parameters.json');
                            if (paramsResponse.ok) {
                                const paramsData = await paramsResponse.json();
                                PaperRenderer._data.parameters = paramsData.parameters || paramsData;
                            }
                        } catch (e) { /* Optional */ }

                        PaperRenderer._loaded = true;
                        PaperRenderer._basePath = prefix;
                        console.log(`PMPaperRenderer: Loaded from split files at ${prefix}`);
                        return true;
                    }
                } catch (e) {
                    if (PaperRenderer._debug) {
                        console.debug(`PMPaperRenderer: Failed to load split files from ${prefix}`);
                    }
                }
            }

            console.error('PMPaperRenderer: Could not load data files');
            return false;
        })();

        return PaperRenderer._loading;
    }

    /**
     * Load a single section from individual file (lazy loading)
     * @private
     */
    async function loadIndividualSection(sectionId) {
        const prefix = PaperRenderer._basePath || '/AutoGenerated/';
        const isAppendix = /^[A-N]$/.test(sectionId);
        const fileName = isAppendix ? `appendix-${sectionId}.json` : `section-${sectionId}.json`;
        const path = `${prefix}sections/${fileName}`;

        try {
            const response = await fetch(path);
            if (response.ok) {
                const section = await response.json();
                // Cache the loaded section
                if (!PaperRenderer._data.sections) {
                    PaperRenderer._data.sections = {};
                }
                PaperRenderer._data.sections[sectionId] = section;
                console.log(`PMPaperRenderer: Lazy loaded section ${sectionId} from ${path}`);
                return section;
            }
        } catch (e) {
            if (PaperRenderer._debug) {
                console.debug(`PMPaperRenderer: Failed to load ${path}`);
            }
        }
        return null;
    }

    // ========================================================================
    // COMPONENT RENDERERS
    // ========================================================================

    /**
     * Render paper title and metadata
     * @private
     */
    function renderTitle(container, metadata) {
        const titleSection = document.createElement('div');
        titleSection.className = 'paper-title-section';
        titleSection.innerHTML = `
            <h1 class="paper-title">${metadata.title || 'Principia Metaphysica'}</h1>
            ${metadata.subtitle ? `<h2 class="paper-subtitle">${metadata.subtitle}</h2>` : ''}
            ${metadata.author ? `<div class="paper-author">${metadata.author}</div>` : ''}
            ${metadata.date ? `<div class="paper-date">${metadata.date}</div>` : ''}
            ${metadata.version ? `<div class="paper-version">Version ${metadata.version}</div>` : ''}
        `;
        container.appendChild(titleSection);
    }

    /**
     * Render abstract section
     * @private
     */
    function renderAbstractSection(container, abstractText) {
        const abstractDiv = document.createElement('div');
        abstractDiv.className = 'paper-abstract';
        abstractDiv.innerHTML = `
            <h2>Abstract</h2>
            <p>${abstractText}</p>
        `;
        container.appendChild(abstractDiv);
    }

    /**
     * Render table of contents
     * @private
     */
    function renderTableOfContents(container, sections) {
        if (!sections || Object.keys(sections).length === 0) return;

        const tocDiv = document.createElement('div');
        tocDiv.className = 'paper-toc';
        tocDiv.innerHTML = '<h2>Table of Contents</h2>';

        // Create two-column grid for main sections and appendices
        const tocGrid = document.createElement('div');
        tocGrid.className = 'toc-grid';

        // Split sections into main sections (numeric) and appendices (letters)
        const mainSections = [];
        const appendices = [];

        for (const section of Object.values(sections)) {
            const isAppendix = /^[A-Z]$/.test(section.id) || section.type === 'appendix' ||
                              (section.title && section.title.startsWith('Appendix'));
            if (isAppendix) {
                appendices.push(section);
            } else {
                mainSections.push(section);
            }
        }

        // Sort main sections by order or numeric ID
        mainSections.sort((a, b) => {
            const orderA = a.order || parseInt(a.id) || 0;
            const orderB = b.order || parseInt(b.id) || 0;
            return orderA - orderB;
        });

        // Sort appendices by letter ID
        appendices.sort((a, b) => {
            // Extract letter from ID or title
            const getAppendixLetter = (sec) => {
                if (/^[A-Z]$/.test(sec.id)) return sec.id;
                const match = sec.title?.match(/Appendix ([A-Z])/);
                return match ? match[1] : 'Z';
            };
            return getAppendixLetter(a).localeCompare(getAppendixLetter(b));
        });

        // Render main sections column
        const mainColumn = document.createElement('div');
        mainColumn.className = 'toc-column';
        mainColumn.innerHTML = '<div class="toc-column-header">Main Sections</div>';

        const mainList = document.createElement('ol');
        mainList.className = 'toc-list';

        for (const section of mainSections) {
            const li = document.createElement('li');
            li.innerHTML = `
                <a href="#section-${section.id}" class="toc-link">
                    <span class="toc-number">${section.id}</span>
                    <span class="toc-title">${section.title}</span>
                </a>
            `;
            mainList.appendChild(li);

            // Subsections (if any)
            if (section.subsections && section.subsections.length > 0) {
                const subList = document.createElement('ol');
                subList.className = 'toc-sublist';
                for (const subsection of section.subsections) {
                    const subLi = document.createElement('li');
                    subLi.innerHTML = `
                        <a href="#section-${subsection.id}" class="toc-link">
                            <span class="toc-number">${subsection.id}</span>
                            <span class="toc-title">${subsection.title}</span>
                        </a>
                    `;
                    subList.appendChild(subLi);
                }
                li.appendChild(subList);
            }
        }

        mainColumn.appendChild(mainList);
        tocGrid.appendChild(mainColumn);

        // Render appendices column (if any)
        if (appendices.length > 0) {
            const appendixColumn = document.createElement('div');
            appendixColumn.className = 'toc-column';
            appendixColumn.innerHTML = '<div class="toc-column-header">Appendices</div>';

            const appendixList = document.createElement('ul');
            appendixList.className = 'toc-list toc-appendices';

            for (const appendix of appendices) {
                const li = document.createElement('li');
                const appendixId = appendix.id;
                li.innerHTML = `
                    <a href="#section-${appendixId}" class="toc-link">
                        <span class="toc-title">${appendix.title}</span>
                    </a>
                `;
                appendixList.appendChild(li);
            }

            appendixColumn.appendChild(appendixList);
            tocGrid.appendChild(appendixColumn);
        }

        tocDiv.appendChild(tocGrid);
        container.appendChild(tocDiv);
    }

    /**
     * Render all sections
     * @private
     */
    async function renderAllSections(container, sections, options) {
        if (!sections || Object.keys(sections).length === 0) return;

        const sectionsDiv = document.createElement('div');
        sectionsDiv.className = 'paper-sections';

        // Sort sections: main sections first (by order/ID), then appendices (alphabetically)
        const sortedSections = Object.values(sections).sort((a, b) => {
            const isAppendixA = /^[A-Z]$/.test(a.id) || a.type === 'appendix' ||
                               (a.title && a.title.startsWith('Appendix'));
            const isAppendixB = /^[A-Z]$/.test(b.id) || b.type === 'appendix' ||
                               (b.title && b.title.startsWith('Appendix'));

            // Main sections come before appendices
            if (!isAppendixA && isAppendixB) return -1;
            if (isAppendixA && !isAppendixB) return 1;

            // Both are appendices - sort by letter
            if (isAppendixA && isAppendixB) {
                const getAppendixLetter = (sec) => {
                    if (/^[A-Z]$/.test(sec.id)) return sec.id;
                    const match = sec.title?.match(/Appendix ([A-Z])/);
                    return match ? match[1] : 'Z';
                };
                return getAppendixLetter(a).localeCompare(getAppendixLetter(b));
            }

            // Both are main sections - sort by order or numeric ID
            const orderA = a.order || parseInt(a.id) || 0;
            const orderB = b.order || parseInt(b.id) || 0;
            return orderA - orderB;
        });

        // Track if we've rendered the appendix nav yet
        let appendixNavRendered = false;

        for (const section of sortedSections) {
            // Insert appendix navigation before first appendix
            const isAppendix = /^[A-Z]$/.test(section.id) || section.type === 'appendix' ||
                              (section.title && section.title.startsWith('Appendix'));

            if (isAppendix && !appendixNavRendered) {
                const appendixNav = renderAppendixNavigation(sortedSections);
                if (appendixNav) {
                    sectionsDiv.appendChild(appendixNav);
                }
                appendixNavRendered = true;
            }

            const sectionEl = await renderSection(section, options);
            if (sectionEl) {
                sectionsDiv.appendChild(sectionEl);
            }
        }

        container.appendChild(sectionsDiv);
    }

    /**
     * Render appendix navigation component
     * @private
     */
    function renderAppendixNavigation(allSections) {
        const appendices = allSections.filter(s =>
            /^[A-Z]$/.test(s.id) || s.type === 'appendix' ||
            (s.title && s.title.startsWith('Appendix'))
        );

        if (appendices.length === 0) return null;

        const navDiv = document.createElement('div');
        navDiv.className = 'appendix-nav';
        navDiv.id = 'appendix-navigation';

        const title = document.createElement('h3');
        title.textContent = `Appendices (${appendices.length})`;
        navDiv.appendChild(title);

        const grid = document.createElement('div');
        grid.className = 'appendix-nav-grid';

        for (const appendix of appendices) {
            const link = document.createElement('a');
            link.href = `#section-${appendix.id}`;
            link.className = 'appendix-nav-link';
            link.textContent = appendix.title;
            grid.appendChild(link);
        }

        navDiv.appendChild(grid);

        // Back to top link
        const backLink = document.createElement('a');
        backLink.href = '#';
        backLink.className = 'back-to-top';
        backLink.textContent = 'Back to Top';
        navDiv.appendChild(backLink);

        return navDiv;
    }

    /**
     * Render a single section with subsections
     * @param {Object} section - Section data from theory_output.json
     * @param {Object} options - Rendering options
     * @returns {Promise<HTMLElement>} - Rendered section element
     */
    async function renderSection(section, options = {}) {
        const { loadFormulas = true, loadParameters = true, useJsonContent = true } = options;

        // Handle both flat structure and metadata/content wrapper
        const sectionId = section.metadata?.id || section.id;
        const sectionTitle = section.metadata?.title || section.title;
        const sectionAbstract = section.metadata?.abstract || section.abstract;
        const subsections = section.content?.subsections || section.subsections || [];
        const contentBlocks = section.contentBlocks || section.content_blocks || [];

        const sectionDiv = document.createElement('section');
        sectionDiv.id = `section-${sectionId}`;
        sectionDiv.className = 'paper-section';
        sectionDiv.setAttribute('data-section-id', sectionId);

        // Add appendix class and alias for letter-based section IDs (e.g., B -> appendix-b)
        const isAppendix = /^[A-Z]$/.test(sectionId) || section.type === 'appendix' ||
                          (sectionTitle && sectionTitle.startsWith('Appendix'));
        if (isAppendix) {
            sectionDiv.classList.add('appendix-section');
        }

        if (/^[A-Za-z]$/.test(sectionId)) {
            const appendixAlias = document.createElement('a');
            appendixAlias.id = `appendix-${sectionId.toLowerCase()}`;
            appendixAlias.className = 'appendix-anchor';
            sectionDiv.insertBefore(appendixAlias, sectionDiv.firstChild);
        }

        // Section header
        const header = document.createElement('div');
        header.className = 'section-header';
        header.innerHTML = `
            <h2 class="section-title">
                <span class="section-number">${sectionId}</span>
                ${sectionTitle}
            </h2>
        `;
        sectionDiv.appendChild(header);

        // Section abstract (if available)
        if (sectionAbstract) {
            const abstractDiv = document.createElement('div');
            abstractDiv.className = 'section-abstract';
            abstractDiv.innerHTML = `<p>${sectionAbstract}</p>`;
            sectionDiv.appendChild(abstractDiv);
        }

        // Render subsections from JSON
        if (useJsonContent && subsections.length > 0) {
            const subsectionsDiv = document.createElement('div');
            subsectionsDiv.className = 'section-subsections';

            for (const subsection of subsections) {
                const subDiv = renderSubsection(subsection);
                subsectionsDiv.appendChild(subDiv);
            }

            sectionDiv.appendChild(subsectionsDiv);

            // Process formulas, parameters, and equation references
            if (loadFormulas) {
                processFormulas(subsectionsDiv);
            }
            if (loadParameters) {
                processParameters(subsectionsDiv);
            }
            // Always process equation cross-references in paper mode
            processEquationReferences(subsectionsDiv);
        }
        // Fallback: Try to load section HTML file if no JSON content
        else if (section.sectionFile) {
            const content = await loadSectionFile(section.sectionFile);
            if (content) {
                const contentDiv = document.createElement('div');
                contentDiv.className = 'section-content';
                contentDiv.innerHTML = content;
                sectionDiv.appendChild(contentDiv);

                if (loadFormulas) {
                    processFormulas(contentDiv);
                }
                if (loadParameters) {
                    processParameters(contentDiv);
                }
                processEquationReferences(contentDiv);
            } else {
                // No HTML file found - show placeholder
                if (PaperRenderer._debug) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'empty-section-placeholder';
                    placeholder.style.cssText = 'padding: 1rem; color: rgba(255,255,255,0.4); font-style: italic; background: rgba(255,255,255,0.02); border-radius: 4px; margin: 1rem 0;';
                    placeholder.textContent = `[Section content for "${sectionTitle}" is being developed - referenced file: ${section.sectionFile}]`;
                    sectionDiv.appendChild(placeholder);
                }
            }
        }
        // No subsections and no section file - completely empty
        else if (subsections.length === 0 && contentBlocks.length === 0) {
            if (PaperRenderer._debug) {
                const placeholder = document.createElement('div');
                placeholder.className = 'empty-section-placeholder';
                placeholder.style.cssText = 'padding: 1rem; color: rgba(255,255,255,0.4); font-style: italic; background: rgba(255,255,255,0.02); border-radius: 4px; margin: 1rem 0;';
                placeholder.textContent = `[Content for this section is being developed]`;
                sectionDiv.appendChild(placeholder);
            }
        }

        // Render top-level content blocks (if any)
        if (contentBlocks.length > 0) {
            const blocksDiv = renderContentBlocks(contentBlocks);
            sectionDiv.appendChild(blocksDiv);
        }

        // Key takeaways (if available)
        if (section.keyTakeaways && section.keyTakeaways.length > 0) {
            const takeawaysDiv = document.createElement('div');
            takeawaysDiv.className = 'section-takeaways';
            takeawaysDiv.innerHTML = `
                <h3>Key Takeaways</h3>
                <ul>
                    ${section.keyTakeaways.map(item => `<li>${item}</li>`).join('')}
                </ul>
            `;
            sectionDiv.appendChild(takeawaysDiv);
        }

        return sectionDiv;
    }

    /**
     * Render a subsection with its content blocks
     * @private
     */
    function renderSubsection(subsection) {
        const subDiv = document.createElement('div');
        subDiv.className = 'paper-subsection';
        subDiv.id = `subsection-${subsection.id || subsection.number || 'unknown'}`;

        // Subsection header
        const header = document.createElement('h3');
        header.className = 'subsection-title';
        header.innerHTML = `
            <span class="subsection-number">${subsection.number || ''}</span>
            ${subsection.title}
        `;
        subDiv.appendChild(header);

        // Render content blocks (support camelCase, snake_case, and plain content)
        let blocks = subsection.contentBlocks || subsection.content_blocks || subsection.content || [];

        // Handle string content (convert to single paragraph block)
        if (typeof blocks === 'string') {
            blocks = [{ type: 'paragraph', text: blocks }];
        }

        if (Array.isArray(blocks) && blocks.length > 0) {
            for (const block of blocks) {
                const blockEl = renderContentBlock(block);
                if (blockEl) {
                    subDiv.appendChild(blockEl);
                }
            }
        } else if (!Array.isArray(blocks) && blocks) {
            // Object content - treat as single block
            const blockEl = renderContentBlock(blocks);
            if (blockEl) {
                subDiv.appendChild(blockEl);
            }
        } else {
            // Empty subsection - add placeholder message
            if (PaperRenderer._debug) {
                const placeholder = document.createElement('p');
                placeholder.className = 'empty-subsection-placeholder';
                placeholder.style.cssText = 'color: rgba(255,255,255,0.3); font-style: italic; padding: 0.5rem;';
                placeholder.textContent = '[Content for this subsection is being developed]';
                subDiv.appendChild(placeholder);
            }
        }

        // Handle nested subsections
        if (subsection.subsections && subsection.subsections.length > 0) {
            for (const nested of subsection.subsections) {
                const nestedDiv = renderSubsection(nested);
                subDiv.appendChild(nestedDiv);
            }
        }

        return subDiv;
    }

    /**
     * Load section HTML file
     * @private
     */
    async function loadSectionFile(filePath) {
        // Check cache first
        if (PaperRenderer._sectionsCache.has(filePath)) {
            return PaperRenderer._sectionsCache.get(filePath);
        }

        const pathPrefixes = ['', '../', '../../'];

        for (const prefix of pathPrefixes) {
            try {
                const fullPath = prefix + filePath;
                const response = await fetch(fullPath);
                if (response.ok) {
                    const html = await response.text();

                    // Extract content from the <body> tag
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const body = doc.querySelector('body');

                    if (body) {
                        const content = body.innerHTML;
                        PaperRenderer._sectionsCache.set(filePath, content);
                        return content;
                    }
                }
            } catch (e) {
                if (PaperRenderer._debug) {
                    console.debug(`PMPaperRenderer: Failed to load ${filePath} from ${prefix}`);
                }
            }
        }

        console.warn(`PMPaperRenderer: Could not load section file: ${filePath}`);
        return null;
    }

    /**
     * Render content blocks
     * @private
     */
    function renderContentBlocks(blocks) {
        const container = document.createElement('div');
        container.className = 'content-blocks';

        for (const block of blocks) {
            const blockEl = renderContentBlock(block);
            if (blockEl) {
                container.appendChild(blockEl);
            }
        }

        return container;
    }

    /**
     * Render a single content block
     * @private
     */
    function renderContentBlock(block) {
        // Helper function to safely convert values to strings
        const safeStringify = (value, fieldName = 'content') => {
            if (value === null || value === undefined) return '';
            if (typeof value === 'object') {
                console.warn(`PMPaperRenderer: Found object in ${fieldName} field of ${block.type} block, converting to JSON:`, value);
                return JSON.stringify(value);
            }
            return String(value);
        };

        const blockDiv = document.createElement('div');
        blockDiv.className = `content-block content-block-${block.type}`;

        switch (block.type) {
            case 'paragraph':
            case 'text':
                blockDiv.innerHTML = `<p>${safeStringify(block.content || block.text, 'text/content')}</p>`;
                break;

            case 'heading':
                const level = block.level || 3;
                blockDiv.innerHTML = `<h${level}>${safeStringify(block.content, 'heading.content')}</h${level}>`;
                break;

            case 'formula':
            case 'equation':
                // Render equation in academic paper style
                const formulaHtml = renderEquation(block);
                if (formulaHtml) {
                    blockDiv.innerHTML = formulaHtml;
                } else {
                    // Fallback for simple formula blocks
                    blockDiv.innerHTML = `
                        <div class="formula-block" data-formula-id="${block.formulaId || block.id || block.label}">
                            ${block.latex ? `$$${block.latex}$$` : (block.content || '')}
                        </div>
                    `;
                }
                break;

            case 'list':
                const listType = block.ordered ? 'ol' : 'ul';
                const listItems = (block.items || []).map((item, idx) =>
                    `<li>${safeStringify(item, `list.items[${idx}]`)}</li>`
                ).join('');
                blockDiv.innerHTML = `<${listType}>${listItems}</${listType}>`;
                break;

            case 'code':
                const lang = block.language ? ` class="language-${block.language}"` : '';
                blockDiv.innerHTML = `<pre><code${lang}>${escapeHtml(block.content || '')}</code></pre>`;
                break;

            case 'quote':
            case 'blockquote':
                blockDiv.innerHTML = `<blockquote>${safeStringify(block.content, 'quote.content')}</blockquote>`;
                break;

            case 'table':
                blockDiv.innerHTML = renderTable(block);
                break;

            case 'note':
                // Academic note/aside
                blockDiv.className = 'academic-note';
                blockDiv.innerHTML = `<div class="note-content">${block.content || ''}</div>`;
                blockDiv.setAttribute('role', 'note');
                break;

            case 'highlight_box':
                // Highlighted information box
                blockDiv.className = 'highlight-box';
                blockDiv.innerHTML = `
                    ${block.title ? `<div class="highlight-title">${block.title}</div>` : ''}
                    <div class="highlight-content">${block.content || ''}</div>
                `;
                blockDiv.setAttribute('role', 'complementary');
                break;

            case 'definition':
                // Mathematical definition block
                blockDiv.className = 'definition-block';
                blockDiv.innerHTML = `
                    ${block.term ? `<div class="definition-term"><strong>Definition:</strong> ${block.term}</div>` : ''}
                    <div class="definition-content">${block.content || ''}</div>
                `;
                blockDiv.setAttribute('role', 'definition');
                break;

            case 'theorem':
                // Theorem block
                blockDiv.className = 'theorem-block';
                blockDiv.innerHTML = `
                    <div class="theorem-header">
                        <span class="theorem-label">${block.label || 'Theorem'}</span>
                        ${block.title ? `<span class="theorem-title">${block.title}</span>` : ''}
                    </div>
                    <div class="theorem-content">${block.content || ''}</div>
                `;
                blockDiv.setAttribute('role', 'article');
                break;

            case 'proof':
                // Proof block
                blockDiv.className = 'proof-block';
                blockDiv.innerHTML = `
                    <div class="proof-header">Proof.</div>
                    <div class="proof-content">${block.content || ''}</div>
                    <div class="proof-end">‚àé</div>
                `;
                blockDiv.setAttribute('role', 'article');
                break;

            case 'remark':
                // Remark/observation block
                blockDiv.className = 'remark-block';
                blockDiv.innerHTML = `
                    <div class="remark-header">${block.title || 'Remark'}</div>
                    <div class="remark-content">${block.content || ''}</div>
                `;
                blockDiv.setAttribute('role', 'note');
                break;

            case 'example':
                // Worked example block
                blockDiv.className = 'example-block';
                blockDiv.innerHTML = `
                    <div class="example-header">${block.title || 'Example'}</div>
                    <div class="example-content">${block.content || ''}</div>
                `;
                blockDiv.setAttribute('role', 'article');
                break;

            case 'derivation':
            case 'derivation_box':
                blockDiv.className = 'derivation-box';
                blockDiv.innerHTML = `
                    <div class="derivation-title">${block.title || 'Derivation'}</div>
                    <div class="derivation-content">${block.content || ''}</div>
                `;
                break;

            case 'callout':
            case 'info_box':
            case 'highlight':
                const calloutType = block.calloutType || block.variant || 'info';
                blockDiv.className = `callout callout-${calloutType}`;
                blockDiv.innerHTML = `
                    ${block.title ? `<div class="callout-title">${block.title}</div>` : ''}
                    <div class="callout-content">${block.content || ''}</div>
                `;
                break;

            case 'subsection':
                // Nested subsection - recursively render
                if (block.subsection) {
                    return renderSubsection(block.subsection);
                }
                blockDiv.innerHTML = safeStringify(block.content, 'subsection.content');
                break;

            case 'note':
                // Note blocks are similar to callouts but with a subtle style
                blockDiv.className = 'callout callout-note note-block';
                blockDiv.innerHTML = `
                    ${block.title ? `<div class="callout-title">${block.title}</div>` : ''}
                    <div class="callout-content">${safeStringify(block.content, 'note.content')}</div>
                `;
                break;

            case 'highlight_box':
                // Highlight boxes are emphasized callouts
                blockDiv.className = 'callout callout-highlight';
                blockDiv.innerHTML = `
                    ${block.title ? `<div class="callout-title">${block.title}</div>` : ''}
                    <div class="callout-content">${safeStringify(block.content, 'highlight.content')}</div>
                `;
                break;

            default:
                // Handle unknown types gracefully - ensure content is a string
                blockDiv.innerHTML = safeStringify(block.content || block.text, 'unknown.content');
                console.warn(`PMPaperRenderer: Unknown block type: ${block.type}`);
        }

        return blockDiv;
    }

    /**
     * Render a table from block data
     * @private
     */
    function renderTable(block) {
        const headers = block.headers || [];
        const rows = block.rows || [];

        // Helper to safely stringify table values
        const safeTableValue = (value, type, index) => {
            if (value === null || value === undefined) return '';
            if (typeof value === 'object') {
                console.warn(`PMPaperRenderer: Found object in table ${type}[${index}], converting to JSON:`, value);
                return JSON.stringify(value);
            }
            return String(value);
        };

        let html = '<table class="pm-table">';

        if (headers.length > 0) {
            html += '<thead><tr>';
            headers.forEach((header, idx) => {
                html += `<th>${safeTableValue(header, 'header', idx)}</th>`;
            });
            html += '</tr></thead>';
        }

        if (rows.length > 0) {
            html += '<tbody>';
            rows.forEach((row, rowIdx) => {
                html += '<tr>';
                row.forEach((cell, cellIdx) => {
                    html += `<td>${safeTableValue(cell, `row[${rowIdx}].cell`, cellIdx)}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody>';
        }

        html += '</table>';
        return html;
    }

    // ========================================================================
    // FORMULA AND PARAMETER PROCESSING
    // ========================================================================

    /**
     * Render an equation in academic paper style with complete metadata
     * @param {Object} block - Formula/equation content block
     * @returns {string|null} - HTML string for academic-style equation
     * @private
     */
    function renderEquation(block) {
        // Get formula ID from various possible fields
        const formulaId = block.formulaId || block.id || block.label;
        if (!formulaId) return null;

        // Try to get full formula metadata from global data
        let formulaData = null;
        if (PaperRenderer._data?.formulas?.formulas) {
            formulaData = PaperRenderer._data.formulas.formulas[formulaId];
        }

        // Extract equation number from label (e.g., "(4.2)" from label or formulaData)
        const label = block.label || formulaData?.label || '';
        const equationNumber = extractEquationNumber(label);

        // Get LaTeX code
        let latex = block.latex || formulaData?.latex || '';
        const plainText = block.plain_text || formulaData?.plain_text || '';

        // Build the equation HTML with anchor ID and hover tooltip
        const anchorId = equationNumber ? `eq-${equationNumber}` : `eq-${formulaId}`;

        // Create tooltip text from description or formula metadata
        let tooltipText = '';
        if (formulaData?.description || block.description) {
            tooltipText = (formulaData?.description || block.description).replace(/"/g, '&quot;');
        } else if (formulaData?.label) {
            tooltipText = formulaData.label.replace(/"/g, '&quot;');
        } else if (label) {
            tooltipText = label.replace(/"/g, '&quot;');
        }

        const titleAttr = tooltipText ? ` title="${tooltipText}"` : '';
        let html = `<div class="equation-wrapper academic-equation" id="${anchorId}" data-formula-id="${formulaId}"${titleAttr}>`;

        // Main equation with number
        html += '<div class="equation-line">';
        html += `<div class="equation-content">$$${latex}$$</div>`;
        if (equationNumber) {
            html += `<div class="equation-number">(${equationNumber})</div>`;
        }
        html += '</div>';

        // Plain text fallback (for accessibility and copying)
        if (plainText) {
            html += `<div class="equation-plaintext" title="Plain text representation">${escapeHtml(plainText)}</div>`;
        }

        // Parameter definitions (from terms)
        if (formulaData?.terms && Object.keys(formulaData.terms).length > 0) {
            html += '<div class="equation-terms">';
            const termsList = renderTermsDefinition(formulaData.terms);
            if (termsList) {
                html += `<div class="terms-intro">where ${termsList}</div>`;
            }
            html += '</div>';
        }

        // Discussion/description
        if (formulaData?.description || block.description) {
            const description = formulaData?.description || block.description;
            html += `<div class="equation-discussion"><p>${description}</p></div>`;
        }

        // Expandable metadata panel
        const hasMetadata = formulaData && (
            (formulaData.input_params && formulaData.input_params.length > 0) ||
            (formulaData.output_params && formulaData.output_params.length > 0) ||
            (formulaData.derivation && (formulaData.derivation.steps || formulaData.derivation.references)) ||
            formulaData.category ||
            formulaData.notes ||
            (formulaData.experimental_value !== undefined) ||
            (formulaData.computed_value !== undefined)
        );

        if (hasMetadata) {
            html += '<div class="equation-metadata-panel">';
            html += '<button class="metadata-toggle" onclick="this.parentElement.classList.toggle(\'expanded\');">';
            html += '<span class="toggle-icon">‚ñ∏</span>';
            html += '<span class="toggle-text">Show formula metadata and derivation</span>';
            html += '</button>';
            html += '<div class="metadata-content">';

            // Input/Output Parameters
            if (formulaData.input_params && formulaData.input_params.length > 0) {
                html += '<div class="metadata-section metadata-inputs">';
                html += '<h5 class="metadata-section-title">üì• Input Parameters</h5>';
                html += '<ul class="param-list">';
                for (const param of formulaData.input_params) {
                    html += `<li class="param-item"><code class="param-link" data-param="${param}">${param}</code></li>`;
                }
                html += '</ul></div>';
            }

            if (formulaData.output_params && formulaData.output_params.length > 0) {
                html += '<div class="metadata-section metadata-outputs">';
                html += '<h5 class="metadata-section-title">üì§ Output Parameters</h5>';
                html += '<ul class="param-list">';
                for (const param of formulaData.output_params) {
                    html += `<li class="param-item"><code class="param-link" data-param="${param}">${param}</code></li>`;
                }
                html += '</ul></div>';
            }

            // Derivation steps
            if (formulaData.derivation?.steps && formulaData.derivation.steps.length > 0) {
                html += '<div class="metadata-section metadata-derivation">';
                html += '<h5 class="metadata-section-title">üî¨ Derivation</h5>';
                html += '<ol class="derivation-steps">';
                for (const step of formulaData.derivation.steps) {
                    html += `<li class="derivation-step">${step}</li>`;
                }
                html += '</ol></div>';
            }

            // References
            if (formulaData.derivation?.references && formulaData.derivation.references.length > 0) {
                html += '<div class="metadata-section metadata-references">';
                html += '<h5 class="metadata-section-title">üìö References</h5>';
                html += '<ul class="reference-list">';
                for (const ref of formulaData.derivation.references) {
                    html += `<li class="reference-item">${ref}</li>`;
                }
                html += '</ul></div>';
            }

            // Category and status
            if (formulaData.category) {
                html += '<div class="metadata-section metadata-category">';
                html += '<h5 class="metadata-section-title">üìä Category</h5>';
                const categoryBadge = getCategoryBadge(formulaData.category);
                html += `<div class="category-badge">${categoryBadge}</div>`;
                html += '</div>';
            }

            // Experimental vs Computed values
            if (formulaData.experimental_value !== undefined || formulaData.computed_value !== undefined) {
                html += '<div class="metadata-section metadata-values">';
                html += '<h5 class="metadata-section-title">üéØ Values</h5>';
                html += '<div class="value-comparison">';

                if (formulaData.computed_value !== undefined) {
                    html += `<div class="value-item value-computed">`;
                    html += `<span class="value-label">Theory:</span> `;
                    html += `<span class="value-number">${formatScientificValue(formulaData.computed_value)}</span>`;
                    if (formulaData.units) {
                        html += ` <span class="value-units">${formulaData.units}</span>`;
                    }
                    html += `</div>`;
                }

                if (formulaData.experimental_value !== undefined) {
                    html += `<div class="value-item value-experimental">`;
                    html += `<span class="value-label">Experiment:</span> `;
                    html += `<span class="value-number">${formatScientificValue(formulaData.experimental_value)}</span>`;
                    if (formulaData.units) {
                        html += ` <span class="value-units">${formulaData.units}</span>`;
                    }
                    html += `</div>`;
                }

                if (formulaData.sigma_deviation !== undefined) {
                    const sigma = formulaData.sigma_deviation;
                    const sigmaClass = Math.abs(sigma) < 1 ? 'excellent' : Math.abs(sigma) < 2 ? 'good' : 'fair';
                    html += `<div class="value-item value-deviation ${sigmaClass}">`;
                    html += `<span class="value-label">Deviation:</span> `;
                    html += `<span class="value-number">${sigma.toFixed(2)}œÉ</span>`;
                    html += `</div>`;
                }

                html += '</div></div>';
            }

            // Notes
            if (formulaData.notes) {
                html += '<div class="metadata-section metadata-notes">';
                html += '<h5 class="metadata-section-title">üìù Notes</h5>';
                html += `<p class="metadata-notes-text">${formulaData.notes}</p>`;
                html += '</div>';
            }

            html += '</div>'; // metadata-content
            html += '</div>'; // equation-metadata-panel
        }

        html += '</div>'; // equation-wrapper
        return html;
    }

    /**
     * Extract equation number from label string
     * @param {string} label - Formula label like "(4.2) Three Generations", "(TT.1)", "Main Equation"
     * @returns {string|null} - Equation number like "4.2", "TT.1", or null
     * @private
     */
    function extractEquationNumber(label) {
        if (!label) return null;

        // Match patterns like "(4.2)" or "(Eq. 4.2)" at the start
        const match = label.match(/^\((?:Eq\.\s*)?([0-9]+\.[0-9]+)\)/);
        if (match) return match[1];

        // Match patterns like "4.2" or "Eq. 4.2"
        const simpleMatch = label.match(/^(?:Eq\.\s*)?([0-9]+\.[0-9]+)/);
        if (simpleMatch) return simpleMatch[1];

        // Match special section labels like "(TT.1)", "(TT.2)", etc.
        const specialMatch = label.match(/^\(([A-Z]+\.[0-9]+)\)/);
        if (specialMatch) return specialMatch[1];

        // Match special patterns without parens like "TT.1"
        const specialSimple = label.match(/^([A-Z]+\.[0-9]+)/);
        if (specialSimple) return specialSimple[1];

        // If label is just a descriptive name like "Main Equation", return it as-is
        // (This allows the equation to have a label even without a formal number)
        if (label && label.length > 0 && !label.match(/^[\s\(\)]+$/)) {
            return label;
        }

        return null;
    }

    /**
     * Render terms as inline definition list
     * @param {Object} terms - Terms object with parameter definitions
     * @returns {string} - Formatted "X is..., Y represents..." string
     * @private
     */
    function renderTermsDefinition(terms) {
        if (!terms || Object.keys(terms).length === 0) return '';

        const definitions = [];
        for (const [symbol, termData] of Object.entries(terms)) {
            const desc = termData.description || termData.name || '';
            if (desc) {
                // Format: "X is the description" or "X represents the description"
                const verb = definitions.length === 0 ? 'is' : 'is';
                const cleanDesc = desc.replace(/^(is|represents|denotes)\s+/i, '');
                definitions.push(`<i>${symbol}</i> ${verb} ${cleanDesc}`);
            }
        }

        return definitions.join(', ');
    }

    /**
     * Format a formula reference for citation
     * @param {Object} formula - Formula data object
     * @returns {string} - Formatted reference like "[Section 2.3, Eq. (2.7)]"
     * @private
     */
    function formatFormulaReference(formula) {
        const eqNum = extractEquationNumber(formula.label);
        const section = formula.section || '';

        if (eqNum && section) {
            return `[${section}, Eq. (${eqNum})]`;
        } else if (eqNum) {
            return `[Eq. (${eqNum})]`;
        } else if (section) {
            return `[${section}]`;
        } else {
            return `[${formula.label || formula.id}]`;
        }
    }

    /**
     * Process formulas in a container
     * Replaces inline formula references with proper data-formula-id elements
     * @private
     */
    function processFormulas(container) {
        // Find all elements with data-formula-id that are empty
        const formulaElements = container.querySelectorAll('[data-formula-id]');

        formulaElements.forEach(el => {
            const formulaId = el.getAttribute('data-formula-id');

            // Skip if already has content
            if (el.innerHTML.trim() && !el.classList.contains('pm-formula-auto')) {
                return;
            }

            // Try to get formula from PM
            if (window.PM && typeof window.PM.formula === 'function') {
                const formula = window.PM.formula(formulaId);
                if (formula) {
                    el.innerHTML = formula.html || formula.latex || formula.plainText || '';
                    el.classList.add('pm-formula-loaded');

                    // Add tooltip with description
                    if (formula.description) {
                        el.setAttribute('title', formula.description);
                    }
                }
            }
        });
    }

    /**
     * Process equation cross-references in text
     * Converts "Eq. (4.2)" to clickable links with hover tooltips
     * @param {HTMLElement} container - Container to process
     * @private
     */
    function processEquationReferences(container) {
        // Find all text nodes
        const walker = document.createTreeWalker(
            container,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );

        const textNodes = [];
        let node;
        while (node = walker.nextNode()) {
            // Skip if parent is script, style, or already a link
            const parent = node.parentElement;
            if (parent && !['SCRIPT', 'STYLE', 'A', 'CODE', 'PRE'].includes(parent.tagName)) {
                textNodes.push(node);
            }
        }

        // Process each text node
        for (const textNode of textNodes) {
            const text = textNode.textContent;

            // Match patterns like "Eq. (4.2)", "equation (4.2)", "(4.2)"
            const pattern = /\b(?:Eq\.|equation)\s*\(([0-9]+\.[0-9]+)\)|\(([0-9]+\.[0-9]+)\)/gi;

            if (pattern.test(text)) {
                // Create a temporary container to build the replacement HTML
                const tempDiv = document.createElement('div');
                let lastIndex = 0;
                let match;
                pattern.lastIndex = 0; // Reset regex

                while ((match = pattern.exec(text)) !== null) {
                    const eqNum = match[1] || match[2];
                    const fullMatch = match[0];

                    // Add text before match
                    if (match.index > lastIndex) {
                        tempDiv.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                    }

                    // Create link to equation with tooltip
                    const link = document.createElement('a');
                    link.href = `#eq-${eqNum}`;
                    link.className = 'equation-ref';
                    link.textContent = fullMatch;

                    // Add tooltip with formula preview
                    link.setAttribute('data-equation-ref', eqNum);
                    link.addEventListener('mouseenter', showEquationTooltip);
                    link.addEventListener('mouseleave', hideEquationTooltip);

                    tempDiv.appendChild(link);

                    lastIndex = match.index + fullMatch.length;
                }

                // Add remaining text
                if (lastIndex < text.length) {
                    tempDiv.appendChild(document.createTextNode(text.substring(lastIndex)));
                }

                // Replace the text node with the new content
                if (tempDiv.childNodes.length > 0) {
                    const parent = textNode.parentNode;
                    while (tempDiv.firstChild) {
                        parent.insertBefore(tempDiv.firstChild, textNode);
                    }
                    parent.removeChild(textNode);
                }
            }
        }
    }

    /**
     * Show equation tooltip on hover
     * @private
     */
    function showEquationTooltip(event) {
        const link = event.target;
        const eqNum = link.getAttribute('data-equation-ref');
        const targetEq = document.getElementById(`eq-${eqNum}`);

        if (!targetEq) return;

        // Find the formula data
        const formulaId = targetEq.getAttribute('data-formula-id');
        let formulaData = null;
        if (formulaId && PaperRenderer._data?.formulas?.formulas) {
            formulaData = PaperRenderer._data.formulas.formulas[formulaId];
        }

        // Create tooltip
        const tooltip = document.createElement('div');
        tooltip.className = 'equation-tooltip';
        tooltip.innerHTML = `
            <div class="tooltip-header">Equation ${eqNum}</div>
            ${formulaData ? `
                <div class="tooltip-latex">$$${formulaData.latex}$$</div>
                ${formulaData.description ? `<div class="tooltip-desc">${formulaData.description}</div>` : ''}
            ` : ''}
            <div class="tooltip-hint">Click to jump to equation</div>
        `;

        document.body.appendChild(tooltip);

        // Position tooltip
        const rect = link.getBoundingClientRect();
        tooltip.style.position = 'fixed';
        tooltip.style.left = rect.left + 'px';
        tooltip.style.top = (rect.bottom + 10) + 'px';

        // Typeset MathJax in tooltip
        if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
            MathJax.typesetPromise([tooltip]).catch(() => {});
        }

        // Store reference for cleanup
        link._tooltip = tooltip;
    }

    /**
     * Hide equation tooltip
     * @private
     */
    function hideEquationTooltip(event) {
        const link = event.target;
        if (link._tooltip) {
            link._tooltip.remove();
            delete link._tooltip;
        }
    }

    /**
     * Process parameters in a container
     * Replaces data-pm-value elements with actual values
     * @private
     */
    function processParameters(container) {
        // Process data-pm-value elements
        const pmValueElements = container.querySelectorAll('[data-pm-value]');

        pmValueElements.forEach(el => {
            const path = el.getAttribute('data-pm-value');
            const format = el.getAttribute('data-format');

            if (window.PM && typeof window.PM.get === 'function') {
                const value = window.PM.get(path);
                if (value !== null && value !== undefined) {
                    el.textContent = formatValue(value, format);
                    el.classList.add('pm-loaded');
                    el.classList.remove('pm-loading', 'pm-error');
                }
            }
        });

        // Process data-category + data-param elements
        const categoryElements = container.querySelectorAll('[data-category][data-param]');

        categoryElements.forEach(el => {
            const category = el.getAttribute('data-category');
            const param = el.getAttribute('data-param');
            const format = el.getAttribute('data-format');

            if (window.PM && typeof window.PM.get === 'function') {
                // Try multiple paths
                const paths = [
                    `simulations.${param}`,
                    `simulations.${category}.${param}`,
                    `parameters.${category}.${param}`,
                    `${category}.${param}`
                ];

                for (const path of paths) {
                    let value = window.PM.get(path);

                    // Auto-extract .value property if present
                    if (value !== null && value !== undefined && typeof value === 'object' && 'value' in value) {
                        // Check for renderable_value first (for complex values like dicts/lists)
                        if ('renderable_value' in value) {
                            value = value.renderable_value;
                        } else {
                            value = value.value;
                        }
                    }

                    if (value !== null && value !== undefined) {
                        el.textContent = formatValue(value, format);
                        el.classList.add('pm-loaded');
                        el.classList.remove('pm-loading', 'pm-error');
                        break;
                    }
                }
            }
        });
    }

    /**
     * Render a formula by ID
     * @param {string} formulaId - Formula ID
     * @returns {string|null} - HTML/LaTeX string
     */
    function renderFormula(formulaId) {
        if (!window.PM || typeof window.PM.formula !== 'function') {
            console.error('PMPaperRenderer: PM.formula() not available');
            return null;
        }

        const formula = window.PM.formula(formulaId);
        if (!formula) {
            console.warn(`PMPaperRenderer: Formula not found: ${formulaId}`);
            return null;
        }

        return formula.html || formula.latex || formula.plainText || null;
    }

    // ========================================================================
    // UTILITY FUNCTIONS
    // ========================================================================

    /**
     * Format a value for display
     * @private
     */
    function formatValue(value, format) {
        if (value === null || value === undefined) return '?';

        if (typeof value === 'number') {
            if (format) {
                if (format.startsWith('scientific:')) {
                    const decimals = parseInt(format.split(':')[1]) || 2;
                    return value.toExponential(decimals);
                }
                if (format.startsWith('fixed:')) {
                    const decimals = parseInt(format.split(':')[1]) || 2;
                    return value.toFixed(decimals);
                }
                if (format === 'percent') {
                    return (value * 100).toFixed(1) + '%';
                }
                if (format === 'integer') {
                    return Math.round(value).toString();
                }
            }

            // Auto-format based on magnitude
            if (Math.abs(value) >= 1e10 || (Math.abs(value) < 0.001 && value !== 0)) {
                return value.toExponential(2);
            } else if (Number.isInteger(value)) {
                return value.toString();
            } else {
                return value.toFixed(3);
            }
        }

        if (typeof value === 'boolean') {
            return value ? 'Yes' : 'No';
        }

        return String(value);
    }

    /**
     * Escape HTML special characters
     * @private
     */
    function escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }

    /**
     * Format a scientific value with proper notation
     * @private
     */
    function formatScientificValue(value) {
        if (typeof value === 'number') {
            if (Math.abs(value) >= 1e4 || (Math.abs(value) < 0.001 && value !== 0)) {
                return value.toExponential(3);
            } else if (Number.isInteger(value)) {
                return value.toString();
            } else {
                return value.toFixed(4);
            }
        }
        return String(value);
    }

    /**
     * Get category badge HTML
     * @private
     */
    function getCategoryBadge(category) {
        const badges = {
            'ESTABLISHED': '<span class="badge badge-established">ESTABLISHED</span><p class="badge-desc">Well-established result from literature</p>',
            'THEORY': '<span class="badge badge-theory">THEORY</span><p class="badge-desc">Core theoretical prediction of Principia Metaphysica</p>',
            'DERIVED': '<span class="badge badge-derived">DERIVED</span><p class="badge-desc">Derived from fundamental principles</p>',
            'PREDICTION': '<span class="badge badge-prediction">PREDICTION</span><p class="badge-desc">Novel prediction to be tested</p>',
            'EXPERIMENTAL': '<span class="badge badge-experimental">EXPERIMENTAL</span><p class="badge-desc">Experimental measurement or constraint</p>'
        };
        return badges[category] || `<span class="badge badge-unknown">${category}</span>`;
    }

    /**
     * Trigger MathJax typesetting on a specific element
     * @param {HTMLElement} element - Element to typeset
     */
    function typesetMathJax(element) {
        if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
            MathJax.typesetPromise([element]).catch(err => {
                console.warn('PMPaperRenderer: MathJax typesetting failed:', err);
            });
        } else if (typeof MathJax !== 'undefined' && MathJax.Hub) {
            MathJax.Hub.Queue(['Typeset', MathJax.Hub, element]);
        }
    }

    // ========================================================================
    // PUBLIC API
    // ========================================================================

    const API = {
        renderPaper,
        renderSection,
        renderFormula,
        renderEquation,
        processFormulas,
        processParameters,
        processEquationReferences,
        typesetMathJax,
        get data() { return PaperRenderer._data; },
        get loaded() { return PaperRenderer._loaded; }
    };

    // Export globally
    window.PMPaperRenderer = API;

    // Export for ES modules
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = API;
    }

    console.log('PMPaperRenderer: Ready (v1.0.0)');

})();
