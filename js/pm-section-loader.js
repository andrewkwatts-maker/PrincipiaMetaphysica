/**
 * Principia Metaphysica - Section Loader (Dynamic)
 * =================================================
 *
 * Dynamically loads section content from:
 * 1. Section metadata from theory_output.json (structure, refs, metadata)
 * 2. Section HTML content from sections/*.html files
 * 3. Renders with formula/param references resolved
 *
 * Usage:
 *   // Load a single section
 *   const section = await PMSectionLoader.loadSection('1');
 *   PMSectionLoader.renderSection('section-container', section);
 *
 *   // Load all sections for full paper view
 *   const sections = await PMSectionLoader.loadAllSections();
 *   PMSectionLoader.renderAllSections('paper-container', sections);
 *
 *   // Render section content dynamically
 *   <div id="section-container" data-section-id="1"></div>
 *
 * Copyright (c) 2025 Andrew Keith Watts. All rights reserved.
 * Version: 1.0.0 - Initial section loading with formula/param resolution
 */

(function() {
    'use strict';

    // ========================================================================
    // SECTION LOADER CLASS
    // ========================================================================

    class PMSectionLoader {
        static _sections = null;
        static _loaded = false;
        static _loading = null;
        static _htmlCache = new Map();

        /**
         * Load section metadata from theory_output.json
         * @returns {Promise<boolean>} - True if loaded successfully
         */
        static async loadMetadata() {
            if (this._loaded) return true;
            if (this._loading) return this._loading;

            this._loading = (async () => {
                try {
                    const pathPrefixes = [
                        'AutoGenerated/',            // AutoGenerated folder (primary)
                        '',                          // Root directory (fallback)
                        '../AutoGenerated/',         // From subdirectory
                        '../',                       // Parent directory
                        '../../AutoGenerated/',      // From nested subdirectory
                        '../../',                    // Two levels up
                    ];

                    // Try to load theory_output.json for section metadata
                    for (const prefix of pathPrefixes) {
                        const testPath = prefix + 'theory_output.json';
                        try {
                            const response = await fetch(testPath);
                            if (response.ok) {
                                const data = await response.json();

                                if (data.sections) {
                                    this._sections = data.sections;
                                    this._loaded = true;

                                    console.log(`%cPMSectionLoader: Loaded section metadata`, 'color: green; font-weight: bold');
                                    console.log(`  Sections: ${Object.keys(this._sections).length}`);

                                    return true;
                                }
                            }
                        } catch (e) {
                            if (window.PM_DEBUG) {
                                console.debug(`  - Failed to load ${testPath}: ${e.message}`);
                            }
                            continue;
                        }
                    }

                    console.warn('%cPMSectionLoader: Section metadata not found in theory_output.json', 'color: orange');
                    // Continue without metadata - can still load HTML files
                    this._sections = {};
                    this._loaded = true;
                    return true;

                } catch (error) {
                    console.error('%cPMSectionLoader: Error loading metadata:', 'color: red; font-weight: bold', error);
                    return false;
                }
            })();

            return this._loading;
        }

        /**
         * Load a single section's HTML content
         * @param {string} sectionId - Section ID (e.g., "1", "2", "3")
         * @returns {Promise<Object>} - Section object with metadata and HTML content
         */
        static async loadSection(sectionId) {
            await this.loadMetadata();

            // Check cache first
            if (this._htmlCache.has(sectionId)) {
                return this._htmlCache.get(sectionId);
            }

            try {
                // Get metadata from theory_output.json
                const metadata = this._sections?.[sectionId] || {};

                // Determine HTML file path
                const htmlFileName = this._getSectionFileName(sectionId, metadata);
                const htmlPaths = [
                    `sections/${htmlFileName}`,
                    `../sections/${htmlFileName}`,
                    `../../sections/${htmlFileName}`,
                ];

                let htmlContent = null;
                let htmlPath = null;

                // Try to load HTML file
                for (const path of htmlPaths) {
                    try {
                        const response = await fetch(path);
                        if (response.ok) {
                            htmlContent = await response.text();
                            htmlPath = path;
                            break;
                        }
                    } catch (e) {
                        if (window.PM_DEBUG) {
                            console.debug(`  - Failed to load ${path}: ${e.message}`);
                        }
                        continue;
                    }
                }

                if (!htmlContent) {
                    console.warn(`PMSectionLoader: Could not load HTML for section ${sectionId}`);
                    return null;
                }

                // Extract content from HTML (remove <html>, <head>, etc.)
                const contentHTML = this._extractContentFromHTML(htmlContent);

                const section = {
                    id: sectionId,
                    metadata: metadata,
                    html: contentHTML,
                    rawHTML: htmlContent,
                    htmlPath: htmlPath,
                    title: metadata.title || this._extractTitle(htmlContent),
                    formulaRefs: metadata.formulaRefs || [],
                    paramRefs: metadata.paramRefs || [],
                    figureRefs: metadata.figureRefs || [],
                    citationRefs: metadata.citationRefs || [],
                };

                // Cache it
                this._htmlCache.set(sectionId, section);

                if (window.PM_DEBUG) {
                    console.log(`PMSectionLoader: Loaded section ${sectionId} from ${htmlPath}`);
                }

                return section;

            } catch (error) {
                console.error(`PMSectionLoader: Error loading section ${sectionId}:`, error);
                return null;
            }
        }

        /**
         * Load all sections
         * @returns {Promise<Array>} - Array of section objects
         */
        static async loadAllSections() {
            await this.loadMetadata();

            // Get all section IDs (from metadata or default list)
            const sectionIds = Object.keys(this._sections).length > 0
                ? Object.keys(this._sections).sort((a, b) => parseInt(a) - parseInt(b))
                : ['1', '2', '3', '4', '5', '6']; // Default main sections

            const sections = [];
            for (const id of sectionIds) {
                const section = await this.loadSection(id);
                if (section) {
                    sections.push(section);
                }
            }

            console.log(`%cPMSectionLoader: Loaded ${sections.length} sections`, 'color: green; font-weight: bold');
            return sections;
        }

        /**
         * Render a section's content into a container element
         * @param {HTMLElement|string} container - Container element or selector
         * @param {Object} section - Section object from loadSection()
         * @param {Object} options - Rendering options
         * @returns {boolean} - True if rendered successfully
         */
        static renderSection(container, section, options = {}) {
            const element = typeof container === 'string'
                ? document.querySelector(container)
                : container;

            if (!element) {
                console.error('PMSectionLoader.renderSection: Container not found');
                return false;
            }

            if (!section || !section.html) {
                console.error('PMSectionLoader.renderSection: Invalid section object');
                return false;
            }

            const {
                processFormulas = true,
                processParams = true,
                triggerMathJax = true,
                addSectionClass = true,
            } = options;

            // Add section class
            if (addSectionClass) {
                element.classList.add('pm-section-rendered');
                element.setAttribute('data-section-id', section.id);
            }

            // Insert HTML content
            element.innerHTML = section.html;

            // Process formula and param references
            if (processFormulas) {
                this._processFormulaRefs(element);
            }

            if (processParams) {
                this._processParamRefs(element);
            }

            // Trigger PM constants loader to update values
            if (window.PM && typeof window.PM.updateDOM === 'function') {
                window.PM.updateDOM();
            }

            // Trigger MathJax typesetting
            if (triggerMathJax) {
                this._triggerMathJax(element);
            }

            console.log(`PMSectionLoader: Rendered section ${section.id} into ${element.id || 'container'}`);
            return true;
        }

        /**
         * Render all sections into a container
         * @param {HTMLElement|string} container - Container element or selector
         * @param {Array} sections - Array of section objects
         * @param {Object} options - Rendering options
         * @returns {boolean} - True if rendered successfully
         */
        static renderAllSections(container, sections, options = {}) {
            const element = typeof container === 'string'
                ? document.querySelector(container)
                : container;

            if (!element) {
                console.error('PMSectionLoader.renderAllSections: Container not found');
                return false;
            }

            if (!Array.isArray(sections) || sections.length === 0) {
                console.error('PMSectionLoader.renderAllSections: No sections provided');
                return false;
            }

            const {
                wrapEachSection = true,
                sectionWrapperClass = 'pm-section-wrapper',
            } = options;

            // Clear container
            element.innerHTML = '';

            // Render each section
            for (const section of sections) {
                if (wrapEachSection) {
                    const wrapper = document.createElement('div');
                    wrapper.className = sectionWrapperClass;
                    wrapper.setAttribute('data-section-id', section.id);
                    element.appendChild(wrapper);
                    this.renderSection(wrapper, section, options);
                } else {
                    const div = document.createElement('div');
                    element.appendChild(div);
                    this.renderSection(div, section, options);
                }
            }

            console.log(`%cPMSectionLoader: Rendered ${sections.length} sections`, 'color: green; font-weight: bold');
            return true;
        }

        /**
         * Render section content from section object
         * Helper method for rendering just the HTML with formula/param resolution
         * @param {Object} section - Section object
         * @returns {string} - Rendered HTML content
         */
        static renderSectionContent(section) {
            if (!section || !section.html) {
                return '<div style="color: red;">Invalid section object</div>';
            }

            // Create a temporary container
            const temp = document.createElement('div');
            temp.innerHTML = section.html;

            // Process formulas and params
            this._processFormulaRefs(temp);
            this._processParamRefs(temp);

            return temp.innerHTML;
        }

        // ====================================================================
        // PRIVATE HELPER METHODS
        // ====================================================================

        /**
         * Get the HTML filename for a section
         * @private
         */
        static _getSectionFileName(sectionId, metadata) {
            // Check if metadata has explicit file reference
            if (metadata.sectionFile) {
                return metadata.sectionFile.split('/').pop();
            }

            // Map section IDs to filenames
            const filenameMap = {
                '1': 'introduction.html',
                '2': 'geometric-framework.html',
                '3': 'fermion-sector.html',
                '4': 'gauge-unification.html',
                '5': 'cosmology.html',
                '6': 'conclusion.html',
            };

            return filenameMap[sectionId] || `section-${sectionId}.html`;
        }

        /**
         * Extract content from full HTML document
         * Removes <html>, <head>, scripts, etc., and returns just the body content
         * @private
         */
        static _extractContentFromHTML(htmlString) {
            // Create a temporary DOM parser
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');

            // Get the main content (usually in <main> or <body>)
            let content = doc.querySelector('main') || doc.querySelector('body');

            if (!content) {
                console.warn('PMSectionLoader: No main or body element found in HTML');
                return htmlString;
            }

            // Remove script tags from content
            content.querySelectorAll('script').forEach(script => script.remove());

            // Return innerHTML
            return content.innerHTML;
        }

        /**
         * Extract title from HTML content
         * @private
         */
        static _extractTitle(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');

            // Try to get title from <title> tag
            const titleTag = doc.querySelector('title');
            if (titleTag) {
                return titleTag.textContent.replace(' - Principia Metaphysica', '').trim();
            }

            // Try to get from h1 or h2
            const h1 = doc.querySelector('h1');
            if (h1) {
                return h1.textContent.trim();
            }

            return 'Untitled Section';
        }

        /**
         * Process formula references in content
         * Looks for data-formula-id attributes and populates them
         * @private
         */
        static _processFormulaRefs(container) {
            const formulaElements = container.querySelectorAll('[data-formula-id]');

            formulaElements.forEach(element => {
                const formulaId = element.getAttribute('data-formula-id');

                // If element is empty or marked for auto-population, populate it
                if (!element.innerHTML.trim() || element.classList.contains('pm-formula-auto')) {
                    const formula = window.PM?.formula(formulaId);
                    if (formula) {
                        element.innerHTML = formula.html || formula.latex || formula.plainText || '';
                        element.classList.add('pm-formula-auto');
                        element.setAttribute('title', formula.description || formula.label || '');
                    }
                }
            });
        }

        /**
         * Process parameter references in content
         * Looks for data-param-id or data-pm-value attributes
         * @private
         */
        static _processParamRefs(container) {
            // This is handled by PM.updateDOM() from pm-constants-loader.js
            // We just ensure the elements are present
            const paramElements = container.querySelectorAll('[data-pm-value], [data-category][data-param]');

            if (paramElements.length > 0 && window.PM_DEBUG) {
                console.log(`PMSectionLoader: Found ${paramElements.length} parameter references`);
            }
        }

        /**
         * Trigger MathJax typesetting on an element
         * @private
         */
        static _triggerMathJax(element) {
            if (typeof window === 'undefined') return;

            // Defer MathJax to ensure DOM is fully updated
            setTimeout(() => {
                // Check for MathJax v3
                if (window.MathJax && window.MathJax.typesetPromise) {
                    window.MathJax.typesetPromise([element]).catch(err => {
                        console.warn('PMSectionLoader: MathJax typesetting failed:', err);
                    });
                }
                // Check for MathJax v2
                else if (window.MathJax && window.MathJax.Hub) {
                    window.MathJax.Hub.Queue(['Typeset', window.MathJax.Hub, element]);
                }
            }, 100);
        }

        /**
         * Get section metadata by ID
         * @param {string} sectionId - Section ID
         * @returns {Object|null} - Section metadata or null
         */
        static getSectionMetadata(sectionId) {
            return this._sections?.[sectionId] || null;
        }

        /**
         * Get all section metadata
         * @returns {Object} - All section metadata keyed by ID
         */
        static getAllMetadata() {
            return this._sections || {};
        }

        /**
         * Check if sections are loaded
         * @returns {boolean}
         */
        static isLoaded() {
            return this._loaded;
        }

        /**
         * Clear HTML cache (useful for development/hot-reloading)
         */
        static clearCache() {
            this._htmlCache.clear();
            console.log('PMSectionLoader: Cache cleared');
        }
    }

    // ========================================================================
    // AUTO-INITIALIZATION
    // ========================================================================

    /**
     * Auto-render sections marked with data-section-id
     */
    function autoRenderSections() {
        const sectionContainers = document.querySelectorAll('[data-section-id]:not(.pm-section-rendered)');

        if (sectionContainers.length === 0) return;

        console.log(`PMSectionLoader: Found ${sectionContainers.length} sections to auto-render`);

        sectionContainers.forEach(async (container) => {
            const sectionId = container.getAttribute('data-section-id');
            const section = await PMSectionLoader.loadSection(sectionId);
            if (section) {
                PMSectionLoader.renderSection(container, section);
            }
        });
    }

    /**
     * Auto-render full paper view marked with data-render-all-sections
     */
    async function autoRenderAllSections() {
        const paperContainers = document.querySelectorAll('[data-render-all-sections]:not(.pm-sections-rendered)');

        if (paperContainers.length === 0) return;

        console.log(`PMSectionLoader: Found ${paperContainers.length} containers for full paper rendering`);

        for (const container of paperContainers) {
            const sections = await PMSectionLoader.loadAllSections();
            PMSectionLoader.renderAllSections(container, sections);
            container.classList.add('pm-sections-rendered');
        }
    }

    // ========================================================================
    // PUBLIC API
    // ========================================================================

    // Export globally
    window.PMSectionLoader = PMSectionLoader;

    console.log('PMSectionLoader: Section loader ready (v1.0.0)');

    // ========================================================================
    // INITIALIZATION
    // ========================================================================

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            PMSectionLoader.loadMetadata().then(() => {
                autoRenderSections();
                autoRenderAllSections();
            });
        });
    } else {
        PMSectionLoader.loadMetadata().then(() => {
            autoRenderSections();
            autoRenderAllSections();
        });
    }

})();
