/**
 * PM Section Renderer
 * ===================
 *
 * Renders paper sections from JSON metadata.
 * Supports both LaTeX (paper) and HTML (website) output.
 * Uses nested rendering for formulas and parameters within sections.
 *
 * Usage:
 *   <pm-section section-id="2"></pm-section>
 *   <pm-section section-id="A" format="latex"></pm-section>
 *
 * Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
 */

class PMSectionRenderer extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this._sectionData = null;
        this._format = 'html'; // 'html' or 'latex'
    }

    static get observedAttributes() {
        return ['section-id', 'format', 'level'];
    }

    connectedCallback() {
        this.loadAndRender();
    }

    attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue !== newValue) {
            this.loadAndRender();
        }
    }

    async loadAndRender() {
        const sectionId = this.getAttribute('section-id');
        const format = this.getAttribute('format') || 'html';
        const level = this.getAttribute('level') || 'full'; // 'summary', 'display', 'full'

        this._format = format;

        if (!sectionId) {
            this.shadowRoot.innerHTML = '<div class="error">No section-id specified</div>';
            return;
        }

        try {
            // Load section data from theory_output.json
            const section = await this.loadSectionData(sectionId);
            if (!section) {
                this.shadowRoot.innerHTML = `<div class="error">Section not found: ${sectionId}</div>`;
                return;
            }

            this._sectionData = section;

            if (format === 'latex') {
                this.renderLaTeX(section, level);
            } else {
                await this.renderHTML(section, level);
            }
        } catch (error) {
            console.error('PMSectionRenderer error:', error);
            this.shadowRoot.innerHTML = `<div class="error">Error loading section: ${error.message}</div>`;
        }
    }

    async loadSectionData(sectionId) {
        // Try to get from global PM object first
        if (window.PM && window.PM.sections && window.PM.sections[sectionId]) {
            return window.PM.sections[sectionId];
        }

        // Also check if PM._data has sections (loaded by pm-constants-loader.js)
        if (window.PM && window.PM._data && window.PM._data.sections && window.PM._data.sections[sectionId]) {
            return window.PM._data.sections[sectionId];
        }

        // Also check window.PM_DATA (exposed by pm-constants-loader.js)
        if (window.PM_DATA && window.PM_DATA.sections && window.PM_DATA.sections[sectionId]) {
            return window.PM_DATA.sections[sectionId];
        }

        const pathPrefixes = [
            '/AutoGenerated/',           // Absolute path (for live site)
            'AutoGenerated/',            // AutoGenerated folder (primary)
            './AutoGenerated/',          // Explicit relative
            '../AutoGenerated/',         // From subdirectory
            '../../AutoGenerated/',      // From nested subdirectory
        ];

        const triedPaths = [];

        // ================================================================
        // STRATEGY 1: Try individual section file (lazy loading - smallest)
        // ================================================================
        // Convert sectionId to filename format: "4" -> "section-4", "A" -> "appendix-A"
        const isAppendix = /^[A-N]$/.test(sectionId);
        const fileName = isAppendix ? `appendix-${sectionId}.json` : `section-${sectionId}.json`;

        for (const prefix of pathPrefixes) {
            const path = `${prefix}sections/${fileName}`;
            triedPaths.push(path);
            try {
                const response = await fetch(path);
                if (response.ok) {
                    const section = await response.json();
                    if (section && (section.id === sectionId || section.id === String(sectionId))) {
                        // Cache in window.PM
                        if (!window.PM) window.PM = {};
                        if (!window.PM.sections) window.PM.sections = {};
                        window.PM.sections[sectionId] = section;
                        console.log(`%cPMSectionRenderer: Loaded section ${sectionId} from ${path}`, 'color: green');
                        return section;
                    }
                }
            } catch (e) {
                if (window.PM_DEBUG) {
                    console.debug(`  - Failed to load ${path}: ${e.message}`);
                }
                continue;
            }
        }

        // ================================================================
        // STRATEGY 2: Try bundled sections.json (all sections in one file)
        // ================================================================
        for (const prefix of pathPrefixes) {
            const path = prefix + 'sections.json';
            triedPaths.push(path);
            try {
                const response = await fetch(path);
                if (response.ok) {
                    const data = await response.json();
                    const sections = data.sections || data;
                    if (sections && sections[sectionId]) {
                        // Cache in window.PM
                        if (!window.PM) window.PM = {};
                        window.PM.sections = sections;
                        console.log(`%cPMSectionRenderer: Loaded section ${sectionId} from ${path}`, 'color: green');
                        return sections[sectionId];
                    }
                }
            } catch (e) {
                if (window.PM_DEBUG) {
                    console.debug(`  - Failed to load ${path}: ${e.message}`);
                }
                continue;
            }
        }

        // ================================================================
        // STRATEGY 3: Fall back to theory_output.json (legacy format)
        // ================================================================
        for (const prefix of pathPrefixes) {
            const path = prefix + 'theory_output.json';
            if (!triedPaths.includes(path)) {
                triedPaths.push(path);
            }
            try {
                const response = await fetch(path);
                if (response.ok) {
                    const data = await response.json();
                    if (data.sections && data.sections[sectionId]) {
                        // Cache in window.PM
                        if (!window.PM) window.PM = {};
                        window.PM.sections = data.sections;
                        console.log(`%cPMSectionRenderer: Loaded section ${sectionId} from ${path}`, 'color: green');
                        return data.sections[sectionId];
                    }
                }
            } catch (e) {
                if (window.PM_DEBUG) {
                    console.debug(`  - Failed to load ${path}: ${e.message}`);
                }
                continue;
            }
        }

        // ================================================================
        // FAILURE: Could not load section
        // ================================================================
        console.error(`%cPMSectionRenderer: Section not found: ${sectionId}`, 'color: red; font-weight: bold');
        console.error('  Tried paths:', triedPaths);
        console.error('  ');
        console.error('  SOLUTIONS:');
        console.error('  1. Run: python run_all_simulations.py --export');
        console.error('  2. Check that AutoGenerated/sections.json or theory_output.json exists');
        console.error('  3. If using file:// protocol, you may need to run a local web server');
        console.error('     Try: python -m http.server 8000');
        console.error('  ');
        console.error('  Set window.PM_DEBUG = true for verbose logging');

        return null;
    }

    // =========================================================================
    // HTML RENDERING (Website)
    // =========================================================================

    async renderHTML(section, level) {
        const styles = await this.getStyles();

        let content = '';

        // Section header
        content += `
            <header class="section-header">
                <span class="section-number">${section.id}</span>
                <h2 class="section-title">${section.title}</h2>
            </header>
        `;

        // Abstract (if present)
        if (section.abstract && level !== 'summary') {
            content += `<div class="section-abstract">${section.abstract}</div>`;
        }

        // Beginner summary (website only, expandable)
        if (section.beginnerSummary && level === 'full') {
            content += `
                <details class="beginner-summary">
                    <summary>Simplified Explanation</summary>
                    <div class="summary-content">${section.beginnerSummary}</div>
                </details>
            `;
        }

        // Key takeaways
        if (section.keyTakeaways && section.keyTakeaways.length > 0 && level === 'full') {
            content += `
                <div class="key-takeaways">
                    <h4>Key Takeaways</h4>
                    <ul>
                        ${section.keyTakeaways.map(t => `<li>${t}</li>`).join('')}
                    </ul>
                </div>
            `;
        }

        // Content blocks
        if (section.contentBlocks && level !== 'summary') {
            content += '<div class="section-content">';
            for (const block of section.contentBlocks) {
                if (!block.paperOnly) { // Skip paper-only content on website
                    content += this.renderContentBlockHTML(block);
                }
            }
            content += '</div>';
        }

        // Website-only content
        if (section.websiteOnlyContent && section.websiteOnlyContent.length > 0) {
            for (const block of section.websiteOnlyContent) {
                content += this.renderContentBlockHTML(block);
            }
        }

        // Appendices (inline on website)
        if (section.appendices && section.appendices.length > 0 && level === 'full') {
            content += '<div class="section-appendices">';
            for (const appendix of section.appendices) {
                content += this.renderAppendixHTML(appendix);
            }
            content += '</div>';
        }

        // Navigation
        if (level === 'full') {
            content += this.renderNavigationHTML(section);
        }

        this.shadowRoot.innerHTML = `<style>${styles}</style><section class="pm-section">${content}</section>`;

        // Trigger MathJax after rendering
        if (typeof window !== 'undefined' && window.MathJax && window.MathJax.typesetPromise) {
            setTimeout(() => {
                window.MathJax.typesetPromise([this.shadowRoot]).catch(err => {
                    console.warn('MathJax typesetting error in section:', err);
                });
            }, 100);
        }
    }

    /**
     * Process text to detect and replace formula/parameter references
     * Supports: {{formula:id}}, {{param:id}}, <pm-formula>, <pm-param>
     */
    processTextContent(text) {
        if (!text || typeof text !== 'string') return text;

        // Replace formula references: {{formula:id}}
        text = text.replace(/\{\{formula:([^}]+)\}\}/g, (match, id) => {
            return `<pm-formula formula-id="${id}" inline="true"></pm-formula>`;
        });

        // Replace parameter references: {{param:id}}
        text = text.replace(/\{\{param:([^}]+)\}\}/g, (match, id) => {
            return `<pm-param id="${id}" mode="inline"></pm-param>`;
        });

        return text;
    }

    renderContentBlockHTML(block) {
        const wrapExpandable = (html) => {
            if (block.expandable) {
                return `<details class="expandable-block"><summary>Details</summary>${html}</details>`;
            }
            return html;
        };

        switch (block.type) {
            case 'text':
                // Ensure text is a string, not an object
                let textContent = typeof block.text === 'object' ? JSON.stringify(block.text) : (block.text || '');
                // Process text for formula/param references
                textContent = this.processTextContent(textContent);
                return wrapExpandable(`<div class="text-block">${textContent}</div>`);

            case 'formula':
                // Render using pm-formula component with interactive display
                const derivAttr = block.showDerivation ? ' show-derivation="true"' : '';
                const termsAttr = block.showTerms === false ? ' show-terms="false"' : '';
                const inlineAttr = block.inline ? ' inline="true"' : '';

                // Add link to formula page
                const formulaLink = `<a href="formulas.html#formula-${block.formulaId}" class="formula-link" target="_blank">View full details â†’</a>`;

                return wrapExpandable(`
                    <pm-formula formula-id="${block.formulaId}"${derivAttr}${termsAttr}${inlineAttr}></pm-formula>
                    ${!block.inline ? formulaLink : ''}
                `);

            case 'param':
                // Render using pm-param component
                return wrapExpandable(`<pm-param id="${block.paramId}" mode="${block.displayMode || 'inline'}"></pm-param>`);

            case 'figure':
                return wrapExpandable(`
                    <figure class="section-figure" id="${block.figureId}">
                        <img src="images/${block.figureId}.svg" alt="${block.altText || block.caption}" />
                        <figcaption>${block.caption}</figcaption>
                    </figure>
                `);

            case 'table':
                // Ensure column headers are strings, not objects
                const headerRow = (block.columns || []).map(c => {
                    const safeCol = typeof c === 'object' ? JSON.stringify(c) : c;
                    return `<th>${safeCol}</th>`;
                }).join('');
                const bodyRows = (block.rows || []).map(row =>
                    `<tr>${row.map(cell => `<td>${this.processTableCell(cell)}</td>`).join('')}</tr>`
                ).join('');
                return wrapExpandable(`
                    <table class="section-table" id="${block.tableId}">
                        <thead><tr>${headerRow}</tr></thead>
                        <tbody>${bodyRows}</tbody>
                    </table>
                `);

            case 'callout':
                const children = (block.children || []).map(c => this.renderContentBlockHTML(c)).join('');
                return wrapExpandable(`
                    <aside class="callout callout-${block.calloutType}">
                        ${block.title ? `<h4>${block.title}</h4>` : ''}
                        ${children}
                    </aside>
                `);

            case 'grid':
                const gridChildren = (block.children || []).map(c =>
                    `<div class="grid-cell">${this.renderContentBlockHTML(c)}</div>`
                ).join('');
                return wrapExpandable(`
                    <div class="content-grid" style="--columns: ${block.columnsCount || 2}">
                        ${gridChildren}
                    </div>
                `);

            case 'panel':
                const panelChildren = (block.children || []).map(c => this.renderContentBlockHTML(c)).join('');
                return wrapExpandable(`
                    <div class="content-panel">
                        ${block.title ? `<h4 class="panel-title">${block.title}</h4>` : ''}
                        ${panelChildren}
                    </div>
                `);

            default:
                return `<div class="unknown-block">Unknown block type: ${block.type}</div>`;
        }
    }

    processTableCell(cell) {
        // Handle formula and param references in table cells
        if (typeof cell === 'string') {
            // Check for formula reference: {{formula:id}}
            cell = cell.replace(/\{\{formula:([^}]+)\}\}/g,
                (match, id) => `<pm-formula formula-id="${id}" show-label="false"></pm-formula>`);
            // Check for param reference: {{param:id}}
            cell = cell.replace(/\{\{param:([^}]+)\}\}/g,
                (match, id) => `<pm-param id="${id}" mode="inline"></pm-param>`);
            return cell;
        }
        // If cell is an object, convert to JSON string to avoid [object Object]
        return typeof cell === 'object' ? JSON.stringify(cell) : String(cell);
    }

    renderAppendixHTML(appendix) {
        let content = `
            <div class="appendix" id="appendix-${appendix.id}">
                <h3 class="appendix-title">Appendix ${appendix.id}: ${appendix.title}</h3>
        `;

        if (appendix.contentBlocks) {
            for (const block of appendix.contentBlocks) {
                content += this.renderContentBlockHTML(block);
            }
        }

        if (appendix.simulationCode) {
            content += `
                <details class="simulation-code">
                    <summary>Simulation Code (${appendix.simulationFile})</summary>
                    <pre><code>${this.escapeHTML(appendix.simulationCode)}</code></pre>
                </details>
            `;
        }

        content += '</div>';
        return content;
    }

    renderNavigationHTML(section) {
        let nav = '<nav class="section-nav">';
        if (section.prevSection) {
            nav += `<a href="#section-${section.prevSection}" class="nav-prev">Previous</a>`;
        }
        if (section.nextSection) {
            nav += `<a href="#section-${section.nextSection}" class="nav-next">Next</a>`;
        }
        nav += '</nav>';
        return nav;
    }

    // =========================================================================
    // LATEX RENDERING (Paper)
    // =========================================================================

    renderLaTeX(section, level) {
        let latex = '';

        // Section command
        const sectionCmd = section.sectionType === 'appendix' ? 'appendix' : 'section';
        latex += `\\${sectionCmd}{${this.escapeLatex(section.title)}}\\label{sec:${section.id}}\n\n`;

        // Abstract
        if (section.abstract) {
            latex += `\\begin{abstract}\n${this.escapeLatex(section.abstract)}\n\\end{abstract}\n\n`;
        }

        // Content blocks
        if (section.contentBlocks) {
            for (const block of section.contentBlocks) {
                if (!block.websiteOnly) { // Skip website-only content in paper
                    latex += this.renderContentBlockLaTeX(block);
                }
            }
        }

        // Appendices at end of section
        if (section.appendices && section.appendices.length > 0) {
            for (const appendix of section.appendices) {
                latex += this.renderAppendixLaTeX(appendix);
            }
        }

        // Display in pre for now (actual paper would use LaTeX compiler)
        this.shadowRoot.innerHTML = `
            <style>
                pre {
                    background: #1e1e2e;
                    color: #cdd6f4;
                    padding: 1rem;
                    overflow-x: auto;
                    font-family: 'Fira Code', monospace;
                    font-size: 0.9rem;
                    line-height: 1.4;
                }
            </style>
            <pre>${this.escapeHTML(latex)}</pre>
        `;
    }

    renderContentBlockLaTeX(block) {
        switch (block.type) {
            case 'text':
                return this.escapeLatex(block.text) + '\n\n';

            case 'formula':
                // Will need to look up formula LaTeX from registry
                return `\\begin{equation}\\label{eq:${block.formulaId}}\n  % Formula: ${block.formulaId}\n\\end{equation}\n\n`;

            case 'param':
                return `$${block.paramId}$ `;

            case 'figure':
                return `\\begin{figure}[htbp]\n  \\centering\n  \\includegraphics{${block.figureId}}\n  \\caption{${this.escapeLatex(block.caption)}}\\label{fig:${block.figureId}}\n\\end{figure}\n\n`;

            case 'table':
                const colSpec = block.columns.map(() => 'c').join('|');
                let table = `\\begin{table}[htbp]\n  \\centering\n  \\begin{tabular}{|${colSpec}|}\n    \\hline\n`;
                table += `    ${block.columns.join(' & ')} \\\\ \\hline\n`;
                for (const row of (block.rows || [])) {
                    table += `    ${row.join(' & ')} \\\\ \\hline\n`;
                }
                table += `  \\end{tabular}\n  \\caption{}\\label{tab:${block.tableId}}\n\\end{table}\n\n`;
                return table;

            case 'callout':
                const children = (block.children || []).map(c => this.renderContentBlockLaTeX(c)).join('');
                return `\\begin{tcolorbox}[title=${this.escapeLatex(block.title || '')}]\n${children}\\end{tcolorbox}\n\n`;

            default:
                return `% Unknown block type: ${block.type}\n`;
        }
    }

    renderAppendixLaTeX(appendix) {
        let latex = `\\subsection{Appendix ${appendix.id}: ${this.escapeLatex(appendix.title)}}\\label{app:${appendix.id}}\n\n`;

        if (appendix.contentBlocks) {
            for (const block of appendix.contentBlocks) {
                latex += this.renderContentBlockLaTeX(block);
            }
        }

        if (appendix.simulationCode) {
            latex += `\\begin{lstlisting}[language=Python,caption=${appendix.simulationFile}]\n${appendix.simulationCode}\n\\end{lstlisting}\n\n`;
        }

        return latex;
    }

    // =========================================================================
    // UTILITY METHODS
    // =========================================================================

    escapeHTML(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }

    escapeLatex(str) {
        if (!str) return '';
        return str
            .replace(/\\/g, '\\textbackslash{}')
            .replace(/[&%$#_{}]/g, '\\$&')
            .replace(/~/g, '\\textasciitilde{}')
            .replace(/\^/g, '\\textasciicircum{}');
    }

    async getStyles() {
        // Try to load external CSS file for paper styling
        try {
            const pathPrefixes = [
                '',
                '../',
                '../../',
            ];

            for (const prefix of pathPrefixes) {
                const path = prefix + 'css/pm-section-paper.css';
                try {
                    const response = await fetch(path);
                    if (response.ok) {
                        const css = await response.text();
                        console.log(`%cPMSectionRenderer: Loaded paper CSS from ${path}`, 'color: green');
                        return css;
                    }
                } catch (e) {
                    // Continue to next path
                    continue;
                }
            }
        } catch (e) {
            console.warn('PMSectionRenderer: Could not load external CSS, using fallback');
        }

        // Fallback inline styles that match the paper
        return `
            @import url('https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400&family=Source+Sans+Pro:wght@400;600&family=Source+Code+Pro:wght@400;500&display=swap');

            :root {
                --bg-dark: #0a0a0f;
                --bg-paper: #ffffff;
                --text-dark: #1a1a1a;
                --text-light: #f8f9fa;
                --accent: #8b7fff;
                --accent-secondary: #ff7eb6;
                --border: #e0e0e0;
                --code-bg: #f5f5f5;
            }

            :host {
                display: block;
                font-family: 'Crimson Text', Georgia, serif;
                line-height: 1.7;
                color: var(--text-dark);
                font-size: 11pt;
            }

            .pm-section {
                max-width: 850px;
                margin: 0 auto;
                padding: 2rem 0;
                background: transparent;
                color: var(--text-dark);
            }

            .section-header {
                margin-bottom: 1.5rem;
            }

            .section-number {
                display: inline-block;
                font-size: 1.3rem;
                color: var(--accent);
                font-weight: 700;
                margin-right: 0.5rem;
            }

            .section-title {
                display: inline-block;
                font-size: 1.3rem;
                margin: 0;
                padding-bottom: 0.3rem;
                border-bottom: 2px solid var(--border);
                font-weight: 600;
                color: #333;
                width: 100%;
            }

            h2.section-title {
                font-size: 1.3rem;
                margin: 2.5rem 0 1rem;
                padding-bottom: 0.3rem;
                border-bottom: 2px solid var(--border);
            }

            h3.subsection-title {
                font-size: 1.1rem;
                margin: 1.5rem 0 0.8rem;
                color: #333;
            }

            .section-abstract,
            .abstract {
                background: #f8f9fa;
                padding: 20px 25px;
                border-left: 4px solid var(--accent);
                margin: 2rem 0;
            }

            .section-abstract h2,
            .abstract h2 {
                font-size: 1rem;
                text-transform: uppercase;
                letter-spacing: 1px;
                margin-bottom: 0.8rem;
            }

            .section-abstract p,
            .abstract p {
                font-size: 0.95rem;
                text-align: justify;
            }

            .beginner-summary {
                background: rgba(96, 165, 250, 0.05);
                border: 1px solid rgba(96, 165, 250, 0.2);
                border-radius: 8px;
                margin: 1.5rem 0;
            }

            .beginner-summary summary {
                padding: 0.75rem 1rem;
                cursor: pointer;
                font-weight: 600;
                color: #60a5fa;
                list-style: none;
            }

            .beginner-summary summary::-webkit-details-marker {
                display: none;
            }

            .summary-content {
                padding: 1rem;
                border-top: 1px solid rgba(96, 165, 250, 0.1);
            }

            .key-takeaways {
                background: rgba(74, 222, 128, 0.05);
                border-left: 4px solid #4ade80;
                padding: 1rem 1.5rem;
                margin: 1.5rem 0;
            }

            .key-takeaways h4 {
                color: #2d8659;
                margin: 0 0 0.5rem 0;
                font-size: 1rem;
            }

            .key-takeaways ul {
                margin: 0;
                padding-left: 1.5rem;
            }

            .key-takeaways li {
                margin-bottom: 0.3rem;
            }

            .section-content {
                margin-bottom: 2rem;
            }

            .text-block {
                margin-bottom: 1rem;
                text-align: justify;
            }

            .text-block p {
                margin-bottom: 1rem;
                text-align: justify;
            }

            .equation-block {
                margin: 1.5rem 0;
                padding: 1rem 0;
                overflow-x: auto;
            }

            .equation-number {
                float: right;
                color: #666;
                font-size: 0.9rem;
            }

            pm-formula {
                display: block;
                margin: 1.5rem 0;
            }

            pm-formula[inline] {
                display: inline-block;
                margin: 0;
            }

            .derivation-box,
            .callout-derivation {
                background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
                border: 1px solid #dee2e6;
                border-radius: 8px;
                padding: 20px;
                margin: 1.5rem 0;
            }

            .derivation-box h4,
            .callout h4 {
                font-size: 1rem;
                color: var(--accent);
                margin-bottom: 0.8rem;
                border-bottom: 1px solid #dee2e6;
                padding-bottom: 0.5rem;
            }

            .derivation-step {
                margin: 0.5rem 0;
                padding-left: 1.5rem;
                position: relative;
            }

            .derivation-step::before {
                content: counter(step);
                counter-increment: step;
                position: absolute;
                left: 0;
                color: var(--accent);
                font-weight: 600;
            }

            .derivation-box ol {
                counter-reset: step;
                list-style: none;
                padding: 0;
            }

            .callout {
                padding: 1rem 1.5rem;
                margin: 1.5rem 0;
                border-radius: 8px;
                border-left: 4px solid;
            }

            .callout-info {
                background: rgba(96, 165, 250, 0.05);
                border-color: #60a5fa;
            }

            .callout-warning {
                background: rgba(251, 191, 36, 0.05);
                border-color: #fbbf24;
            }

            .callout-derivation {
                background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
                border-color: var(--accent);
            }

            .callout-example {
                background: rgba(74, 222, 128, 0.05);
                border-color: #4ade80;
            }

            .callout-success {
                background: rgba(74, 222, 128, 0.05);
                border-color: #2e7d32;
            }

            .callout-note {
                background: #f8f9fa;
                border-color: #666;
            }

            .callout h4 {
                margin: 0 0 0.5rem 0;
                font-size: 1rem;
            }

            .callout p {
                margin-bottom: 0.5rem;
            }

            .callout p:last-child {
                margin-bottom: 0;
            }

            table,
            .section-table {
                width: 100%;
                border-collapse: collapse;
                margin: 1.5rem 0;
                font-size: 0.9rem;
            }

            th, td,
            .section-table th,
            .section-table td {
                padding: 10px 12px;
                text-align: left;
                border-bottom: 1px solid var(--border);
            }

            th,
            .section-table th {
                background: #f5f5f5;
                font-weight: 600;
            }

            .section-table.bordered th,
            .section-table.bordered td {
                border: 1px solid var(--border);
            }

            pre {
                background: var(--code-bg);
                padding: 15px 20px;
                border-radius: 6px;
                overflow-x: auto;
                font-family: 'Source Code Pro', monospace;
                font-size: 0.85rem;
                line-height: 1.5;
                margin: 1rem 0;
                border-left: 3px solid var(--accent);
            }

            code {
                font-family: 'Source Code Pro', monospace;
                font-size: 0.9em;
                background: #f0f0f0;
                padding: 2px 5px;
                border-radius: 3px;
            }

            pre code {
                background: none;
                padding: 0;
            }

            figure,
            .section-figure {
                text-align: center;
                margin: 2rem 0;
            }

            figure img,
            .section-figure img {
                max-width: 100%;
                height: auto;
            }

            figcaption,
            .section-figure figcaption,
            .diagram-caption {
                font-size: 0.9rem;
                color: #666;
                margin-top: 0.5rem;
                font-style: italic;
            }

            .diagram-container {
                margin: 2rem 0;
                text-align: center;
            }

            .diagram-container svg {
                max-width: 100%;
                height: auto;
            }

            ul, ol {
                margin-left: 2rem;
                margin-bottom: 1rem;
            }

            li {
                margin-bottom: 0.3rem;
            }

            ul ul, ol ol, ul ol, ol ul {
                margin-top: 0.3rem;
                margin-bottom: 0.3rem;
            }

            .content-panel {
                background: #f8f9fa;
                border: 1px solid var(--border);
                border-radius: 8px;
                padding: 1.5rem;
                margin: 1.5rem 0;
            }

            .panel-title {
                color: var(--accent);
                margin: 0 0 1rem 0;
                font-size: 1.1rem;
            }

            .content-grid {
                display: grid;
                grid-template-columns: repeat(var(--columns, 2), 1fr);
                gap: 1.5rem;
                margin: 1.5rem 0;
            }

            .grid-cell {
                background: #f8f9fa;
                padding: 1rem;
                border-radius: 6px;
                border-left: 3px solid var(--accent);
            }

            .expandable-block {
                margin: 1rem 0;
            }

            .expandable-block summary {
                cursor: pointer;
                color: var(--accent);
                font-weight: 600;
                list-style: none;
                padding: 0.5rem;
                background: #f8f9fa;
                border-radius: 4px;
            }

            .expandable-block summary::-webkit-details-marker {
                display: none;
            }

            .expandable-block summary:hover {
                background: #e9ecef;
            }

            .expandable-block[open] summary {
                margin-bottom: 1rem;
            }

            .appendix {
                margin-top: 3rem;
                padding-top: 2rem;
                border-top: 2px solid var(--border);
            }

            .appendix-title {
                color: var(--accent);
                font-size: 1.2rem;
                margin-bottom: 1rem;
            }

            .section-appendices {
                margin-top: 3rem;
            }

            .simulation-code {
                margin-top: 1rem;
            }

            .simulation-code summary {
                cursor: pointer;
                color: var(--accent);
                font-weight: 600;
                list-style: none;
                padding: 0.5rem;
                background: #f8f9fa;
                border-radius: 4px;
            }

            .simulation-code summary::-webkit-details-marker {
                display: none;
            }

            .simulation-code pre {
                background: #1e1e2e;
                color: #cdd6f4;
                padding: 1rem;
                overflow-x: auto;
                border-radius: 4px;
                font-size: 0.85rem;
                margin-top: 0.5rem;
            }

            .section-nav {
                display: flex;
                justify-content: space-between;
                margin-top: 3rem;
                padding-top: 1rem;
                border-top: 1px solid var(--border);
            }

            .section-nav a {
                color: var(--accent);
                text-decoration: none;
                padding: 0.5rem 1rem;
                border: 1px solid var(--border);
                border-radius: 4px;
                transition: all 0.2s ease;
            }

            .section-nav a:hover {
                background: #f8f9fa;
                border-color: var(--accent);
            }

            p {
                margin-bottom: 1rem;
                text-align: justify;
            }

            strong {
                font-weight: 600;
            }

            em {
                font-style: italic;
            }

            sub, sup {
                font-size: 0.75em;
                line-height: 0;
                position: relative;
                vertical-align: baseline;
            }

            sup {
                top: -0.5em;
            }

            sub {
                bottom: -0.25em;
            }

            pm-formula::part(container) {
                font-family: 'Crimson Text', Georgia, serif;
                color: var(--text-dark);
            }

            pm-formula::part(label) {
                font-family: 'Source Sans Pro', sans-serif;
                font-weight: 600;
                color: var(--accent);
            }

            pm-formula::part(formula-display) {
                margin: 1rem 0;
                font-size: 1.1em;
            }

            pm-value {
                font-family: 'Source Code Pro', monospace;
                font-size: 0.9em;
            }

            .references {
                font-size: 0.9rem;
            }

            .references li {
                margin-bottom: 0.5rem;
            }

            .references ol {
                counter-reset: ref-counter;
                list-style: none;
            }

            .references ol li {
                counter-increment: ref-counter;
                padding-left: 2.5rem;
                position: relative;
            }

            .references ol li::before {
                content: "[" counter(ref-counter) "]";
                position: absolute;
                left: 0;
                color: #666;
                font-weight: 600;
            }

            .error {
                color: #dc3545;
                padding: 1rem;
                background: rgba(220, 53, 69, 0.1);
                border-radius: 4px;
                border-left: 3px solid #dc3545;
            }

            @media screen and (max-width: 768px) {
                .pm-section {
                    padding: 1rem;
                }

                .section-title {
                    font-size: 1.15rem;
                }

                h3.subsection-title {
                    font-size: 1rem;
                }

                .abstract,
                .section-abstract {
                    padding: 15px;
                }

                .derivation-box,
                .callout {
                    padding: 15px;
                    margin: 1rem 0;
                }

                .equation-block {
                    padding: 0.5rem 0;
                    font-size: 0.9rem;
                }

                table,
                .section-table {
                    display: block;
                    overflow-x: auto;
                    white-space: nowrap;
                    font-size: 0.8rem;
                }

                th, td,
                .section-table th,
                .section-table td {
                    padding: 8px 10px;
                }

                pre {
                    padding: 10px 12px;
                    font-size: 0.75rem;
                }

                .content-grid {
                    grid-template-columns: 1fr;
                }

                ul, ol {
                    margin-left: 1.5rem;
                }
            }

            @media screen and (max-width: 480px) {
                .pm-section {
                    padding: 0.5rem;
                }

                .section-title {
                    font-size: 1.05rem;
                }

                .derivation-box,
                .callout {
                    padding: 12px;
                    border-radius: 6px;
                }

                .derivation-step {
                    padding-left: 1.2rem;
                    font-size: 0.9rem;
                }
            }

            @media print {
                .pm-section {
                    padding: 0;
                    max-width: none;
                }

                .section-nav {
                    display: none;
                }

                .beginner-summary,
                .expandable-block summary {
                    display: none;
                }

                .expandable-block[open] {
                    display: block;
                }

                @page {
                    size: A4;
                    margin: 25mm 20mm;
                }
            }
        `;
    }
}

// Register the custom element
if (typeof window !== 'undefined' && window.customElements) {
    if (!customElements.get('pm-section')) {
        customElements.define('pm-section', PMSectionRenderer);
    }
}

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { PMSectionRenderer };
}
