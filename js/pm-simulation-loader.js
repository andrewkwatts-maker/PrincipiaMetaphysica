/**
 * PM Simulation Loader v17.2
 *
 * Dynamically loads and displays simulation files from the repository.
 * Creates categories from folder structure with expandable file panels.
 *
 * Features:
 * - Loads from simulations-index.json (primary) or GitHub API (fallback)
 * - Creates category cards from folder structure
 * - Lazy-loads file content on expand
 * - Caches loaded content in memory
 * - Syntax highlighting via Prism.js
 *
 * Copyright (c) 2025 Andrew Keith Watts. All rights reserved.
 */

(function(global) {
    'use strict';

    // Configuration
    const CONFIG = {
        GITHUB_REPO: 'andrewkwatts-maker/PrincipiaMetaphysica',
        GITHUB_BRANCH: 'main',
        INDEX_PATHS: [
            '../AutoGenerated/simulations-index.json',
            '/AutoGenerated/simulations-index.json',
            'AutoGenerated/simulations-index.json',
            './simulations-index.json'
        ],
        CACHE_TTL: 5 * 60 * 1000, // 5 minutes
        GITHUB_API_BASE: 'https://api.github.com/repos',
        GITHUB_RAW_BASE: 'https://raw.githubusercontent.com'
    };

    // Internal state
    const state = {
        index: null,
        fileCache: new Map(),
        folderCache: null,
        lastIndexLoad: 0,
        isLoading: false,
        loadError: null
    };

    /**
     * Get GitHub raw content URL
     */
    function getRawUrl(path) {
        return `${CONFIG.GITHUB_RAW_BASE}/${CONFIG.GITHUB_REPO}/${CONFIG.GITHUB_BRANCH}/${path}`;
    }

    /**
     * Get GitHub API URL
     */
    function getApiUrl(path) {
        return `${CONFIG.GITHUB_API_BASE}/${CONFIG.GITHUB_REPO}/contents/${path}`;
    }

    /**
     * Load the simulation index from JSON file
     * @returns {Promise<Object|null>} The loaded index or null on failure
     */
    async function loadIndex() {
        // Check cache
        if (state.index && (Date.now() - state.lastIndexLoad) < CONFIG.CACHE_TTL) {
            console.log('[PM-SimLoader] Using cached index');
            return state.index;
        }

        state.isLoading = true;
        state.loadError = null;

        // Try each path in order
        for (const path of CONFIG.INDEX_PATHS) {
            try {
                console.log(`[PM-SimLoader] Trying index path: ${path}`);
                const response = await fetch(path);

                if (!response.ok) continue;

                const text = await response.text();

                // Validate it's actually JSON
                if (!text.trim().startsWith('{')) {
                    console.log(`[PM-SimLoader] Path ${path} returned non-JSON`);
                    continue;
                }

                const data = JSON.parse(text);

                // Validate structure
                if (data.categories && data.version) {
                    state.index = data;
                    state.lastIndexLoad = Date.now();
                    state.isLoading = false;
                    console.log(`[PM-SimLoader] Loaded index v${data.version} with ${data.total_scripts} scripts`);
                    return data;
                }
            } catch (e) {
                console.log(`[PM-SimLoader] Failed to load from ${path}:`, e.message);
            }
        }

        // Fallback to GitHub API
        console.log('[PM-SimLoader] Static index not found, falling back to GitHub API');
        const apiIndex = await buildIndexFromGitHub();

        if (apiIndex) {
            state.index = apiIndex;
            state.lastIndexLoad = Date.now();
        }

        state.isLoading = false;
        return state.index;
    }

    /**
     * Build index dynamically from GitHub API
     * @returns {Promise<Object|null>} Built index or null on failure
     */
    async function buildIndexFromGitHub() {
        try {
            const response = await fetch(getApiUrl('simulations'));

            if (!response.ok) {
                // Check rate limiting
                const remaining = response.headers.get('X-RateLimit-Remaining');
                if (response.status === 403 && (remaining === '0' || remaining === null)) {
                    state.loadError = 'GitHub API rate limit exceeded (60 requests/hour)';
                    console.error('[PM-SimLoader] Rate limit exceeded');
                    return null;
                }
                throw new Error(`GitHub API returned ${response.status}`);
            }

            const items = await response.json();
            const categories = {};

            // Process directories
            for (const item of items.filter(i => i.type === 'dir')) {
                if (item.name === 'v16') {
                    // Fetch v16 subdirectories
                    const v16Response = await fetch(item.url);
                    if (v16Response.ok) {
                        const v16Items = await v16Response.json();
                        for (const subdir of v16Items.filter(i => i.type === 'dir')) {
                            const scripts = await fetchScriptsFromFolder(subdir.url);
                            if (scripts.length > 0) {
                                categories[`v16/${subdir.name}`] = {
                                    title: `v16 / ${capitalizeFirst(subdir.name)}`,
                                    path: subdir.path,
                                    folderName: subdir.name,
                                    description: `${capitalizeFirst(subdir.name)} simulations`,
                                    isV16: true,
                                    order: getOrderForCategory(subdir.name),
                                    sectionId: getSectionIdForCategory(subdir.name),
                                    scripts: scripts,
                                    count: scripts.length
                                };
                            }
                        }
                    }
                } else if (!['__pycache__', '.git', 'AutoGenerated'].includes(item.name)) {
                    const scripts = await fetchScriptsFromFolder(item.url);
                    if (scripts.length > 0) {
                        categories[item.name] = {
                            title: capitalizeFirst(item.name),
                            path: item.path,
                            folderName: item.name,
                            description: `${capitalizeFirst(item.name)} utilities`,
                            isV16: false,
                            order: 90,
                            sectionId: null,
                            scripts: scripts,
                            count: scripts.length
                        };
                    }
                }
            }

            return {
                version: '17.2-dynamic',
                generated: new Date().toISOString(),
                total_scripts: Object.values(categories).reduce((sum, cat) => sum + cat.scripts.length, 0),
                categories: categories
            };
        } catch (error) {
            console.error('[PM-SimLoader] GitHub API error:', error);
            state.loadError = error.message;
            return null;
        }
    }

    /**
     * Fetch Python scripts from a GitHub folder
     */
    async function fetchScriptsFromFolder(folderUrl) {
        try {
            const response = await fetch(folderUrl);
            if (!response.ok) return [];

            const items = await response.json();
            return items
                .filter(item =>
                    item.type === 'file' &&
                    item.name.endsWith('.py') &&
                    item.name !== '__init__.py'
                )
                .map(item => ({
                    file: item.name,
                    path: item.path,
                    version: extractVersion(item.name),
                    title: null,
                    description: formatFileName(item.name),
                    status: null
                }));
        } catch (error) {
            console.error('[PM-SimLoader] Error fetching folder:', error);
            return [];
        }
    }

    /**
     * Load file content with caching
     * @param {string} filePath - Path to the file
     * @returns {Promise<string|null>} File content or null on failure
     */
    async function loadFileContent(filePath) {
        // Check cache
        if (state.fileCache.has(filePath)) {
            console.log(`[PM-SimLoader] Using cached content for ${filePath}`);
            return state.fileCache.get(filePath);
        }

        try {
            const url = getRawUrl(filePath);
            console.log(`[PM-SimLoader] Fetching ${url}`);

            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            const content = await response.text();
            state.fileCache.set(filePath, content);
            return content;
        } catch (error) {
            console.error(`[PM-SimLoader] Error loading ${filePath}:`, error);
            return null;
        }
    }

    /**
     * Get categories sorted by order
     * @returns {Array} Sorted array of [categoryKey, categoryData] pairs
     */
    function getSortedCategories() {
        if (!state.index || !state.index.categories) return [];

        return Object.entries(state.index.categories)
            .sort((a, b) => (a[1].order || 99) - (b[1].order || 99));
    }

    /**
     * Get scripts for a specific category
     * @param {string} categoryKey - Category identifier
     * @returns {Array} Array of script objects
     */
    function getCategoryScripts(categoryKey) {
        if (!state.index || !state.index.categories) return [];
        const category = state.index.categories[categoryKey];
        return category ? category.scripts || [] : [];
    }

    /**
     * Search scripts across all categories
     * @param {string} query - Search query
     * @returns {Array} Matching scripts with category info
     */
    function searchScripts(query) {
        if (!state.index || !query) return [];

        const lowerQuery = query.toLowerCase();
        const results = [];

        for (const [catKey, catData] of Object.entries(state.index.categories)) {
            for (const script of catData.scripts || []) {
                const matchFile = script.file.toLowerCase().includes(lowerQuery);
                const matchDesc = script.description &&
                    script.description.toLowerCase().includes(lowerQuery);

                if (matchFile || matchDesc) {
                    results.push({
                        ...script,
                        category: catKey,
                        categoryTitle: catData.title
                    });
                }
            }
        }

        return results;
    }

    /**
     * Create HTML for a category card
     * @param {string} categoryKey - Category identifier
     * @param {Object} categoryData - Category data
     * @returns {string} HTML string
     */
    function renderCategoryCard(categoryKey, categoryData) {
        const icon = getCategoryIcon(categoryKey);
        const scriptCount = categoryData.scripts ? categoryData.scripts.length : 0;

        return `
            <div class="index-category" data-category="${categoryKey}">
                <h3>${icon} ${categoryData.title}</h3>
                <p class="category-description">${categoryData.description || ''}</p>
                <ul>
                    ${(categoryData.scripts || []).slice(0, 5).map(script => `
                        <li>
                            <span class="index-link" onclick="PMSimLoader.scrollToScript('${script.file}', '${script.path}')">
                                ${script.file}
                            </span>
                        </li>
                    `).join('')}
                    ${scriptCount > 5 ? `<li class="more-scripts">+ ${scriptCount - 5} more...</li>` : ''}
                </ul>
                <div class="category-footer">
                    <span class="script-count">${scriptCount} scripts</span>
                    ${categoryData.isV16 ? '<span class="status-badge">v16</span>' : ''}
                </div>
            </div>
        `;
    }

    /**
     * Create HTML for an expandable file panel
     * @param {Object} script - Script object
     * @param {string} categoryKey - Category identifier
     * @returns {string} HTML string
     */
    function renderFilePanel(script, categoryKey) {
        const language = script.file.endsWith('.json') ? 'json' :
                        script.file.endsWith('.js') ? 'javascript' : 'python';

        return `
            <div class="file-section" id="section-${script.file}" data-path="${script.path}">
                <div class="file-header" onclick="PMSimLoader.togglePanel('${script.file}', '${script.path}')">
                    <div class="file-info">
                        <span class="file-icon">${getFileIcon(language)}</span>
                        <div class="file-meta">
                            <span class="file-name">${script.file}</span>
                            <span class="file-description">${script.description || formatFileName(script.file)}</span>
                        </div>
                    </div>
                    <div class="file-actions">
                        ${script.version ? `<span class="version-badge">v${script.version}</span>` : ''}
                        ${script.status ? `<span class="status-badge" data-status="${script.status}">${script.status}</span>` : ''}
                        <span class="toggle-icon">+</span>
                    </div>
                </div>
                <div class="file-content" data-language="${language}">
                    <div class="file-placeholder">Click to load content</div>
                </div>
            </div>
        `;
    }

    /**
     * Toggle file panel expansion
     * @param {string} filename - File name
     * @param {string} filePath - File path
     */
    async function togglePanel(filename, filePath) {
        const section = document.getElementById(`section-${filename}`);
        if (!section) return;

        const isExpanded = section.classList.contains('expanded');
        const contentDiv = section.querySelector('.file-content');
        const toggleIcon = section.querySelector('.toggle-icon');

        if (isExpanded) {
            section.classList.remove('expanded');
            if (toggleIcon) toggleIcon.textContent = '+';
        } else {
            section.classList.add('expanded');
            if (toggleIcon) toggleIcon.textContent = '-';

            // Load content if not already loaded
            if (contentDiv && !contentDiv.classList.contains('loaded')) {
                contentDiv.innerHTML = '<div class="file-loading"><span class="spinner"></span>Loading...</div>';

                const content = await loadFileContent(filePath);

                if (content) {
                    const language = contentDiv.dataset.language || 'python';
                    const lines = content.split('\n').length;
                    const size = new Blob([content]).size;
                    const sizeStr = size > 1024 ? `${(size / 1024).toFixed(1)} KB` : `${size} bytes`;

                    contentDiv.innerHTML = `
                        <div class="file-stats">${lines} lines | ${sizeStr}</div>
                        <pre class="line-numbers"><code class="language-${language}">${escapeHtml(content)}</code></pre>
                    `;
                    contentDiv.classList.add('loaded');

                    // Trigger Prism highlighting
                    if (window.Prism) {
                        Prism.highlightAllUnder(contentDiv);
                    }
                } else {
                    contentDiv.innerHTML = '<div class="file-error">Failed to load file content</div>';
                }
            }
        }
    }

    /**
     * Scroll to and expand a specific script
     * @param {string} filename - File name
     * @param {string} filePath - File path
     */
    function scrollToScript(filename, filePath) {
        const section = document.getElementById(`section-${filename}`);
        if (section) {
            section.scrollIntoView({ behavior: 'smooth', block: 'start' });
            setTimeout(() => {
                if (!section.classList.contains('expanded')) {
                    togglePanel(filename, filePath);
                }
            }, 300);
        }
    }

    /**
     * Render the full simulation browser
     * @param {Object} containers - Container element IDs
     */
    async function render(containers = {}) {
        const {
            indexContainer = 'index-container',
            categoriesContainer = 'simulation-categories-container',
            loadingIndicator = 'simulations-loading'
        } = containers;

        // Show loading
        const loadingEl = document.getElementById(loadingIndicator);
        if (loadingEl) loadingEl.style.display = 'block';

        // Load index
        const index = await loadIndex();

        // Hide loading
        if (loadingEl) loadingEl.style.display = 'none';

        if (!index) {
            const container = document.getElementById(categoriesContainer);
            if (container) {
                container.innerHTML = `
                    <div class="file-error" style="text-align: center; padding: 2rem;">
                        <h3>Unable to Load Simulations</h3>
                        <p>${state.loadError || 'Could not load simulation index'}</p>
                        <p><small>Try running: <code>python simulations/Constants/generate_simulations_index.py</code></small></p>
                    </div>
                `;
            }
            return;
        }

        // Render index cards
        const indexEl = document.getElementById(indexContainer);
        if (indexEl) {
            const sortedCategories = getSortedCategories();
            indexEl.innerHTML = `
                <div class="index-grid">
                    ${sortedCategories.map(([key, data]) => renderCategoryCard(key, data)).join('')}
                </div>
                <div class="index-stats">
                    <span>${index.total_scripts} simulation scripts</span>
                    <span class="separator">|</span>
                    <span>${sortedCategories.length} categories</span>
                    <span class="separator">|</span>
                    <span>v${index.version}</span>
                </div>
            `;
        }

        // Render file panels by category
        const catEl = document.getElementById(categoriesContainer);
        if (catEl) {
            const sortedCategories = getSortedCategories();
            catEl.innerHTML = sortedCategories.map(([key, data]) => `
                <div class="category-section" data-category="${key}">
                    <h2 class="category-header">${getCategoryIcon(key)} ${data.title}</h2>
                    <p class="category-description">${data.description || ''}</p>
                    <div class="category-scripts">
                        ${(data.scripts || []).map(script => renderFilePanel(script, key)).join('')}
                    </div>
                </div>
            `).join('');
        }

        // Dispatch ready event
        document.dispatchEvent(new CustomEvent('pm-simulations-ready', {
            detail: { index: index, scriptCount: index.total_scripts }
        }));
    }

    // Utility functions
    function capitalizeFirst(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }

    function extractVersion(filename) {
        const match = filename.match(/_v(\d+)_(\d+)/);
        return match ? `${match[1]}.${match[2]}` : null;
    }

    function formatFileName(filename) {
        return filename
            .replace(/\.py$/, '')
            .replace(/_v\d+_\d+/, '')
            .replace(/_/g, ' ')
            .replace(/\b\w/g, c => c.toUpperCase());
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function getCategoryIcon(categoryKey) {
        const icons = {
            'v16/cosmology': 'ðŸŒŒ',
            'v16/fermion': 'âš›ï¸',
            'v16/gauge': 'ðŸ”—',
            'v16/geometric': 'ðŸ“',
            'v16/higgs': 'âš¡',
            'v16/neutrino': 'ðŸ‘»',
            'v16/appendices': 'ðŸ“š',
            'v16/validation': 'âœ“',
            'validation': 'âœ“',
            'cosmology': 'ðŸŒŒ',
            'Constants': 'âš™ï¸',
            'base': 'ðŸ—ï¸',
            'data': 'ðŸ“Š',
            'derivations': 'ðŸ“'
        };
        return icons[categoryKey] || 'ðŸ“„';
    }

    function getFileIcon(language) {
        const icons = { python: 'ðŸ', json: '{}', javascript: 'JS' };
        return icons[language] || 'ðŸ“„';
    }

    function getOrderForCategory(name) {
        const orders = {
            introduction: 0, gauge: 1, geometric: 2, fermion: 3,
            neutrino: 4, higgs: 5, proton: 6, pneuma: 8,
            cosmology: 9, quantum_bio: 10, thermal: 11,
            predictions: 12, statistics: 13, discussion: 20,
            appendices: 30, validation: 40
        };
        return orders[name] || 50;
    }

    function getSectionIdForCategory(name) {
        const sections = {
            introduction: '1', gauge: '2', geometric: '2',
            fermion: '4', neutrino: '4', higgs: '4',
            proton: '4', cosmology: '5', quantum_bio: '6',
            discussion: '7', appendices: 'A'
        };
        return sections[name] || null;
    }

    // Public API
    const PMSimLoader = {
        // Core functions
        loadIndex,
        loadFileContent,
        render,

        // Category functions
        getSortedCategories,
        getCategoryScripts,
        searchScripts,

        // UI functions
        togglePanel,
        scrollToScript,
        renderCategoryCard,
        renderFilePanel,

        // State access
        getState: () => ({ ...state }),
        getConfig: () => ({ ...CONFIG }),

        // Cache management
        clearCache: () => {
            state.fileCache.clear();
            state.index = null;
            state.lastIndexLoad = 0;
        },

        // For testing
        _internal: {
            extractVersion,
            formatFileName,
            capitalizeFirst,
            getOrderForCategory,
            getSectionIdForCategory
        }
    };

    // Export
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = PMSimLoader;
    } else {
        global.PMSimLoader = PMSimLoader;
    }

})(typeof window !== 'undefined' ? window : global);
