<!DOCTYPE html>
<!--
    Copyright (c) 2025 Andrew Keith Watts. All rights reserved.

    This is the intellectual property of Andrew Keith Watts. Unauthorized
    reproduction, distribution, or modification of this code, in whole or in part,
    without the express written permission of Andrew Keith Watts is strictly prohibited.

    For inquiries, please contact AndrewKWatts@Gmail.com
-->
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta content="Complete parameter reference for Principia Metaphysica - geometric, derived, calibrated, predicted, and experimental parameters" name="description"/>
    <title>Theory Parameters - Principia Metaphysica</title>
    <link href="css/styles.css" rel="stylesheet"/>
    <link href="css/pm-common.css" rel="stylesheet"/>
    <link rel="stylesheet" href="/css/auth.css">

    <!-- MathJax for mathematical symbols -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                tags: 'ams'
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        /* Page-specific styles */
        .parameters-hero {
            background: linear-gradient(135deg, rgba(139, 127, 255, 0.15), rgba(81, 207, 102, 0.1));
            border: 2px solid rgba(139, 127, 255, 0.3);
            border-radius: 20px;
            padding: 3rem;
            margin-bottom: 2.5rem;
            text-align: center;
            position: relative;
        }

        .parameters-hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-primary), #51cf66);
            border-radius: 20px 20px 0 0;
        }

        .parameters-hero h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--accent-primary), #51cf66);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
        }

        .parameters-hero p {
            color: var(--text-secondary);
            font-size: 1.1rem;
            max-width: 800px;
            margin: 0 auto;
        }

        /* Filter controls */
        .filter-controls {
            background: rgba(26, 31, 58, 0.5);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .filter-group label {
            color: var(--text-primary);
            font-weight: 600;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-group input[type="text"],
        .filter-group select {
            padding: 0.875rem 1.25rem;
            border: 1px solid rgba(139, 127, 255, 0.3);
            border-radius: 12px;
            background: rgba(139, 127, 255, 0.15);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            color: #f8f9fa;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .filter-group input[type="text"]:focus,
        .filter-group select:focus {
            outline: none;
            background: rgba(139, 127, 255, 0.2);
            border-color: rgba(139, 127, 255, 0.6);
            box-shadow:
                0 0 0 3px rgba(139, 127, 255, 0.15),
                0 0 20px rgba(139, 127, 255, 0.2);
        }

        .filter-group input[type="text"]::placeholder {
            color: rgba(248, 249, 250, 0.5);
        }

        /* Statistics bar */
        .stats-bar {
            background: rgba(26, 31, 58, 0.5);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 1.5rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            display: block;
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-primary);
        }

        .stat-label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 0.25rem;
        }

        /* Category sections */
        .category-section {
            background: rgba(26, 31, 58, 0.4);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid rgba(139, 127, 255, 0.2);
            position: relative;
        }

        .category-header::before {
            content: '';
            position: absolute;
            top: -1rem;
            left: -1rem;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(139, 127, 255, 0.15) 0%, transparent 70%);
            pointer-events: none;
        }

        .category-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: capitalize;
            text-shadow: 0 0 20px rgba(139, 127, 255, 0.3);
        }

        .category-count {
            background: rgba(139, 127, 255, 0.15);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(139, 127, 255, 0.3);
            color: var(--accent-primary);
            padding: 0.35rem 0.85rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        /* Parameter cards */
        .parameter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
        }

        .parameter-card {
            background: rgba(26, 31, 58, 0.5);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 1.5rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .parameter-card:hover {
            background: rgba(26, 31, 58, 0.7);
            border-color: rgba(139, 127, 255, 0.3);
            transform: translateY(-2px) scale(1.01);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .parameter-card.filtered-out {
            display: none;
        }

        .param-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }

        .param-name {
            font-family: 'Courier New', monospace;
            font-weight: 700;
            font-size: 1rem;
            color: var(--accent-primary);
        }

        .param-status-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        .status-DERIVED {
            background: rgba(139, 127, 255, 0.15);
            border: 1px solid rgba(139, 127, 255, 0.3);
            color: #8b7fff;
        }
        .status-PREDICTED {
            background: rgba(255, 183, 77, 0.15);
            border: 1px solid rgba(255, 183, 77, 0.3);
            color: #ffb74d;
        }
        .status-INPUT {
            background: rgba(77, 182, 255, 0.15);
            border: 1px solid rgba(77, 182, 255, 0.3);
            color: #4db6ff;
        }
        .status-MEASURED {
            background: rgba(81, 207, 102, 0.15);
            border: 1px solid rgba(81, 207, 102, 0.3);
            color: #51cf66;
        }
        .status-GEOMETRIC {
            background: rgba(81, 207, 102, 0.15);
            border: 1px solid rgba(81, 207, 102, 0.3);
            color: #51cf66;
        }

        .param-symbol {
            font-size: 1.8rem;
            color: var(--text-primary);
            margin: 0.75rem 0;
            font-style: italic;
        }

        .param-value-display {
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(139, 127, 255, 0.15);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(139, 127, 255, 0.3);
            border-radius: 8px;
        }

        .param-value {
            font-family: 'Source Code Pro', monospace;
            font-size: 1.3rem;
            font-weight: 600;
            color: #f8f9fa;
        }

        .param-units {
            color: rgba(248, 249, 250, 0.7);
            font-size: 0.9rem;
            font-style: italic;
            font-weight: 500;
        }

        .param-uncertainty {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-left: 0.5rem;
        }

        .param-description {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        .param-metadata {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-primary);
            font-size: 0.85rem;
        }

        .metadata-item {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            color: var(--text-muted);
        }

        .metadata-label {
            font-weight: 600;
            color: var(--text-secondary);
        }

        .param-comparison {
            background: rgba(81, 207, 102, 0.08);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(81, 207, 102, 0.3);
            border-radius: 8px;
            padding: 0.75rem;
            margin-top: 1rem;
        }

        .comparison-header {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }

        .comparison-values {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            font-size: 0.85rem;
        }

        .comparison-item {
            display: flex;
            flex-direction: column;
        }

        .comparison-label {
            color: var(--text-muted);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .comparison-value {
            color: var(--text-primary);
            font-family: 'Source Code Pro', monospace;
            font-weight: 600;
            margin-top: 0.25rem;
        }

        .deviation-indicator {
            margin-top: 0.5rem;
            font-size: 0.8rem;
            padding: 0.35rem 0.6rem;
            border-radius: 6px;
            text-align: center;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        .deviation-good {
            background: rgba(81, 207, 102, 0.15);
            border: 1px solid rgba(81, 207, 102, 0.3);
            color: #51cf66;
        }

        .deviation-moderate {
            background: rgba(255, 183, 77, 0.15);
            border: 1px solid rgba(255, 183, 77, 0.3);
            color: #ffb74d;
        }

        .deviation-high {
            background: rgba(255, 126, 182, 0.15);
            border: 1px solid rgba(255, 126, 182, 0.3);
            color: var(--accent-secondary);
        }

        .formula-links {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-primary);
        }

        .formula-links-header {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .formula-link-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .formula-link {
            display: inline-block;
            padding: 0.35rem 0.75rem;
            background: rgba(139, 127, 255, 0.1);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            border: 1px solid rgba(139, 127, 255, 0.3);
            border-radius: 8px;
            color: var(--accent-primary);
            text-decoration: none;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .formula-link:hover {
            background: rgba(139, 127, 255, 0.2);
            border-color: rgba(139, 127, 255, 0.5);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 127, 255, 0.2);
        }

        /* Loading state */
        .loading-state {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
        }

        .loading-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(139, 127, 255, 0.2);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error-message {
            background: rgba(255, 126, 182, 0.1);
            border: 1px solid rgba(255, 126, 182, 0.3);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            color: var(--accent-secondary);
        }

        /* No results message */
        .no-results {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        /* Navigation links */
        .nav-links {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-primary);
        }

        .nav-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background: rgba(139, 127, 255, 0.1);
            border: 1px solid rgba(139, 127, 255, 0.3);
            border-radius: 10px;
            color: var(--text-primary);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            background: rgba(139, 127, 255, 0.2);
            transform: translateY(-2px);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .parameter-grid {
                grid-template-columns: 1fr;
            }

            .filter-controls {
                grid-template-columns: 1fr;
            }

            .stats-bar {
                flex-direction: column;
            }
        }
    </style>
    <script src="js/pm-constants-loader.js"></script>
</head>
<body class="auth-loading">
    <div id="main-content" style="display: none;">
    <header>
        <div class="header-content">
            <div class="site-title" style="font-size: 1.5rem; font-weight: 700; color: var(--text-primary);">
                Principia Metaphysica
            </div>
            <nav>
                <ul>
                    <li><a href="principia-metaphysica-paper.html">Home</a></li>
                    <li><a href="sections.html">Sections</a></li>
                    <li><a href="formulas.html">Formulas</a></li>
                    <li><a href="parameters.html">Parameters</a></li>
                    <li><a href="references.html">References</a></li>
                    <li><a href="foundations.html">Foundations</a></li>
                </ul>
            </nav>
        </div>

        <div class="user-controls">
            <img id="user-avatar" src="/images/default-avatar.svg" alt="User">
            <span id="user-email"></span>
            <button id="logout-btn">Logout</button>
        </div>
    </header>

    <main>
        <nav aria-label="Breadcrumb" class="breadcrumb">
            <a href="index.html">Home</a>
            <span class="separator">/</span>
            <span class="current">Theory Parameters</span>
        </nav>

        <!-- Hero Section -->
        <div class="parameters-hero">
            <h1>Theory Parameters</h1>
            <p>
                Complete reference of all theoretical parameters from Principia Metaphysica.
                Dynamically loaded from <code>AUTO_GENERATED/json/parameters.json</code> - NO hardcoded values!
            </p>
        </div>

        <!-- Statistics Bar -->
        <div class="stats-bar">
            <div class="stat-item">
                <span class="stat-value" id="stat-total">0</span>
                <span class="stat-label">Total Parameters</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="stat-visible">0</span>
                <span class="stat-label">Visible</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="stat-categories">0</span>
                <span class="stat-label">Categories</span>
            </div>
            <div class="stat-item">
                <span class="stat-value" id="stat-validated">0</span>
                <span class="stat-label">Validated</span>
            </div>
        </div>

        <!-- Filter Controls -->
        <div class="filter-controls">
            <div class="filter-group">
                <label for="search-input">Search</label>
                <input type="text" id="search-input" placeholder="Filter by name or description...">
            </div>
            <div class="filter-group">
                <label for="category-filter">Category</label>
                <select id="category-filter">
                    <option value="">All Categories</option>
                    <!-- Dynamically populated -->
                </select>
            </div>
            <div class="filter-group">
                <label for="status-filter">Status</label>
                <select id="status-filter">
                    <option value="">All Statuses</option>
                    <option value="DERIVED">Derived</option>
                    <option value="PREDICTED">Predicted</option>
                    <option value="INPUT">Input</option>
                    <option value="MEASURED">Measured</option>
                    <option value="GEOMETRIC">Geometric</option>
                </select>
            </div>
        </div>

        <!-- Loading State -->
        <div id="loading-indicator" class="loading-state">
            <div class="loading-spinner"></div>
            <p>Loading parameters from AUTO_GENERATED/json/parameters.json...</p>
        </div>

        <!-- Error State -->
        <div id="error-indicator" class="error-message" style="display: none;">
            <h3>Failed to Load Parameters</h3>
            <p id="error-message"></p>
        </div>

        <!-- Parameters Container -->
        <div id="parameters-container" style="display: none;">
            <!-- Dynamically populated category sections -->
        </div>

        <!-- No Results -->
        <div id="no-results" class="no-results" style="display: none;">
            <p>No parameters match your filter criteria.</p>
        </div>

        <!-- Navigation -->
        <div class="nav-links">
            <a class="nav-link" href="index.html">← Back to Home</a>
            <a class="nav-link" href="sections/formulas.html">View Formulas →</a>
        </div>
    </main>

    <footer>
        <p>
            <strong>Principia Metaphysica</strong><br/>
            © 2025 Andrew Keith Watts. All rights reserved.
        </p>
    </footer>
    </div>

    <script type="module">
        import { setupAuthGuard } from '/js/auth-guard.js';
        setupAuthGuard('parameters');
    </script>

    <script>
        // ====================================================================
        // PARAMETERS PAGE - Dynamic Loading from parameters.json
        // ====================================================================

        let allParameters = [];
        let parametersByCategory = {};
        let formulaDatabase = {};

        // Configuration for parameter metadata
        const CATEGORY_DISPLAY_NAMES = {
            'dimensions': 'Spacetime Dimensions',
            'topology': 'G₂ Topology',
            'dark_energy': 'Dark Energy',
            'gauge': 'Gauge Unification',
            'proton_decay': 'Proton Decay',
            'neutrino': 'Neutrino Physics',
            'pmns': 'PMNS Mixing Angles',
            'kk_spectrum': 'Kaluza-Klein Spectrum',
            'pneuma': 'Pneuma Field',
            'xy_bosons': 'X/Y Gauge Bosons',
            'mirror_sector': 'Mirror Sector',
            'higgs': 'Higgs Sector'
        };

        const PARAMETER_SYMBOLS = {
            // Dimensions
            'D_BULK': 'D_{\\text{bulk}}',
            'D_AFTER_SP2R': 'D_{\\text{Sp(2,R)}}',
            'D_INTERNAL': 'D_{\\text{int}}',
            'D_EFFECTIVE': 'D_{\\text{eff}}',
            'D_COMMON': 'D_{\\text{common}}',
            'M_PLANCK': 'M_{\\text{Pl}}',
            'M_BULK': 'M_{\\text{bulk}}',

            // Topology
            'CHI_EFF': '\\chi_{\\text{eff}}',
            'B2': 'b_2',
            'B3': 'b_3',
            'n_flux': 'N_{\\text{flux}}',
            'HODGE_H11': 'h^{1,1}',
            'HODGE_H21': 'h^{2,1}',
            'HODGE_H31': 'h^{3,1}',
            'n_gen': 'n_{\\text{gen}}',
            'chi_eff_computed': '\\chi_{\\text{eff}}^{\\text{comp}}',

            // Dark Energy
            'w0': 'w_0',
            'wa': 'w_a',
            'd_eff': 'd_{\\text{eff}}',
            'alpha_T': '\\alpha_T',

            // Gauge
            'ALPHA_GUT': '\\alpha_{\\text{GUT}}',
            'ALPHA_GUT_INV': '\\alpha_{\\text{GUT}}^{-1}',
            'M_GUT': 'M_{\\text{GUT}}',
            'WEAK_MIXING_ANGLE': '\\sin^2\\theta_W',
            'alpha_s': '\\alpha_s',

            // Proton Decay
            'tau_p_years': '\\tau_p',
            'BR_epi0': 'BR(e^+\\pi^0)',

            // PMNS
            'theta_12': '\\theta_{12}',
            'theta_23': '\\theta_{23}',
            'theta_13': '\\theta_{13}',
            'delta_CP': '\\delta_{CP}',
            'delta_cp': '\\delta_{CP}',  // lowercase variant

            // Neutrino
            'delta_m21_sq': '\\Delta m_{21}^2',
            'delta_m31_sq': '\\Delta m_{31}^2',
            'm_nu_1': 'm_{\\nu_1}',
            'm_nu_2': 'm_{\\nu_2}',
            'm_nu_3': 'm_{\\nu_3}',
            'sum_m_nu': '\\sum m_\\nu',
            'm_rh_neutrino': 'M_{\\text{RH}}',

            // KK Spectrum
            'm1_TeV': 'm_{\\text{KK}}',

            // Pneuma
            'VEV': '\\langle\\Psi_P\\rangle',

            // XY Bosons
            'M_X': 'M_X',
            'M_Y': 'M_Y',

            // Mirror Sector
            'temperature_ratio': 'T\'/T',
            'dm_baryon_ratio': '\\Omega_{\\text{DM}}/\\Omega_b',
            'modulation_width': '\\Delta_{\\text{mod}}',
            'n_sectors': 'N_{\\text{sectors}}',
            'gravity_dilution': 'f_{\\text{grav}}',

            // Higgs
            'mu': '\\mu',
            'lambda_H': '\\lambda_H',

            // Proton decay additional
            'SUPER_K_BOUND': '\\tau_p^{\\text{SK}}',
            'ratio_to_bound': '\\tau_p / \\tau_p^{\\text{SK}}',
            'suppression': 'f_{\\text{supp}}',

            // Neutrino additional
            'm_nu_1': 'm_{\\nu_1}',
            'm_nu_2': 'm_{\\nu_2}',
            'm_nu_3': 'm_{\\nu_3}',
            'sum_m_nu': '\\sum m_\\nu',
            'hierarchy': 'H_{\\nu}',

            // KK additional
            'uncertainty_TeV': '\\sigma_{m_{\\text{KK}}}',
            'LHC_BOUND_TEV': 'm_{\\text{KK}}^{\\text{LHC}}',

            // Other
            'D_SHARED_EXTRAS': 'D_{\\text{shared}}',
            'average_deviation_sigma': '\\langle\\sigma\\rangle',
            'source_version': '\\text{Version}'
        };

        const PARAMETER_DESCRIPTIONS = {
            // Dimensions
            'D_BULK': 'Bulk spacetime dimensions from bosonic string theory',
            'D_AFTER_SP2R': 'Dimensions after Sp(2,ℝ) reduction',
            'D_INTERNAL': 'Internal G₂ manifold dimensions',
            'D_EFFECTIVE': 'Effective dimensions after compactification',
            'D_COMMON': 'Common observable spacetime dimensions',
            'M_PLANCK': 'Planck mass scale',
            'M_BULK': 'Bulk Planck mass',

            // Topology
            'CHI_EFF': 'Effective Euler characteristic of G₂ manifold #187',
            'B2': 'Second Betti number (number of 2-cycles)',
            'B3': 'Third Betti number (number of 3-cycles)',
            'n_flux': 'Flux quantization number',
            'n_gen': 'Number of fermion generations',

            // Dark Energy
            'w0': 'Dark energy equation of state parameter at z=0',
            'wa': 'Dark energy evolution parameter',
            'd_eff': 'Effective dimension for dark energy',
            'alpha_T': 'Temperature coupling parameter',

            // Gauge
            'ALPHA_GUT': 'GUT coupling constant α_GUT',
            'ALPHA_GUT_INV': 'Inverse GUT coupling 1/α_GUT ≈ 23.54',
            'M_GUT': 'GUT unification scale',
            'WEAK_MIXING_ANGLE': 'Weinberg angle sin²θ_W',
            'alpha_s': 'Strong coupling at M_Z',

            // Proton Decay
            'tau_p_years': 'Predicted proton lifetime',
            'BR_epi0': 'Branching ratio for p → e⁺π⁰',

            // PMNS
            'theta_12': 'Solar neutrino mixing angle',
            'theta_23': 'Atmospheric neutrino mixing angle',
            'theta_13': 'Reactor neutrino mixing angle',
            'delta_CP': 'CP-violating phase',

            // Neutrino
            'delta_m21_sq': 'Solar mass-squared difference',
            'delta_m31_sq': 'Atmospheric mass-squared difference',
            'sum_m_nu': 'Sum of neutrino masses',
            'm_rh_neutrino': 'Right-handed Majorana neutrino mass (seesaw)',
            'm_nu_1': 'Lightest neutrino mass eigenstate',
            'm_nu_2': 'Second neutrino mass eigenstate',
            'm_nu_3': 'Heaviest neutrino mass eigenstate',
            'hierarchy': 'Neutrino mass hierarchy',

            // KK
            'm1_TeV': 'First Kaluza-Klein excitation mass',
            'uncertainty_TeV': 'KK mass uncertainty',
            'LHC_BOUND_TEV': 'LHC experimental bound',

            // Pneuma
            'VEV': 'Pneuma field vacuum expectation value',

            // XY
            'M_X': 'X gauge boson mass',
            'M_Y': 'Y gauge boson mass',

            // Mirror
            'temperature_ratio': 'Mirror sector temperature ratio',
            'dm_baryon_ratio': 'Dark matter to baryon density ratio',
            'modulation_width': 'Geometric width from G₂ cycle overlap',
            'n_sectors': 'Number of mirror sectors',
            'gravity_dilution': 'Gravitational interaction dilution factor',

            // Proton Decay
            'SUPER_K_BOUND': 'Super-Kamiokande experimental lower bound',
            'ratio_to_bound': 'Ratio of prediction to experimental bound',
            'suppression': 'Proton decay suppression factor',

            // Higgs
            'mu': 'Higgs mass parameter',
            'lambda_H': 'Higgs quartic coupling',

            // Other
            'D_SHARED_EXTRAS': 'Shared extra dimensions',
            'SIGNATURE_INITIAL': 'Initial spacetime signature',
            'SIGNATURE_BULK': 'Bulk spacetime signature',
            'chi_eff_computed': 'Computed effective Euler characteristic',
            'average_deviation_sigma': 'Average deviation from experiment',
            'source_version': 'Reference data version'
        };

        // Initialize the page
        async function initializePage() {
            try {
                // Load parameters from JSON
                const parameters = await loadParametersJSON();

                // Load formulas for cross-referencing
                await loadFormulasJSON();

                // Process and organize parameters
                processParameters(parameters);

                // Populate category filter
                populateCategoryFilter();

                // Render the parameters
                renderParameters();

                // Setup event listeners
                setupEventListeners();

                // Update statistics
                updateStatistics();

                // Hide loading, show content
                hideLoading();

            } catch (error) {
                console.error('Error initializing parameters page:', error);
                showError(error.message);
            }
        }

        async function loadParametersJSON() {
            const pathPrefixes = [
                'AUTO_GENERATED/json/',
                '../AUTO_GENERATED/json/',
                '../../AUTO_GENERATED/json/',
                ''
            ];

            for (const prefix of pathPrefixes) {
                try {
                    const path = prefix + 'parameters.json';
                    const response = await fetch(path);
                    if (response.ok) {
                        const data = await response.json();
                        console.log(`Loaded parameters from ${path}`);
                        console.log(`Version: ${data.version}`);
                        return data;
                    }
                } catch (e) {
                    continue;
                }
            }

            throw new Error('Could not load AUTO_GENERATED/json/parameters.json. Please run: python run_all_simulations.py --export');
        }

        async function loadFormulasJSON() {
            const pathPrefixes = [
                'AUTO_GENERATED/json/',
                '../AUTO_GENERATED/json/',
                '../../AUTO_GENERATED/json/',
                ''
            ];

            for (const prefix of pathPrefixes) {
                try {
                    const path = prefix + 'formulas.json';
                    const response = await fetch(path);
                    if (response.ok) {
                        const data = await response.json();
                        formulaDatabase = data.formulas || {};
                        console.log(`Loaded ${Object.keys(formulaDatabase).length} formulas`);
                        return;
                    }
                } catch (e) {
                    continue;
                }
            }

            console.warn('Could not load formulas.json - formula links will be unavailable');
        }

        function processParameters(data) {
            allParameters = [];
            parametersByCategory = {};

            // Iterate through all categories in the JSON
            for (const [category, params] of Object.entries(data)) {
                if (category === 'version') continue;

                parametersByCategory[category] = [];

                // Handle nested parameters
                processCategory(category, params);
            }

            console.log(`Processed ${allParameters.length} parameters across ${Object.keys(parametersByCategory).length} categories`);
        }

        function processCategory(category, params, parentKey = '') {
            for (const [key, value] of Object.entries(params)) {
                const fullKey = parentKey ? `${parentKey}.${key}` : key;

                // If value is a simple parameter (number, string) or has standard fields
                if (isParameter(value)) {
                    const param = createParameter(category, fullKey, value);
                    allParameters.push(param);
                    parametersByCategory[category].push(param);
                } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                    // Recursively process nested objects
                    processCategory(category, value, fullKey);
                }
            }
        }

        function isParameter(value) {
            // A parameter is either a primitive value or an object with specific fields
            if (typeof value !== 'object' || value === null) {
                return typeof value === 'number' || typeof value === 'string';
            }

            // Arrays are always parameters (like SIGNATURE_INITIAL)
            if (Array.isArray(value)) {
                return true;
            }

            // Check for common parameter field patterns
            const paramFields = ['value', 'predicted', 'experimental', 'units', 'status', 'description', 'derivation', 'source'];
            const hasParamField = paramFields.some(field => field in value);

            // If it has parameter fields, it's a parameter
            if (hasParamField) {
                return true;
            }

            // Check if all children are primitive values (like mass_spectrum with m_nu_1, m_nu_2, etc.)
            const values = Object.values(value);
            if (values.length > 0) {
                const allPrimitive = values.every(v =>
                    typeof v === 'number' ||
                    typeof v === 'string' ||
                    typeof v === 'boolean'
                );
                // If it has a mix of primitive values and metadata fields, treat as parameter group
                if (allPrimitive || (values.some(v => typeof v === 'number') && hasParamField)) {
                    return false; // This is a container, not a parameter
                }
            }

            return false;
        }

        function createParameter(category, key, value) {
            const displayName = formatParameterName(key);

            // Try full key first, then just the last part after the dot
            const keyParts = key.split('.');
            const lastKey = keyParts[keyParts.length - 1];
            const symbol = PARAMETER_SYMBOLS[key] || PARAMETER_SYMBOLS[lastKey] || '';

            let paramValue, units, status, description, experimental, predicted, uncertainty, derivation, source;
            let observed, observedUncertainty, deviationPercent, sigmaAgreement;

            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                // Extract primary value in order of preference
                paramValue = value.value ?? value.predicted ?? value.experimental ?? value.observed ?? null;

                // If no explicit value field and object has numeric properties, it might be a composite
                if (paramValue === null) {
                    // Check if this is a pure container (shouldn't happen but just in case)
                    paramValue = value;
                }

                units = value.units || '';
                status = value.status || 'DERIVED';
                description = value.description || value.derivation || PARAMETER_DESCRIPTIONS[key] || PARAMETER_DESCRIPTIONS[lastKey] || '';
                experimental = value.experimental;
                predicted = value.predicted;
                observed = value.observed;
                observedUncertainty = value.observed_uncertainty || value.experimental_error;
                uncertainty = value.predicted_error || value.experimental_error || value.uncertainty;
                derivation = value.derivation;
                source = value.source;
                deviationPercent = value.deviation_percent;
                sigmaAgreement = value.sigma_agreement;
            } else {
                // Primitive value (number, string, or array)
                paramValue = value;
                units = inferUnits(key);
                status = 'GEOMETRIC';
                description = PARAMETER_DESCRIPTIONS[key] || PARAMETER_DESCRIPTIONS[lastKey] || '';
            }

            return {
                category,
                key,
                displayName,
                symbol,
                value: paramValue,
                displayValue: formatValue(paramValue),
                units,
                status,
                description,
                experimental,
                predicted,
                observed,
                observedUncertainty,
                uncertainty,
                derivation,
                source,
                deviationPercent,
                sigmaAgreement,
                relatedFormulas: findRelatedFormulas(key)
            };
        }

        function formatParameterName(key) {
            // Handle dot notation - show full path for nested parameters
            const parts = key.split('.');

            if (parts.length > 1) {
                // For nested parameters, show the full path in a readable way
                return parts.map(part =>
                    part
                        .replace(/_/g, ' ')
                        .replace(/([A-Z])/g, ' $1')
                        .trim()
                        .split(' ')
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                        .join(' ')
                ).join(' → ');
            }

            // For top-level parameters, just format the name
            return key
                .replace(/_/g, ' ')
                .replace(/([A-Z])/g, ' $1')
                .trim()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ');
        }

        function formatValue(value) {
            if (value === null || value === undefined) return '—';
            if (typeof value === 'boolean') return value ? 'Yes' : 'No';
            if (Array.isArray(value)) return value.join(', ');

            if (typeof value === 'number') {
                const abs = Math.abs(value);
                if (abs === 0) return '0';
                if (abs >= 1e10 || (abs < 0.001 && abs > 0)) {
                    return value.toExponential(3);
                } else if (Number.isInteger(value)) {
                    return value.toLocaleString();
                } else {
                    return value.toPrecision(4);
                }
            }

            return String(value);
        }

        function inferUnits(key) {
            const unitPatterns = {
                '_TeV': 'TeV',
                '_GeV': 'GeV',
                '_eV': 'eV',
                '_years': 'years',
                'theta_': 'degrees',
                'delta_CP': 'degrees',
                'alpha_': 'dimensionless',
                'm_': 'GeV',
                'M_': 'GeV',
                'tau_': 'years'
            };

            for (const [pattern, unit] of Object.entries(unitPatterns)) {
                if (key.includes(pattern)) return unit;
            }

            return '';
        }

        function findRelatedFormulas(paramKey) {
            const related = [];
            const keyParts = paramKey.split('.');
            const lastKey = keyParts[keyParts.length - 1];

            for (const [formulaId, formula] of Object.entries(formulaDatabase)) {
                // Check if parameter appears in formula terms
                // Try both full key and last part
                if (formula.terms && (paramKey in formula.terms || lastKey in formula.terms)) {
                    related.push({
                        id: formulaId,
                        label: formula.label || formulaId,
                        section: formula.section
                    });
                }
            }

            return related;
        }

        function populateCategoryFilter() {
            const select = document.getElementById('category-filter');

            for (const category of Object.keys(parametersByCategory)) {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = CATEGORY_DISPLAY_NAMES[category] || category;
                select.appendChild(option);
            }
        }

        function renderParameters() {
            const container = document.getElementById('parameters-container');
            container.innerHTML = '';

            // Render each category
            for (const [category, params] of Object.entries(parametersByCategory)) {
                if (params.length === 0) continue;

                const section = renderCategorySection(category, params);
                container.appendChild(section);
            }

            // Trigger MathJax rendering
            if (window.MathJax) {
                MathJax.typesetPromise();
            }
        }

        function renderCategorySection(category, params) {
            const section = document.createElement('div');
            section.className = 'category-section';
            section.dataset.category = category;

            const header = document.createElement('div');
            header.className = 'category-header';
            header.innerHTML = `
                <h2 class="category-title">${CATEGORY_DISPLAY_NAMES[category] || category}</h2>
                <span class="category-count">${params.length} parameters</span>
            `;
            section.appendChild(header);

            const grid = document.createElement('div');
            grid.className = 'parameter-grid';

            params.forEach(param => {
                const card = renderParameterCard(param);
                grid.appendChild(card);
            });

            section.appendChild(grid);
            return section;
        }

        function renderParameterCard(param) {
            const card = document.createElement('div');
            card.className = 'parameter-card';
            card.dataset.category = param.category;
            card.dataset.status = param.status;
            card.dataset.key = param.key;

            let html = `
                <div class="param-header">
                    <div class="param-name">${param.key}</div>
                    <span class="param-status-badge status-${param.status}">${param.status}</span>
                </div>
            `;

            if (param.symbol) {
                html += `<div class="param-symbol">$${param.symbol}$</div>`;
            }

            html += `
                <div class="param-value-display">
                    <span class="param-value">${param.displayValue}</span>
                    ${param.units ? `<span class="param-units">${param.units}</span>` : ''}
                    ${param.uncertainty ? `<span class="param-uncertainty">± ${formatValue(param.uncertainty)}</span>` : ''}
                </div>
            `;

            if (param.description) {
                html += `<div class="param-description">${param.description}</div>`;
            }

            // Show comparison if both predicted and experimental/observed exist
            if (param.predicted !== undefined && (param.experimental !== undefined || param.observed !== undefined)) {
                const comparisonValue = param.experimental ?? param.observed;
                const comparisonLabel = param.experimental !== undefined ? 'Experimental' : 'Observed';

                // Use provided sigma if available, otherwise calculate
                let deviation, deviationText;
                if (param.sigmaAgreement !== undefined) {
                    deviation = param.sigmaAgreement;
                    deviationText = `${deviation.toFixed(1)}σ`;
                } else if (param.deviationPercent !== undefined) {
                    deviation = param.deviationPercent / 10; // Rough estimate
                    deviationText = `${param.deviationPercent.toFixed(1)}% deviation`;
                } else {
                    deviation = calculateDeviation(param.predicted, comparisonValue);
                    deviationText = `${deviation.toFixed(1)}σ`;
                }

                const deviationClass = deviation < 1 ? 'deviation-good' : deviation < 3 ? 'deviation-moderate' : 'deviation-high';

                html += `
                    <div class="param-comparison">
                        <div class="comparison-header">Theoretical vs ${comparisonLabel}</div>
                        <div class="comparison-values">
                            <div class="comparison-item">
                                <span class="comparison-label">Predicted</span>
                                <span class="comparison-value">${formatValue(param.predicted)}</span>
                            </div>
                            <div class="comparison-item">
                                <span class="comparison-label">${comparisonLabel}</span>
                                <span class="comparison-value">${formatValue(comparisonValue)}</span>
                            </div>
                        </div>
                        <div class="deviation-indicator ${deviationClass}">
                            ${deviation < 1 ? '✓ Excellent agreement' : deviation < 3 ? '~ Good agreement' : '⚠ Moderate agreement'} (${deviationText})
                        </div>
                    </div>
                `;
            }

            // Metadata
            const metadata = [];
            if (param.derivation) metadata.push(`<span class="metadata-item"><span class="metadata-label">Derivation:</span> ${param.derivation}</span>`);
            if (param.source) metadata.push(`<span class="metadata-item"><span class="metadata-label">Source:</span> ${param.source}</span>`);

            if (metadata.length > 0) {
                html += `<div class="param-metadata">${metadata.join('')}</div>`;
            }

            // Related formulas
            if (param.relatedFormulas && param.relatedFormulas.length > 0) {
                html += `
                    <div class="formula-links">
                        <div class="formula-links-header">Used in formulas:</div>
                        <div class="formula-link-list">
                            ${param.relatedFormulas.map(f =>
                                `<a href="sections/formulas.html#${f.id}" class="formula-link">${f.label}</a>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }

            card.innerHTML = html;
            return card;
        }

        function calculateDeviation(predicted, experimental) {
            // Simple sigma calculation (would need uncertainty for proper calculation)
            const diff = Math.abs(predicted - experimental);
            const avg = (Math.abs(predicted) + Math.abs(experimental)) / 2;
            return avg > 0 ? (diff / avg) * 10 : 0; // Rough estimate
        }

        function setupEventListeners() {
            // Search
            document.getElementById('search-input').addEventListener('input', applyFilters);

            // Filters
            document.getElementById('category-filter').addEventListener('change', applyFilters);
            document.getElementById('status-filter').addEventListener('change', applyFilters);
        }

        function applyFilters() {
            const searchText = document.getElementById('search-input').value.toLowerCase();
            const categoryFilter = document.getElementById('category-filter').value;
            const statusFilter = document.getElementById('status-filter').value;

            const cards = document.querySelectorAll('.parameter-card');
            let visibleCount = 0;

            cards.forEach(card => {
                const category = card.dataset.category;
                const status = card.dataset.status;
                const key = card.dataset.key;
                const param = allParameters.find(p => p.key === key && p.category === category);

                let visible = true;

                // Search filter
                if (searchText) {
                    const matchKey = key.toLowerCase().includes(searchText);
                    const matchDesc = param?.description?.toLowerCase().includes(searchText) || false;
                    const matchCategory = category.toLowerCase().includes(searchText);
                    visible = visible && (matchKey || matchDesc || matchCategory);
                }

                // Category filter
                if (categoryFilter && category !== categoryFilter) {
                    visible = false;
                }

                // Status filter
                if (statusFilter && status !== statusFilter) {
                    visible = false;
                }

                if (visible) {
                    card.classList.remove('filtered-out');
                    visibleCount++;
                } else {
                    card.classList.add('filtered-out');
                }
            });

            // Hide empty category sections
            document.querySelectorAll('.category-section').forEach(section => {
                const visibleCards = section.querySelectorAll('.parameter-card:not(.filtered-out)');
                section.style.display = visibleCards.length > 0 ? 'block' : 'none';
            });

            // Update visible count
            document.getElementById('stat-visible').textContent = visibleCount;

            // Show/hide no results
            document.getElementById('no-results').style.display = visibleCount === 0 ? 'block' : 'none';
        }

        function updateStatistics() {
            const total = allParameters.length;
            const categories = Object.keys(parametersByCategory).length;
            const validated = allParameters.filter(p =>
                p.experimental !== undefined ||
                p.observed !== undefined ||
                p.status === 'MEASURED' ||
                p.status === 'INPUT'
            ).length;

            document.getElementById('stat-total').textContent = total;
            document.getElementById('stat-visible').textContent = total;
            document.getElementById('stat-categories').textContent = categories;
            document.getElementById('stat-validated').textContent = validated;
        }

        function hideLoading() {
            document.getElementById('loading-indicator').style.display = 'none';
            document.getElementById('parameters-container').style.display = 'block';
        }

        function showError(message) {
            document.getElementById('loading-indicator').style.display = 'none';
            document.getElementById('error-indicator').style.display = 'block';
            document.getElementById('error-message').textContent = message;
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializePage);
        } else {
            initializePage();
        }
    </script>
</body>
</html>
