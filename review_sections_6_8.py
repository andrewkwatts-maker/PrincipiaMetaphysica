"""
Review Sections 6-8 and Appendices of Principia Metaphysica
===========================================================
Comprehensive analysis for accuracy and schema compliance.
"""

import json
from pathlib import Path
import re

def load_theory():
    """Load theory_output.json"""
    with open(r'h:\Github\PrincipiaMetaphysica\AutoGenerated\theory_output.json', encoding='utf-8') as f:
        return json.load(f)

def extract_section_content(section):
    """Extract all content from a section"""
    content_blocks = section.get('contentBlocks', section.get('content_blocks', []))

    paragraphs = []
    for block in content_blocks:
        if block.get('type') == 'paragraph':
            # Try both 'content' and 'text' fields
            text = block.get('content', block.get('text', ''))
            paragraphs.append(text)

    return {
        'id': section.get('id'),
        'title': section.get('title'),
        'abstract': section.get('abstract', ''),
        'paragraphs': paragraphs,
        'formula_refs': section.get('formulaRefs', section.get('formula_refs', [])),
        'param_refs': section.get('paramRefs', section.get('param_refs', []))
    }

def check_simulation_references(content_text):
    """Check for simulation file references"""
    simulations = []

    # Common simulation patterns
    patterns = [
        r'unity_test',
        r'topological_uniqueness',
        r'orch_or',
        r'quantum_bio',
        r'simulations/v16',
        r'tests/',
        r'\.py'
    ]

    for pattern in patterns:
        if re.search(pattern, content_text, re.IGNORECASE):
            simulations.append(pattern)

    return simulations

def check_proof_references(content_text):
    """Check for formal proof references"""
    proof_refs = []

    patterns = [
        r'formal_proof',
        r'proof_indices',
        r'wolfram',
        r'mathematica',
        r'35 proofs',
        r'proof \d+',
        r'Appendix'
    ]

    for pattern in patterns:
        matches = re.findall(pattern, content_text, re.IGNORECASE)
        if matches:
            proof_refs.extend(matches)

    return proof_refs

def analyze_section_6(theory):
    """Analyze Section 6: Predictions"""
    section = theory['sections']['6']
    content = extract_section_content(section)

    full_text = content['abstract'] + ' ' + ' '.join(content['paragraphs'])

    analysis = {
        'section_id': '6',
        'title': content['title'],
        'has_abstract': bool(content['abstract']),
        'paragraph_count': len(content['paragraphs']),
        'formula_refs_count': len(content['formula_refs']),
        'param_refs_count': len(content['param_refs']),
        'simulation_references': check_simulation_references(full_text),
        'mentions_unity_test': 'unity_test' in full_text.lower() or 'falsifiability' in full_text.lower(),
        'mentions_uniqueness': 'uniqueness' in full_text.lower() or 'topological' in full_text.lower(),
        'mentions_orch_or': 'orch' in full_text.lower() or 'consciousness' in full_text.lower(),
        'content_sample': full_text[:500] if full_text else 'NO CONTENT'
    }

    return analysis

def analyze_section_7(theory):
    """Analyze Section 7: Discussion"""
    section = theory['sections']['7']
    content = extract_section_content(section)

    full_text = content['abstract'] + ' ' + ' '.join(content['paragraphs'])

    analysis = {
        'section_id': '7',
        'title': content['title'],
        'has_abstract': bool(content['abstract']),
        'paragraph_count': len(content['paragraphs']),
        'formula_refs_count': len(content['formula_refs']),
        'param_refs_count': len(content['param_refs']),
        'content_sample': full_text[:500] if full_text else 'NO CONTENT'
    }

    return analysis

def analyze_section_8(theory):
    """Analyze Section 8: Conclusion"""
    section = theory['sections']['8']
    content = extract_section_content(section)

    full_text = content['abstract'] + ' ' + ' '.join(content['paragraphs'])

    # Check for computed values
    computed_values = {
        'alpha': re.search(r'137\.03[0-9]*', full_text),
        'mass_ratio': re.search(r'1836\.[0-9]*', full_text),
        'b3': re.search(r'b3\s*=\s*24', full_text, re.IGNORECASE),
        'k_gimel': 'k_gimel' in full_text or 'gimel' in full_text.lower(),
        'c_kaf': 'c_kaf' in full_text or 'kaf' in full_text.lower()
    }

    analysis = {
        'section_id': '8',
        'title': content['title'],
        'has_abstract': bool(content['abstract']),
        'paragraph_count': len(content['paragraphs']),
        'formula_refs_count': len(content['formula_refs']),
        'param_refs_count': len(content['param_refs']),
        'computed_values_mentioned': {k: bool(v) for k, v in computed_values.items()},
        'content_sample': full_text[:500] if full_text else 'NO CONTENT'
    }

    return analysis

def analyze_appendices(theory):
    """Analyze all appendices (A-N)"""
    appendix_ids = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N']

    appendices = []
    for app_id in appendix_ids:
        if app_id in theory['sections']:
            section = theory['sections'][app_id]
            content = extract_section_content(section)

            full_text = content['abstract'] + ' ' + ' '.join(content['paragraphs'])

            appendices.append({
                'id': app_id,
                'title': content['title'],
                'has_content': len(full_text) > 0,
                'proof_references': check_proof_references(full_text),
                'mentions_formal_proof_indices': 'formal_proof_indices' in full_text.lower(),
                'mentions_wolfram': 'wolfram' in full_text.lower(),
                'mentions_35_proofs': '35' in full_text or 'thirty-five' in full_text.lower(),
                'mentions_unity_test': 'unity' in full_text.lower() and 'test' in full_text.lower(),
                'content_length': len(full_text)
            })

    return appendices

def check_schema_compliance(theory):
    """Check overall schema compliance"""
    issues = []

    # Check required top-level keys
    required_keys = ['metadata', 'sections', 'formulas', 'parameters']
    for key in required_keys:
        if key not in theory:
            issues.append(f"Missing required key: {key}")

    # Check sections 6-8 exist
    for sec_id in ['6', '7', '8']:
        if sec_id not in theory['sections']:
            issues.append(f"Missing Section {sec_id}")

    # Check appendices
    appendix_count = sum(1 for k in theory['sections'].keys() if k.isalpha())

    return {
        'compliant': len(issues) == 0,
        'issues': issues,
        'appendix_count': appendix_count
    }

def generate_report():
    """Generate comprehensive review report"""
    print("Loading theory_output.json...")
    theory = load_theory()

    print("Analyzing Section 6...")
    sec6 = analyze_section_6(theory)

    print("Analyzing Section 7...")
    sec7 = analyze_section_7(theory)

    print("Analyzing Section 8...")
    sec8 = analyze_section_8(theory)

    print("Analyzing Appendices...")
    appendices = analyze_appendices(theory)

    print("Checking schema compliance...")
    schema = check_schema_compliance(theory)

    report = {
        'review_timestamp': '2025-12-29',
        'schema_compliance': schema,
        'section_6_predictions': sec6,
        'section_7_discussion': sec7,
        'section_8_conclusion': sec8,
        'appendices': appendices,
        'verification_files_checked': [
            'unity_test_v16.py',
            'topological_uniqueness_lock.py',
            'orch_or_geometry_v16_1.py'
        ],
        'recommendations': []
    }

    # Generate recommendations
    if not sec6['mentions_unity_test']:
        report['recommendations'].append({
            'section': '6',
            'type': 'MISSING_REFERENCE',
            'message': 'Section 6 should reference unity_test_v16.py for falsifiability'
        })

    if not sec6['mentions_uniqueness']:
        report['recommendations'].append({
            'section': '6',
            'type': 'MISSING_REFERENCE',
            'message': 'Section 6 should reference topological_uniqueness_lock.py'
        })

    if not sec6['mentions_orch_or']:
        report['recommendations'].append({
            'section': '6',
            'type': 'MISSING_REFERENCE',
            'message': 'Section 6 should reference orch_or_geometry_v16_1.py'
        })

    # Check appendices for formal proofs
    formal_proof_mentioned = any(app['mentions_formal_proof_indices'] for app in appendices)
    if not formal_proof_mentioned:
        report['recommendations'].append({
            'section': 'Appendices',
            'type': 'MISSING_REFERENCE',
            'message': 'Appendices should reference formal_proof_indices.json (35 proofs)'
        })

    wolfram_mentioned = any(app['mentions_wolfram'] for app in appendices)
    if not wolfram_mentioned:
        report['recommendations'].append({
            'section': 'Appendices',
            'type': 'MISSING_REFERENCE',
            'message': 'Appendices should mention Wolfram verification'
        })

    # Save report
    output_path = Path(__file__).parent / 'SECTION_6_8_REVIEW_REPORT.json'
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(report, f, indent=2, ensure_ascii=False)

    print(f"\nReport saved to: {output_path}")

    # Print summary
    print("\n" + "="*60)
    print(" REVIEW SUMMARY")
    print("="*60)
    print(f"Section 6: {sec6['title']}")
    print(f"  - Paragraphs: {sec6['paragraph_count']}")
    print(f"  - Formula refs: {sec6['formula_refs_count']}")
    print(f"  - Unity test mentioned: {sec6['mentions_unity_test']}")
    print(f"  - Uniqueness mentioned: {sec6['mentions_uniqueness']}")
    print(f"  - Orch-OR mentioned: {sec6['mentions_orch_or']}")

    print(f"\nSection 7: {sec7['title']}")
    print(f"  - Paragraphs: {sec7['paragraph_count']}")
    print(f"  - Formula refs: {sec7['formula_refs_count']}")

    print(f"\nSection 8: {sec8['title']}")
    print(f"  - Paragraphs: {sec8['paragraph_count']}")
    print(f"  - Formula refs: {sec8['formula_refs_count']}")
    print(f"  - Computed values mentioned:")
    for key, val in sec8['computed_values_mentioned'].items():
        print(f"    - {key}: {val}")

    print(f"\nAppendices: {len(appendices)} found")
    for app in appendices:
        print(f"  - Appendix {app['id']}: {app['title'][:50]}...")

    print(f"\nRecommendations: {len(report['recommendations'])}")
    for rec in report['recommendations']:
        print(f"  - [{rec['section']}] {rec['message']}")

    print("="*60)

    return report

if __name__ == "__main__":
    generate_report()
