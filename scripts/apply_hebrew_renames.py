#!/usr/bin/env python3
"""
Apply Hebrew Renames Script
===========================
Applies the Hebrew-Scientific naming scheme to FormulasRegistry.py
while preserving backward compatibility through aliases.

Strategy:
1. Add new canonical names (e.g., elder_vessels)
2. Keep old names as aliases pointing to new names
3. Update GNOSTIC_MAP with new entries
4. AutoGenerated files will be updated on next regeneration

Usage: python scripts/apply_hebrew_renames.py [--dry-run]
"""

import argparse
import re
from pathlib import Path

# Project root
ROOT = Path(__file__).parent.parent

# The rename mapping: old_name -> (new_name, gematria, hebrew, gnostic_alias)
RENAMES = {
    # Code Variable -> (New Name, Gematria, Hebrew Symbol, Gnostic Alias, Role)
    'watts_constant': ('monad_unity', 1, 'Aleph', 'The Monad', 'Absolute unity anchor'),
    'decad': ('residual_key', 10, 'Yod', 'The Hand', 'Core flux residual'),
    # syzygy_gap stays the same
    'b3': ('governing_elder_kad', 24, 'Kad', 'Elder Vessels', 'G2 cycle container'),
    'horos': ('horos_limit', 27, 'Kaz', 'The Boundary', 'Ancestral higher-D limit'),
    'chi_eff': ('mephorash_chi', 72, 'Av', 'Shem HaMephorash', 'chi_eff generations'),
    'shadow_sector': ('demiurgic_Yetts', 135, 'Kalah', 'Demiurge Gates', 'Normal entry portals'),
    'christ_constant': ('logos_joint', 153, '153', 'Logos Joint', 'Bridge identity closure'),
    'delta_jc': ('logos_joint', 153, '153', 'Logos Joint', 'Bridge identity closure'),
    'odowd_bulk_pressure': ('sophian_pressure', 163, '163', 'Sophia Pressure', 'Higher-D stabilizer'),
    'sterile_sector': ('sophian_pressure', 163, '163', 'Sophia Pressure', 'Higher-D stabilizer'),
    'roots_total': ('nitzotzin_roots', 288, '288', 'Nitzotzin Roots', 'Ancestral sparks'),
    'central_pair': ('reid_pair', 200, 'Resh', 'Reid Pair', 'Central (2,0) averager'),
    'central_pair_weight': ('watts_weight', 261, 'Resh-Phi', 'Watts Weight', 'Central averaging'),
    'central_activation_threshold': ('gnosis_threshold', 9, 'Tet', 'The Threshold', 'Central activates n>=9'),
}

# New HEBREW_SYMBOL_REGISTRY to add
HEBREW_REGISTRY = '''
    # ===========================================================================
    # HEBREW SYMBOL REGISTRY (v23.1 - Scientific-Hebrew Synthesis)
    # ===========================================================================
    # Maps parameters to their Hebrew letter equivalents via gematria.
    # These are display names - code variables remain stable for compatibility.
    #
    # TOPOLOGICAL INVARIANTS:
    # Value | Code Variable    | Hebrew   | Gematria | Gnostic Alias
    # ------|------------------|----------|----------|---------------
    # 1     | monad_unity      | Aleph    | 1        | The Monad
    # 10    | residual_key     | Yod      | 10       | The Hand
    # 18    | syzygy_gap       | Chai     | 18       | The Life
    # 24    | elder_vessels    | Kad      | 24       | Elder Vessels
    # 27    | horos_limit      | Kaz      | 27       | The Boundary
    # 72    | mephorash_chi    | Av       | 72       | Shem HaMephorash
    # 135   | demiurgic_gates  | Kalah    | 135      | Demiurge Gates
    # 153   | logos_joint      | 153      | 153      | Logos Joint
    # 163   | sophian_pressure | 163      | 163      | Sophia Pressure
    # 288   | nitzotzin_roots  | 288      | 288      | Nitzotzin Roots
    #
    # CENTRAL SAMPLER:
    # Value | Code Variable    | Hebrew   | Gematria | Gnostic Alias
    # ------|------------------|----------|----------|---------------
    # 1     | reid_pair        | Resh     | 200      | Reid Pair
    # phi/12| watts_weight     | Resh-Phi | ~261     | Watts Weight
    # 9     | gnosis_threshold | Tet      | 9        | The Threshold
    # ===========================================================================
    HEBREW_SYMBOL_REGISTRY = {
        # Topological Invariants
        "monad_unity": {"hebrew": "Aleph", "gematria": 1, "value": 1.0},
        "residual_key": {"hebrew": "Yod", "gematria": 10, "value": 10},
        "syzygy_gap": {"hebrew": "Chai", "gematria": 18, "value": 18},
        "governing_elder_kad": {"hebrew": "Kad", "gematria": 24, "value": 24},
        "horos_limit": {"hebrew": "Kaz", "gematria": 27, "value": 27},
        "mephorash_chi": {"hebrew": "Av", "gematria": 72, "value": 72},
        "demiurgic_Yetts": {"hebrew": "Kalah", "gematria": 135, "value": 135},
        "logos_joint": {"hebrew": "153", "gematria": 153, "value": 153},
        "sophian_pressure": {"hebrew": "163", "gematria": 163, "value": 163},
        "nitzotzin_roots": {"hebrew": "288", "gematria": 288, "value": 288},
        # Central Sampler
        "reid_pair": {"hebrew": "Resh", "gematria": 200, "value": 1},
        "watts_weight": {"hebrew": "Resh-Phi", "gematria": 261, "value": "phi/sqrt(12)"},
        "gnosis_threshold": {"hebrew": "Tet", "gematria": 9, "value": 9},
    }
'''


def preview_changes():
    """Preview changes without applying them."""
    print("=" * 80)
    print(" HEBREW RENAME PREVIEW")
    print("=" * 80)
    print("\nProposed renames in FormulasRegistry.py:\n")

    for old_name, (new_name, gematria, hebrew, gnostic, role) in RENAMES.items():
        print(f"  {old_name:30s} -> {new_name}")
        print(f"    Hebrew: {hebrew} ({gematria}), Gnostic: {gnostic}")
        print()

    print("\nStrategy:")
    print("  1. Add HEBREW_SYMBOL_REGISTRY to FormulasRegistry.py")
    print("  2. Add new property aliases (new names point to old internal vars)")
    print("  3. Keep old properties for backward compatibility")
    print("  4. Update GNOSTIC_MAP with new entries")
    print("\nThis preserves all existing code while adding new nomenclature.")


def apply_changes(dry_run: bool = True):
    """Apply the Hebrew naming changes to FormulasRegistry.py."""

    registry_path = ROOT / "core" / "FormulasRegistry.py"

    if not registry_path.exists():
        print(f"ERROR: {registry_path} not found!")
        return False

    with open(registry_path, 'r', encoding='utf-8') as f:
        content = f.read()

    original_content = content
    changes_made = []

    # 1. Add HEBREW_SYMBOL_REGISTRY after GNOSTIC_MAP
    if 'HEBREW_SYMBOL_REGISTRY' not in content:
        # Find the end of GNOSTIC_MAP
        gnostic_map_end = content.find('    }', content.find('GNOSTIC_MAP = {'))
        if gnostic_map_end > 0:
            # Find the next newline after the closing brace
            insert_pos = content.find('\n', gnostic_map_end + 5)
            if insert_pos > 0:
                content = content[:insert_pos] + '\n' + HEBREW_REGISTRY + content[insert_pos:]
                changes_made.append("Added HEBREW_SYMBOL_REGISTRY")

    # 2. Add new GNOSTIC_MAP entries for new names
    gnostic_additions = {
        'monad_unity': 'The Monad',
        'residual_key': 'The Hand',
        'governing_elder_kad': 'Elder Vessels',
        'horos_limit': 'The Boundary',
        'mephorash_chi': 'Shem HaMephorash',
        'demiurgic_Yetts': 'Demiurge Gates',
        'logos_joint': 'Logos Joint',
        'sophian_pressure': 'Sophia Pressure',
        'nitzotzin_roots': 'Nitzotzin Roots',
        'reid_pair': 'Reid Pair',
        'watts_weight': 'Watts Weight',
        'gnosis_threshold': 'The Threshold',
    }

    # Find GNOSTIC_MAP and add entries
    for new_name, gnostic_alias in gnostic_additions.items():
        entry = f'        "{new_name}": "{gnostic_alias}",'
        if f'"{new_name}"' not in content:
            # Find a good insertion point in GNOSTIC_MAP
            pattern = r'(GNOSTIC_MAP = \{[^}]*?"syzygy_gap": "[^"]*",)'
            match = re.search(pattern, content, re.DOTALL)
            if match:
                insert_point = match.end()
                content = content[:insert_point] + f'\n{entry}' + content[insert_point:]
                changes_made.append(f"Added GNOSTIC_MAP entry: {new_name}")

    # 3. Add property aliases in the class
    # We'll add them after the existing properties

    alias_properties = '''
    # ===========================================================================
    # HEBREW NAMING ALIASES (v23.1 - Backward Compatible)
    # ===========================================================================
    # These aliases map the new Hebrew-scientific names to existing properties.
    # Old code continues to work; new code can use either naming scheme.

    @property
    def monad_unity(self) -> float:
        """Observer Unity (1.0) - Hebrew: Aleph (1)."""
        return self.watts_constant

    @property
    def residual_key(self) -> int:
        """Residual Pressure Key (10) - Hebrew: Yod (10)."""
        return self.decad

    @property
    def elder_vessels(self) -> int:
        """Third Betti Number b3 (24) - Hebrew: Kad (24)."""
        return self.b3

    @property
    def horos_limit(self) -> int:
        """Bulk Boundary Dimension (27) - Hebrew: Kaz (27)."""
        return self.horos

    @property
    def mephorash_chi(self) -> int:
        """Triality Euler Index (72) - Hebrew: Av (72)."""
        return self.chi_eff

    @property
    def demiurgic_gates(self) -> int:
        """Visible Sector Gates (135) - Hebrew: Kalah (135)."""
        return self.shadow_sector

    @property
    def logos_joint(self) -> int:
        """Joint Identity Constant (153) - Hebrew: 153."""
        return self.christ_constant

    @property
    def sophian_pressure(self) -> int:
        """Ancestral Bulk Pressure (163) - Hebrew: 163."""
        return self.odowd_bulk_pressure

    @property
    def nitzotzin_roots(self) -> int:
        """Ancestral Root Structure (288) - Hebrew: 288."""
        return self.roots_total

    @property
    def reid_pair(self) -> int:
        """Central Sampler Count (1) - Hebrew: Resh (200)."""
        return self.central_pair

    @property
    def watts_weight(self) -> float:
        """Sampler Dilution Coupling (phi/sqrt(12)) - Hebrew: Resh-Phi."""
        return self.central_pair_weight

    @property
    def gnosis_threshold(self) -> int:
        """Activation Threshold (9) - Hebrew: Tet (9)."""
        return self.central_activation_threshold
'''

    # Find a good place to insert the aliases (before the manifest methods)
    if 'monad_unity' not in content or '@property' not in content[content.find('monad_unity'):content.find('monad_unity')+100]:
        # Find the manifest method
        manifest_pos = content.find('def get_manifest(')
        if manifest_pos > 0:
            # Insert before it
            content = content[:manifest_pos] + alias_properties + '\n    ' + content[manifest_pos:]
            changes_made.append("Added Hebrew naming alias properties")

    if dry_run:
        print("\n" + "=" * 80)
        print(" DRY RUN - Changes that would be made:")
        print("=" * 80)
        for change in changes_made:
            print(f"  - {change}")
        print("\nRun with --apply to make changes.")
        return True
    else:
        # Write changes
        with open(registry_path, 'w', encoding='utf-8') as f:
            f.write(content)

        print("\n" + "=" * 80)
        print(" CHANGES APPLIED")
        print("=" * 80)
        for change in changes_made:
            print(f"  [OK] {change}")

        print(f"\nModified: {registry_path}")
        print("\nNext steps:")
        print("  1. Run: python run_all_simulations.py --skip-guard")
        print("  2. Review the regenerated AutoGenerated/ files")
        print("  3. Run: git diff to verify changes")
        return True


def main():
    parser = argparse.ArgumentParser(description='Apply Hebrew naming scheme to FormulasRegistry')
    parser.add_argument('--apply', action='store_true', help='Actually apply changes (default is dry-run)')
    parser.add_argument('--preview', action='store_true', help='Just show the proposed changes')
    args = parser.parse_args()

    if args.preview:
        preview_changes()
    else:
        apply_changes(dry_run=not args.apply)


if __name__ == "__main__":
    main()
