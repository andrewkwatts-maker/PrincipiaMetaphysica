"""
Generate Interactive HTML for Formula Terms
============================================

This script adds the 'html' field to formulas in formulas.json that have
'terms' metadata, enabling interactive hover tooltips on the formulas page.

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
"""

import json
import os
import re
from typing import Dict, Any, List, Optional

# Path configuration
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(SCRIPT_DIR)
FORMULAS_JSON = os.path.join(PROJECT_ROOT, "AutoGenerated", "formulas.json")
OUTPUT_JSON = os.path.join(PROJECT_ROOT, "AutoGenerated", "formulas.json")


def escape_html(text: str) -> str:
    """Escape HTML special characters."""
    return (text
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace('"', "&quot;"))


def latex_to_html(latex: str) -> str:
    """
    Convert LaTeX to simple HTML with subscripts and superscripts.
    This is a simplified converter for display purposes.
    """
    html = latex

    # Remove \int, \left, \right, \text wrappers
    html = re.sub(r'\\int\s*', '&int;', html)
    html = re.sub(r'\\left\[', '[', html)
    html = re.sub(r'\\right\]', ']', html)
    html = re.sub(r'\\left\(', '(', html)
    html = re.sub(r'\\right\)', ')', html)
    html = re.sub(r'\\sqrt\{([^}]+)\}', r'&radic;(\1)', html)
    html = re.sub(r'\\bar\{([^}]+)\}', r'<span style="text-decoration:overline">\1</span>', html)
    html = re.sub(r'\\text\{([^}]+)\}', r'\1', html)
    html = re.sub(r'\\mathcal\{([^}]+)\}', r'<i>\1</i>', html)

    # Convert subscripts and superscripts
    html = re.sub(r'_\{([^}]+)\}', r'<sub>\1</sub>', html)
    html = re.sub(r'_([a-zA-Z0-9])', r'<sub>\1</sub>', html)
    html = re.sub(r'\^\{([^}]+)\}', r'<sup>\1</sup>', html)
    html = re.sub(r'\^([a-zA-Z0-9])', r'<sup>\1</sup>', html)

    # Clean up remaining LaTeX commands
    html = re.sub(r'\\[a-zA-Z]+', '', html)

    # Clean up extra whitespace
    html = re.sub(r'\s+', ' ', html).strip()

    return html


def generate_interactive_html(formula: Dict[str, Any]) -> Optional[str]:
    """
    Generate interactive HTML with hoverable terms for a formula.

    Returns None if formula doesn't have terms metadata.
    """
    terms = formula.get('terms', {})
    if not terms or not isinstance(terms, dict):
        return None

    latex = formula.get('latex', '')
    plain_text = formula.get('plain_text', '')

    if not plain_text and not latex:
        return None

    # Use plain_text as base, or convert LaTeX
    base_html = plain_text if plain_text else latex_to_html(latex)

    # Map of symbols to their HTML wrappers
    # Sort by length descending to avoid partial replacements
    sorted_terms = sorted(terms.items(), key=lambda x: len(x[0]), reverse=True)

    result_html = base_html
    replaced = set()

    for symbol, term_data in sorted_terms:
        if symbol in replaced:
            continue

        # Get description
        if isinstance(term_data, str):
            description = term_data
        elif isinstance(term_data, dict):
            description = term_data.get('description', term_data.get('name', ''))
        else:
            description = str(term_data)

        # Create the interactive span
        # Use data-term attribute for JavaScript to pick up
        escaped_desc = escape_html(description)
        escaped_symbol = escape_html(symbol)

        # Build the formula-var span with tooltip
        interactive_span = f'<span class="formula-var" data-term="{escaped_symbol}">{escaped_symbol}<span class="var-tooltip"><span class="var-name">{escaped_symbol}</span><span class="var-description">{escaped_desc}</span></span></span>'

        # Replace symbol in the formula (careful with boundaries)
        # Use word boundaries where possible
        pattern = re.escape(symbol)
        if re.search(pattern, result_html):
            # Only replace first occurrence to avoid over-replacing
            # Use a function replacement to avoid backslash issues
            result_html = result_html.replace(symbol, interactive_span, 1)
            replaced.add(symbol)

    # If no replacements were made, return None
    if not replaced:
        return None

    return result_html


def generate_master_action_html() -> str:
    """
    Generate specific HTML for the 25D Pneuma Master Action.
    This is hand-crafted for optimal display.
    """
    return '''<span class="formula-var" data-term="S">S<span class="var-tooltip"><span class="var-name">S - Action</span><span class="var-description">25D Pneuma master action functional</span></span></span>
<span class="formula-op"> = </span>
<span class="formula-var" data-term="integral">&int;d<sup>25</sup>X<span class="var-tooltip"><span class="var-name">&int;d<sup>25</sup>X - Integration</span><span class="var-description">Integration over 25-dimensional spacetime with signature (24,1)</span></span></span>
<span class="formula-var" data-term="sqrt-G">&radic;(-G)<span class="var-tooltip"><span class="var-name">&radic;(-G) - Metric Determinant</span><span class="var-description">Square root of negative metric determinant for covariant volume element</span></span></span>
<span class="formula-op">[</span>
<span class="formula-var highlight" data-term="R">R<span class="var-tooltip"><span class="var-name">R - Ricci Scalar</span><span class="var-description">25D Einstein-Hilbert scalar curvature</span><span class="var-units">Length<sup>-2</sup></span></span></span>
<span class="formula-op"> + </span>
<span class="formula-var highlight" data-term="Psi_P"><span style="text-decoration:overline">&Psi;</span><sub>P</sub>(i&Gamma;<sup>M</sup>D<sub>M</sub> - m)&Psi;<sub>P</sub><span class="var-tooltip"><span class="var-name">&Psi;<sub>P</sub> - Pneuma Spinor</span><span class="var-description">4096-component Pneuma spinor from Cl(24,1) Clifford algebra. Source of all matter.</span><span class="var-units">Mass<sup>12.5</sup></span></span></span>
<span class="formula-op"> + </span>
<span class="formula-var" data-term="lambda">&lambda;(<span style="text-decoration:overline">&Psi;</span><sub>P</sub>&Psi;<sub>P</sub>)<sup>2</sup><span class="var-tooltip"><span class="var-name">&lambda; - Quartic Term</span><span class="var-description">Quartic self-interaction for fermion condensation and mass generation</span></span></span>
<span class="formula-op"> + </span>
<span class="formula-var" data-term="t_ortho">g&middot;t<sub>ortho</sub>&middot;<span style="text-decoration:overline">&Psi;</span><sub>P</sub>&Psi;<sub>P</sub><span class="var-tooltip"><span class="var-name">t<sub>ortho</sub> - Orthogonal Time</span><span class="var-description">Orthogonal time direction coupling from Sp(2,R) gauge structure</span></span></span>
<span class="formula-op"> + </span>
<span class="formula-var" data-term="L_Sp2R"><i>L</i><sub>Sp(2,R)</sub><span class="var-tooltip"><span class="var-name"><i>L</i><sub>Sp(2,R)</sub> - Gauge Lagrangian</span><span class="var-description">Sp(2,R) gauge fixing Lagrangian for 2T physics time gauge</span></span></span>
<span class="formula-op">]</span>'''


def generate_three_generations_html() -> str:
    """Generate HTML for n_gen = chi_eff / 48 formula."""
    return '''<span class="formula-var" data-term="n_gen">n<sub>gen</sub><span class="var-tooltip"><span class="var-name">n<sub>gen</sub> - Generation Number</span><span class="var-description">Number of fermion generations, derived from topology</span><span class="var-units">Dimensionless integer = 3</span></span></span>
<span class="formula-op"> = </span>
<span class="formula-var" data-term="chi_eff">&chi;<sub>eff</sub><span class="var-tooltip"><span class="var-name">&chi;<sub>eff</sub> - Effective Euler</span><span class="var-description">Effective Euler characteristic from Hodge numbers: 2(h<sup>1,1</sup> - h<sup>2,1</sup> + h<sup>3,1</sup>) = 144</span></span></span>
<span class="formula-op"> / </span>
<span class="formula-var" data-term="48">48<span class="var-tooltip"><span class="var-name">48 - Index Divisor</span><span class="var-description">Atiyah-Singer index theorem divisor for G2 compactification</span></span></span>'''


def generate_euler_characteristic_html() -> str:
    """Generate HTML for chi_eff formula."""
    return '''<span class="formula-var" data-term="chi_eff">&chi;<sub>eff</sub><span class="var-tooltip"><span class="var-name">&chi;<sub>eff</sub> - Effective Euler</span><span class="var-description">Effective Euler characteristic controlling generation count</span></span></span>
<span class="formula-op"> = </span>
<span class="formula-var" data-term="2">2<span class="var-tooltip"><span class="var-name">2 - Prefactor</span><span class="var-description">Doubling from Poincare duality on 7-manifold</span></span></span>
<span class="formula-op">(</span>
<span class="formula-var" data-term="h11">h<sup>1,1</sup><span class="var-tooltip"><span class="var-name">h<sup>1,1</sup> - Kahler Moduli</span><span class="var-description">Kahler moduli count = 4 for TCS #187</span></span></span>
<span class="formula-op"> - </span>
<span class="formula-var" data-term="h21">h<sup>2,1</sup><span class="var-tooltip"><span class="var-name">h<sup>2,1</sup> - Complex Structure</span><span class="var-description">Complex structure moduli = 0 (no complex structure on G2)</span></span></span>
<span class="formula-op"> + </span>
<span class="formula-var" data-term="h31">h<sup>3,1</sup><span class="var-tooltip"><span class="var-name">h<sup>3,1</sup> - Associative Moduli</span><span class="var-description">Associative 3-cycle moduli = 68</span></span></span>
<span class="formula-op">)</span>'''


def process_formulas():
    """Process formulas.json and add html fields."""

    print(f"Loading formulas from: {FORMULAS_JSON}")

    with open(FORMULAS_JSON, 'r', encoding='utf-8') as f:
        data = json.load(f)

    formulas = data.get('formulas', {})
    if isinstance(formulas, list):
        # Convert to dict if it's a list
        formulas = {f['id']: f for f in formulas if 'id' in f}

    count = 0

    # Add hand-crafted HTML for key formulas
    key_formulas = {
        'pneuma-master-action-v18': generate_master_action_html(),
        'three-generations': generate_three_generations_html(),
        'euler-characteristic': generate_euler_characteristic_html(),
    }

    for formula_id, html in key_formulas.items():
        if formula_id in formulas:
            formulas[formula_id]['html'] = html
            print(f"  + Added HTML for: {formula_id}")
            count += 1

    # Auto-generate HTML for formulas with terms
    for formula_id, formula in formulas.items():
        if formula_id in key_formulas:
            continue  # Skip already processed

        if 'html' in formula:
            continue  # Already has HTML

        html = generate_interactive_html(formula)
        if html:
            formula['html'] = html
            print(f"  + Auto-generated HTML for: {formula_id}")
            count += 1

    # Write back
    data['formulas'] = formulas

    with open(OUTPUT_JSON, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

    print(f"\nProcessed {count} formulas with interactive HTML")
    print(f"Output written to: {OUTPUT_JSON}")


if __name__ == '__main__':
    process_formulas()
