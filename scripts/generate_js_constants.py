#!/usr/bin/env python3
"""
Generate JavaScript Constants from Simulation Output

This script creates auto-generated JS files from theory_output.json,
ensuring the frontend always displays values from simulations.

Usage:
    python scripts/generate_js_constants.py [--diff] [--write]

Options:
    --diff   Show differences between old and new files
    --write  Write the generated files (default: dry run)

Outputs:
    js/theory-constants.generated.js   (new generated file)
    reports/js_generation_diff.txt     (diff report)

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
"""

import json
import re
import argparse
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List, Tuple

# Project root
PROJECT_ROOT = Path(__file__).parent.parent

# Output files
GENERATED_JS = PROJECT_ROOT / "js" / "theory-constants.generated.js"
OLD_JS = PROJECT_ROOT / "js" / "theory-constants.js"
DIFF_REPORT = PROJECT_ROOT / "reports" / "js_generation_diff.txt"


def load_theory_output() -> Dict[str, Any]:
    """Load theory_output.json with UTF-8 encoding."""
    theory_path = PROJECT_ROOT / "AutoGenerated" / "theory_output.json"
    if not theory_path.exists():
        raise FileNotFoundError(f"theory_output.json not found at {theory_path}")

    with open(theory_path, 'r', encoding='utf-8') as f:
        return json.load(f)


def extract_value(param_data: Any) -> Any:
    """Extract the actual value from parameter data structure."""
    if isinstance(param_data, dict):
        if 'value' in param_data:
            return extract_value(param_data['value'])
        return param_data
    return param_data


def format_js_value(value: Any, precision: int = 6) -> str:
    """Format a Python value for JavaScript output."""
    if value is None:
        return "null"
    if isinstance(value, bool):
        return "true" if value else "false"
    if isinstance(value, int):
        return str(value)
    if isinstance(value, float):
        # Handle scientific notation
        if abs(value) > 1e10 or (abs(value) < 1e-3 and value != 0):
            return f"{value:.6e}"
        return f"{value:.{precision}g}"
    if isinstance(value, str):
        # Escape special characters
        escaped = value.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n')
        return f'"{escaped}"'
    if isinstance(value, (list, tuple)):
        items = [format_js_value(v) for v in value]
        return f"[{', '.join(items)}]"
    if isinstance(value, dict):
        items = [f"{k}: {format_js_value(v)}" for k, v in value.items()]
        return f"{{{', '.join(items)}}}"
    return str(value)


def create_value_mapping(params: Dict[str, Any]) -> Dict[str, Any]:
    """Create a flat mapping of all parameter paths to values."""
    mapping = {}

    def flatten(d: Dict, prefix: str = ''):
        for k, v in d.items():
            full_key = f"{prefix}.{k}" if prefix else k
            if isinstance(v, dict) and 'value' not in v:
                flatten(v, full_key)
            else:
                mapping[full_key] = extract_value(v)

    flatten(params)
    return mapping


# Mapping from old JS keys to theory_output paths
JS_TO_THEORY_MAP = {
    # Dimensions
    'dimensions.full': 'geometry.D_bulk',
    'dimensions.effective': 'geometry.D_G2',
    'dimensions.observable': None,  # Always 4

    # Spinors
    'spinors.full26D': 'geometry.spinor_26d',
    'spinors.effective13D': None,  # Fixed at 64

    # Topology (Hodge numbers from GeometricAnchors)
    'topology.h11': 'geometry.h11',
    'topology.h21': 'geometry.h21',
    'topology.h31': 'geometry.h31',
    'topology.chiEffective': 'geometry.chi_eff',
    'topology.generations': 'geometry.n_generations',
    'topology.adjointDim': None,  # Fixed at 45

    # Fundamental Scales
    'fundamentalScales.mPlanck': 'geometry.m_planck_4d',
    'fundamentalScales.mStar': 'geometry.M_star',
    'fundamentalScales.mGUT': 'geometry.M_GUT_geometric',
    'fundamentalScales.alphaGUT': 'geometry.alpha_gut',
    'fundamentalScales.alphaEM': 'constants.alpha_em',

    # Dark Energy
    'darkEnergy.w0': 'geometry.w_zero',
    'darkEnergy.wa': 'geometry.wa',
    'darkEnergy.w0Observed': 'desi.w0',
    'darkEnergy.waObserved': 'desi.wa',
    'darkEnergy.omegaLambda': 'geometry.omega_Lambda_Planck',
    'darkEnergy.omegaMatter': 'geometry.Omega_matter',
    'darkEnergy.omegaBaryon': 'geometry.Omega_baryon',
    'darkEnergy.H0': 'geometry.H0_early',

    # Thermal Time
    'thermalTime.alphaT': 'geometry.alpha_T_phenomenological',
    'thermalTime.alphaTBase': None,  # Needs derivation
    'thermalTime.alphaRSquared': 'geometry.alpha_R_squared_phenom',

    # Neutrino
    'neutrino.theta12': 'geometry.theta_12',
    'neutrino.theta13': 'geometry.theta_13',
    'neutrino.theta23': 'geometry.theta_23',
    'neutrino.deltaCP': 'geometry.delta_CP_PMNS',
    'neutrino.sumMNu': 'geometry.sum_m_nu',

    # CKM
    'ckm.Vus': 'geometry.V_us',
    'ckm.Vcb': 'geometry.V_cb',
    'ckm.Vub': 'geometry.V_ub',
    'ckm.Jarlskog': 'geometry.J_CKM',

    # Constants
    'constants.alphaInverse': 'geometry.alpha_inverse',
    'constants.alphaS': 'geometry.alpha_s',
    'constants.sin2ThetaW': 'geometry.sin2_theta_W',
    'constants.higgsVEV': 'geometry.higgs_vev',
    'constants.GF': 'geometry.G_F',
    'constants.TCMB': 'geometry.T_CMB',
    'constants.muPE': 'geometry.mu_pe',
}


def generate_theory_constants_js(theory_output: Dict[str, Any]) -> str:
    """Generate the theory-constants.js file content."""
    metadata = theory_output.get('metadata', {})
    params = theory_output.get('parameters', {})

    git_hash = metadata.get('git', {}).get('commit_hash', 'unknown')
    timestamp = datetime.now().isoformat()

    header = f'''/**
 * theory-constants.js - Principia Metaphysica Theory Constants
 *
 * AUTO-GENERATED from simulations by generate_js_constants.py
 * DO NOT EDIT THIS FILE MANUALLY - Run simulations to regenerate!
 *
 * Generated: {timestamp}
 * Source: AutoGenerated/theory_output.json
 * Git: {git_hash}
 *
 * Usage:
 *   TheoryConstants.dimensions.D_BULK  // 26
 *   TheoryConstants.cosmology.w0       // -0.9583
 *   TheoryConstants.constants.alpha_inverse  // 137.037
 */

"use strict";

const TheoryConstants = {{
'''

    categories = categorize_parameters(params)

    sections = []
    for cat_name, cat_params in categories.items():
        if not cat_params:
            continue

        section_lines = [f"\n    // {cat_name.upper()}", f"    {cat_name}: {{"]

        for param_key, param_value in sorted(cat_params.items()):
            # Convert key to camelCase for JS
            js_key = param_key.replace('.', '_').replace('-', '_')
            js_value = format_js_value(param_value)
            section_lines.append(f"        {js_key}: {js_value},")

        section_lines.append("    },")
        sections.append('\n'.join(section_lines))

    footer = '''
};

// Export for both browser and Node.js
if (typeof window !== 'undefined') {
    window.TheoryConstants = TheoryConstants;
}
if (typeof module !== 'undefined' && module.exports) {
    module.exports = TheoryConstants;
}
'''

    return header + '\n'.join(sections) + footer


def extract_old_values(js_content: str) -> Dict[str, Any]:
    """Extract numeric values from existing JS file."""
    values = {}

    # Pattern for key: value pairs
    pattern = re.compile(r'(\w+)\s*:\s*(-?[\d.e+-]+)\s*[,\}]', re.IGNORECASE)

    for match in pattern.finditer(js_content):
        key = match.group(1)
        try:
            value = float(match.group(2))
            values[key] = value
        except ValueError:
            pass

    return values


def generate_diff_report(old_values: Dict[str, Any], new_values: Dict[str, Any]) -> str:
    """Generate a diff report comparing old and new values."""
    lines = [
        "=" * 70,
        "JS CONSTANTS GENERATION DIFF REPORT",
        f"Generated: {datetime.now().isoformat()}",
        "=" * 70,
        ""
    ]

    old_keys = set(old_values.keys())
    new_keys = set(new_values.keys())

    added = new_keys - old_keys
    removed = old_keys - new_keys
    common = old_keys & new_keys

    changed = []
    for key in common:
        old_val = old_values[key]
        new_val = new_values[key]
        if isinstance(old_val, (int, float)) and isinstance(new_val, (int, float)):
            if abs(old_val) > 1e-10:
                rel_diff = abs(old_val - new_val) / abs(old_val)
                if rel_diff > 0.001:  # More than 0.1% difference
                    changed.append((key, old_val, new_val, rel_diff))

    lines.append("SUMMARY")
    lines.append("-" * 40)
    lines.append(f"Old file keys:      {len(old_keys)}")
    lines.append(f"New file keys:      {len(new_keys)}")
    lines.append(f"Added:              {len(added)}")
    lines.append(f"Removed:            {len(removed)}")
    lines.append(f"Changed (>0.1%):    {len(changed)}")
    lines.append("")

    if added:
        lines.append("ADDED KEYS")
        lines.append("-" * 40)
        for key in sorted(added)[:20]:
            lines.append(f"  + {key}: {new_values[key]}")
        if len(added) > 20:
            lines.append(f"  ... and {len(added) - 20} more")
        lines.append("")

    if removed:
        lines.append("REMOVED KEYS (verify these are intentional)")
        lines.append("-" * 40)
        for key in sorted(removed)[:20]:
            lines.append(f"  - {key}: {old_values[key]}")
        if len(removed) > 20:
            lines.append(f"  ... and {len(removed) - 20} more")
        lines.append("")

    if changed:
        lines.append("CHANGED VALUES (>0.1% difference)")
        lines.append("-" * 40)
        for key, old_val, new_val, rel_diff in sorted(changed, key=lambda x: -x[3])[:30]:
            lines.append(f"  {key}:")
            lines.append(f"    Old: {old_val}")
            lines.append(f"    New: {new_val}")
            lines.append(f"    Diff: {rel_diff*100:.2f}%")
        if len(changed) > 30:
            lines.append(f"  ... and {len(changed) - 30} more")
        lines.append("")

    lines.append("=" * 70)
    return "\n".join(lines)


def generate_update_report(theory_mapping: Dict[str, Any]) -> str:
    """Generate a report showing what JS values should be updated."""
    lines = [
        "=" * 70,
        "JS VALUES UPDATE REPORT",
        f"Generated: {datetime.now().isoformat()}",
        "=" * 70,
        "",
        "This report shows which hardcoded JS values should be updated",
        "to match simulation-derived values in theory_output.json.",
        "",
    ]

    updates_needed = []
    for js_key, theory_path in JS_TO_THEORY_MAP.items():
        if theory_path is None:
            continue  # Fixed value, not from theory

        if theory_path in theory_mapping:
            theory_value = theory_mapping[theory_path]
            updates_needed.append((js_key, theory_path, theory_value))
        else:
            lines.append(f"  [MISSING] {js_key} -> {theory_path} (not in theory_output)")

    lines.append("")
    lines.append("RECOMMENDED UPDATES")
    lines.append("-" * 40)
    lines.append("Update these values in theory-constants.js:")
    lines.append("")

    for js_key, theory_path, value in sorted(updates_needed):
        lines.append(f"  {js_key}:")
        lines.append(f"    Source: {theory_path}")
        lines.append(f"    Value:  {format_js_value(value)}")
        lines.append("")

    lines.append("=" * 70)
    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(description='Generate JS constants from simulations')
    parser.add_argument('--diff', action='store_true', help='Show diff against old file')
    parser.add_argument('--updates', action='store_true', help='Show recommended updates')
    parser.add_argument('--write', action='store_true', help='Write generated files')
    args = parser.parse_args()

    print("Loading theory_output.json...")
    theory_output = load_theory_output()

    params = theory_output.get('parameters', {})
    theory_mapping = create_value_mapping(params)
    print(f"Theory output has {len(theory_mapping)} parameters")

    # Generate update report (recommended approach)
    if args.updates or not (args.diff or args.write):
        print("\n" + generate_update_report(theory_mapping))
        return

    print("Generating JS content...")
    js_content = generate_theory_constants_js(theory_output)

    # Extract values from new content
    new_values = extract_old_values(js_content)
    print(f"Generated {len(new_values)} values")

    # Load old file if exists
    old_values = {}
    if OLD_JS.exists():
        print(f"Loading old file: {OLD_JS}")
        old_content = OLD_JS.read_text(encoding='utf-8')
        old_values = extract_old_values(old_content)
        print(f"Old file has {len(old_values)} values")

    # Generate diff report
    if args.diff:
        diff_report = generate_diff_report(old_values, new_values)
        print("\n" + diff_report)

        if args.write:
            DIFF_REPORT.parent.mkdir(exist_ok=True)
            DIFF_REPORT.write_text(diff_report, encoding='utf-8')
            print(f"\nDiff report saved to: {DIFF_REPORT}")

    # Write generated file
    if args.write:
        GENERATED_JS.write_text(js_content, encoding='utf-8')
        print(f"\nGenerated file saved to: {GENERATED_JS}")
        print("\nTo replace the old file, run:")
        print(f"  copy {GENERATED_JS} {OLD_JS}")
    else:
        print("\nDry run complete. Use --write to save files.")


if __name__ == "__main__":
    main()
