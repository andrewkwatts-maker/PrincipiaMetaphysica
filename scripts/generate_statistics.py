#!/usr/bin/env python3
"""
Generate validation statistics dynamically from source data.

This script computes statistics.json from:
1. GATES_72_CERTIFICATES.json - Gate verification status and sigma deviations
2. CERTIFICATES_v16_2_FINAL.json - Parameter certificates with sigma deviations
3. simulations/results (if available) - Additional validation results

Statistics computed:
- within_1sigma: count of predictions within 1 sigma of experimental values
- within_2sigma: count within 2 sigma
- exact_matches: count where sigma_deviation = 0.0
- total_predictions: total verifiable predictions
- chi_squared_reduced: computed from sigma deviations
- degrees_of_freedom: number of verified gates - fitted parameters

This ensures statistics.json is regenerated from source data, not manually edited.
"""

import json
import os
import sys
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional, Tuple

# Import version from SSoT
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
try:
    from core.FormulasRegistry import FormulasRegistry
    VERSION = FormulasRegistry.VERSION_SHORT
except ImportError:
    VERSION = "19.2"  # Fallback

# Paths relative to project root
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
GATES_CERT_FILE = os.path.join(PROJECT_ROOT, "AutoGenerated", "GATES_72_CERTIFICATES.json")
PARAM_CERT_FILE = os.path.join(PROJECT_ROOT, "AutoGenerated", "CERTIFICATES_v16_2_FINAL.json")
PARAMETERS_FILE = os.path.join(PROJECT_ROOT, "AutoGenerated", "parameters.json")
SIMULATIONS_RESULTS_DIR = os.path.join(PROJECT_ROOT, "simulations", "results")
OUTPUT_FILE = os.path.join(PROJECT_ROOT, "AutoGenerated", "statistics.json")

# Number of fitted parameters (constants used in the framework derivations)
# These are the fundamental geometric constants that anchor the framework
FITTED_PARAMS_COUNT = 1  # Only k_gimel is fitted; b3, chi_eff, phi are mathematical


def load_json_file(filepath: str) -> Optional[Dict[str, Any]]:
    """Load a JSON file if it exists."""
    if os.path.exists(filepath):
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError) as e:
            print(f"Warning: Could not load {filepath}: {e}")
    return None


def extract_sigma_deviations_from_gates(gates_data: Dict[str, Any]) -> List[float]:
    """Extract sigma deviations from gate certificates."""
    sigma_deviations = []

    if not gates_data or 'certificates' not in gates_data:
        return sigma_deviations

    for cert in gates_data['certificates']:
        # Only include VERIFIED gates with derived/experimental values
        if cert.get('verification_status') == 'VERIFIED':
            # Check if certificate has sigma deviation info
            if 'derived_value' in cert and 'experimental_value' in cert:
                derived = cert.get('derived_value')
                experimental = cert.get('experimental_value')
                # Compute sigma if we have uncertainty info
                if derived is not None and experimental is not None:
                    # Look for evidence block with sigma info
                    evidence = cert.get('evidence', {})
                    if 'max_deviation_sigma' in evidence:
                        sigma_deviations.append(evidence['max_deviation_sigma'])

    return sigma_deviations


def extract_sigma_deviations_from_param_certs(cert_data: Dict[str, Any]) -> List[float]:
    """Extract sigma deviations from parameter certificates."""
    sigma_deviations = []

    if not cert_data or 'certificates' not in cert_data:
        return sigma_deviations

    for cert in cert_data['certificates']:
        sigma = cert.get('sigma_deviation')
        if sigma is not None and isinstance(sigma, (int, float)):
            sigma_deviations.append(float(sigma))

    return sigma_deviations


def extract_sigma_deviations_from_parameters(params_data: Dict[str, Any]) -> List[float]:
    """Extract sigma deviations from parameters.json."""
    sigma_deviations = []

    if not params_data or 'parameters' not in params_data:
        return sigma_deviations

    for param in params_data['parameters']:
        sigma = param.get('sigma_deviation')
        if sigma is not None and isinstance(sigma, (int, float)):
            sigma_deviations.append(float(sigma))

    return sigma_deviations


def load_simulation_results() -> List[Dict[str, Any]]:
    """Load validation results from simulations/results directory if available."""
    results = []

    if not os.path.exists(SIMULATIONS_RESULTS_DIR):
        return results

    for filename in os.listdir(SIMULATIONS_RESULTS_DIR):
        if filename.endswith('.json'):
            filepath = os.path.join(SIMULATIONS_RESULTS_DIR, filename)
            data = load_json_file(filepath)
            if data:
                results.append(data)

    return results


def compute_statistics(sigma_deviations: List[float]) -> Dict[str, Any]:
    """Compute validation statistics from sigma deviations."""
    if not sigma_deviations:
        return {
            "within_1sigma": 0,
            "within_2sigma": 0,
            "exact_matches": 0,
            "total_predictions": 0,
            "chi_squared_reduced": None,
            "degrees_of_freedom": 0,
            "note": "No sigma deviation data available"
        }

    # Count predictions within sigma thresholds
    within_1sigma = sum(1 for s in sigma_deviations if abs(s) <= 1.0)
    within_2sigma = sum(1 for s in sigma_deviations if abs(s) <= 2.0)
    exact_matches = sum(1 for s in sigma_deviations if s == 0.0)
    total_predictions = len(sigma_deviations)

    # Compute reduced chi-squared: sum(sigma^2) / degrees_of_freedom
    # degrees_of_freedom = n_predictions - n_fitted_params
    degrees_of_freedom = max(1, total_predictions - FITTED_PARAMS_COUNT)
    chi_squared = sum(s ** 2 for s in sigma_deviations)
    chi_squared_reduced = chi_squared / degrees_of_freedom

    return {
        "within_1sigma": within_1sigma,
        "within_2sigma": within_2sigma,
        "exact_matches": exact_matches,
        "total_predictions": total_predictions,
        "chi_squared_reduced": round(chi_squared_reduced, 4),
        "degrees_of_freedom": degrees_of_freedom
    }


def count_gate_statuses(gates_data: Dict[str, Any]) -> Dict[str, int]:
    """Count gates by verification status."""
    counts = {
        "verified": 0,
        "pending_lock": 0,
        "not_testable": 0,
        "mathematical": 0,
        "total_gates": 0
    }

    if not gates_data or 'certificates' not in gates_data:
        return counts

    for cert in gates_data['certificates']:
        counts["total_gates"] += 1
        status = cert.get('verification_status', '').upper()

        if status == 'VERIFIED':
            counts["verified"] += 1
        elif status == 'PENDING_LOCK':
            counts["pending_lock"] += 1
        elif status == 'NOT_TESTABLE':
            counts["not_testable"] += 1
        elif status == 'MATHEMATICAL':
            counts["mathematical"] += 1

    return counts


def generate_statistics() -> Dict[str, Any]:
    """Generate complete statistics from all source data."""
    print("Loading source data...")

    # Load all data sources
    gates_data = load_json_file(GATES_CERT_FILE)
    param_cert_data = load_json_file(PARAM_CERT_FILE)
    parameters_data = load_json_file(PARAMETERS_FILE)

    # Collect all sigma deviations
    all_sigma_deviations = []

    # From parameter certificates (primary source for sigma deviations)
    if param_cert_data:
        cert_sigmas = extract_sigma_deviations_from_param_certs(param_cert_data)
        all_sigma_deviations.extend(cert_sigmas)
        print(f"  - Found {len(cert_sigmas)} sigma deviations from CERTIFICATES_v16_2_FINAL.json")

    # From gates certificates
    if gates_data:
        gate_sigmas = extract_sigma_deviations_from_gates(gates_data)
        # Avoid duplicates - only add if not already covered
        if gate_sigmas:
            all_sigma_deviations.extend(gate_sigmas)
            print(f"  - Found {len(gate_sigmas)} sigma deviations from GATES_72_CERTIFICATES.json")

    # Compute main validation statistics
    validation_stats = compute_statistics(all_sigma_deviations)

    # Count gate statuses
    gate_counts = count_gate_statuses(gates_data)

    # Determine overall status
    if gate_counts["verified"] >= 30:
        status = "MAJORITY_VERIFIED"
    elif gate_counts["verified"] >= 20:
        status = "SUBSTANTIAL_PROGRESS"
    elif gate_counts["verified"] >= 10:
        status = "MODERATE_PROGRESS"
    else:
        status = "EARLY_STAGE"

    # Compute success rate for predictions with data
    total_with_data = validation_stats["total_predictions"]
    success_rate = (validation_stats["within_2sigma"] / total_with_data * 100) if total_with_data > 0 else 0.0

    # Build output structure
    statistics = {
        "version": VERSION,
        "generated_at": datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
        "source_files": {
            "gates_certificates": GATES_CERT_FILE,
            "parameter_certificates": PARAM_CERT_FILE,
            "parameters": PARAMETERS_FILE
        },
        "statistics": {
            "exact_matches": validation_stats["exact_matches"]
        },
        "summary": {
            "exact_parameters": validation_stats["exact_matches"]
        },
        "validation": {
            "within_1sigma": validation_stats["within_1sigma"],
            "within_2sigma": validation_stats["within_2sigma"],
            "total_predictions": validation_stats["total_predictions"],
            "total_parameters": total_with_data,
            "calibrated_count": FITTED_PARAMS_COUNT,
            "constraints_count": 1,
            "exact_matches": validation_stats["exact_matches"],
            "success_rate": f"{success_rate:.1f}%"
        },
        "framework_statistics": {
            "pass_count": gate_counts["verified"],
            "pending_count": gate_counts["pending_lock"],
            "not_testable_count": gate_counts["not_testable"],
            "mathematical_count": gate_counts["mathematical"],
            "total_gates": gate_counts["total_gates"],
            "testable_count": gate_counts["total_gates"] - gate_counts["not_testable"],  # 72 - 30 = 42
            "exact_matches": validation_stats["exact_matches"],
            "chi_squared_reduced": validation_stats["chi_squared_reduced"],
            "degrees_of_freedom": validation_stats["degrees_of_freedom"],
            "status": status
        }
    }

    # Also update parameters.json with framework_statistics as registered params
    # This ensures the JS loader can find them via standard parameter lookup
    if os.path.exists(PARAMETERS_FILE):
        try:
            with open(PARAMETERS_FILE, 'r', encoding='utf-8') as f:
                params_data = json.load(f)

            # Add framework_statistics as registered parameters
            fs = statistics['framework_statistics']
            params_data['parameters']['framework_statistics.pass_count'] = {
                'value': fs['pass_count'],
                'status': 'COMPUTED',
                'source': 'generate_statistics.py'
            }
            params_data['parameters']['framework_statistics.pending_count'] = {
                'value': fs['pending_count'],
                'status': 'COMPUTED',
                'source': 'generate_statistics.py'
            }
            params_data['parameters']['framework_statistics.not_testable_count'] = {
                'value': fs['not_testable_count'],
                'status': 'COMPUTED',
                'source': 'generate_statistics.py'
            }
            params_data['parameters']['framework_statistics.mathematical_count'] = {
                'value': fs['mathematical_count'],
                'status': 'COMPUTED',
                'source': 'generate_statistics.py'
            }
            params_data['parameters']['framework_statistics.total_gates'] = {
                'value': fs['total_gates'],
                'status': 'COMPUTED',
                'source': 'generate_statistics.py'
            }
            params_data['parameters']['framework_statistics.testable_count'] = {
                'value': fs['testable_count'],
                'status': 'COMPUTED',
                'source': 'generate_statistics.py',
                'description': 'Number of testable gates (total - axioms)'
            }
            params_data['parameters']['framework_statistics.chi_squared_reduced'] = {
                'value': fs['chi_squared_reduced'],
                'status': 'COMPUTED',
                'source': 'generate_statistics.py'
            }
            params_data['parameters']['framework_statistics.degrees_of_freedom'] = {
                'value': fs['degrees_of_freedom'],
                'status': 'COMPUTED',
                'source': 'generate_statistics.py'
            }
            params_data['parameters']['framework_statistics.status'] = {
                'value': fs['status'],
                'status': 'COMPUTED',
                'source': 'generate_statistics.py'
            }
            params_data['parameters']['framework_statistics.exact_matches'] = {
                'value': fs['exact_matches'],
                'status': 'COMPUTED',
                'source': 'generate_statistics.py'
            }

            # Also add validation section
            vs = statistics['validation']
            params_data['parameters']['validation.within_1sigma'] = {
                'value': vs['within_1sigma'],
                'status': 'COMPUTED',
                'source': 'generate_statistics.py'
            }
            params_data['parameters']['validation.within_2sigma'] = {
                'value': vs['within_2sigma'],
                'status': 'COMPUTED',
                'source': 'generate_statistics.py'
            }
            params_data['parameters']['validation.total_predictions'] = {
                'value': vs['total_predictions'],
                'status': 'COMPUTED',
                'source': 'generate_statistics.py'
            }
            params_data['parameters']['validation.success_rate'] = {
                'value': vs['success_rate'],
                'status': 'COMPUTED',
                'source': 'generate_statistics.py'
            }

            with open(PARAMETERS_FILE, 'w', encoding='utf-8') as f:
                json.dump(params_data, f, indent=2)
            print(f"  Updated parameters.json with framework_statistics")
        except Exception as e:
            print(f"  Warning: Could not update parameters.json: {e}")

    return statistics


def main():
    """Main entry point."""
    print("=" * 60)
    print("Generating Validation Statistics")
    print("=" * 60)

    # Generate statistics (this also updates parameters.json)
    statistics = generate_statistics()

    # Write output
    os.makedirs(os.path.dirname(OUTPUT_FILE), exist_ok=True)
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        json.dump(statistics, f, indent=2)

    # Print summary
    print("\n" + "=" * 60)
    print("STATISTICS SUMMARY")
    print("=" * 60)
    print(f"\nValidation Results:")
    print(f"  Within 1 sigma:    {statistics['validation']['within_1sigma']}")
    print(f"  Within 2 sigma:    {statistics['validation']['within_2sigma']}")
    print(f"  Exact matches:     {statistics['validation']['exact_matches']}")
    print(f"  Total predictions: {statistics['validation']['total_predictions']}")
    print(f"  Success rate:      {statistics['validation']['success_rate']}")

    print(f"\nFramework Statistics (72 Gates Total):")
    fs = statistics['framework_statistics']
    print(f"  Verified gates:    {fs['pass_count']} of {fs['testable_count']} testable")
    print(f"  Pending gates:     {fs['pending_count']}")
    print(f"  Not testable:      {fs['not_testable_count']} (axioms)")
    print(f"  Mathematical:      {fs['mathematical_count']}")
    print(f"  Chi-squared (red): {fs['chi_squared_reduced']}")
    print(f"  Degrees of freedom:{fs['degrees_of_freedom']}")
    print(f"  Status:            {fs['status']}")

    print(f"\nOutput written to: {OUTPUT_FILE}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
