#!/usr/bin/env python3
"""
Generate JavaScript Constants from Simulation Output

This script updates theory-constants.js with values from parameters.json,
ensuring the frontend always displays simulation-derived values.

Usage:
    python scripts/generate_js_constants.py           # Dry run, show diff
    python scripts/generate_js_constants.py --write   # Apply changes

Source of Truth: AutoGenerated/parameters.json
Target: js/theory-constants.js

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
"""

import json
import re
import argparse
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, Optional, Tuple

# Project root
PROJECT_ROOT = Path(__file__).parent.parent

# Files
PARAMS_JSON = PROJECT_ROOT / "AutoGenerated" / "parameters.json"
TARGET_JS = PROJECT_ROOT / "js" / "theory-constants.js"
DIFF_REPORT = PROJECT_ROOT / "reports" / "js_constants_diff.txt"


# Mapping from JS paths to parameter.json paths
# Format: (js_section, js_key) -> parameter_path
PARAM_MAPPINGS = {
    # Dimensions
    ("dimensions", "full"): "geometry.D_bulk",
    ("dimensions", "effective"): "geometry.D_G2",

    # Spinors
    ("spinors", "full26D"): "geometry.spinor_26d",
    ("spinors", "effective13D"): "geometry.spinor_13d",

    # Topology
    ("topology", "h11"): "geometry.h11",
    ("topology", "h21"): "geometry.h21",
    ("topology", "h31"): "geometry.h31",
    ("topology", "chiEffective"): "geometry.chi_eff",
    ("topology", "fluxReduction"): "geometry.flux_reduction",
    ("topology", "generations"): "geometry.n_generations",

    # Fundamental Scales
    ("fundamentalScales", "mPlanck"): "geometry.m_planck_4d",
    ("fundamentalScales", "mStar"): "geometry.M_star",
    ("fundamentalScales", "mGUT"): "geometry.M_GUT_geometric",
    ("fundamentalScales", "alphaGUT"): "geometry.alpha_gut",

    # Dark Energy (v16.2)
    ("darkEnergy", "w0"): "geometry.w_zero",
    ("darkEnergy", "wa"): "geometry.wa",
    ("darkEnergy", "w0Observed"): "geometry.w0_observed_DESI",
    ("darkEnergy", "w0Error"): "geometry.w0_error_DESI",
    ("darkEnergy", "waObserved"): "geometry.wa_observed_DESI",
    ("darkEnergy", "omegaLambda"): "geometry.Omega_Lambda",
    ("darkEnergy", "omegaMatter"): "geometry.Omega_matter",
    ("darkEnergy", "omegaBaryon"): "geometry.Omega_baryon",
    ("darkEnergy", "H0"): "geometry.H0_early",

    # Thermal Time
    ("thermalTime", "alphaT"): "geometry.alpha_T",
    ("thermalTime", "alphaTBase"): "geometry.alpha_T_phenomenological",

    # Modified Gravity
    ("modifiedGravity", "alphaRSquared"): "geometry.alpha_R_squared_phenom",
    ("modifiedGravity", "phi0Breathing"): "geometry.xi_breathing",
    ("modifiedGravity", "nEffPneuma"): "geometry.pneuma_components",

    # Multi-Time (v16.2: deprecated values replaced by pneuma_components)
    ("multiTime", "xi"): "geometry.pneuma_components",
    ("multiTime", "etaBoosted"): "geometry.pneuma_components",
    ("multiTime", "kLISATypical"): "geometry.k_LISA_typical",
    ("multiTime", "theta45Deg"): "geometry.theta_45deg",

    # Moduli (v16.2)
    ("moduli", "fTermPhysical"): "geometry.pneuma_components",
    ("moduli", "aSwampland"): "geometry.a_swampland",

    # Landscape (v16.2)
    ("landscape", "landscapeEntropy"): "geometry.landscape_entropy",
    ("landscape", "deltaVMultiverse"): "geometry.pneuma_components",

    # v128 Predictions (KK Mass)
    ("v128Predictions", "mKKCentral"): "geometry.m_KK_central",
    ("v128Predictions", "mKKCurrentBound"): "geometry.m_KK_bound",
    ("v128Predictions", "etaBoosted"): "geometry.pneuma_components",

    # Neutrinos (v16.2 Hopf Fibration)
    ("neutrinos", "sumMNu"): "geometry.sum_m_nu",
    ("neutrinos", "deltaMSq21"): "geometry.dm21_squared",
    ("neutrinos", "deltaMSq31"): "geometry.dm31_squared",
    ("neutrinos", "theta_12"): "geometry.theta_12",
    ("neutrinos", "theta_13"): "geometry.theta_13",
    ("neutrinos", "theta_23"): "geometry.theta_23",
    ("neutrinos", "delta_CP"): "geometry.delta_CP_PMNS",

    # CKM Matrix
    ("ckmMatrix", "V_us"): "geometry.V_us",
    ("ckmMatrix", "V_cb"): "geometry.V_cb",
    ("ckmMatrix", "V_ub"): "geometry.V_ub",
    ("ckmMatrix", "jarlskogInvariant"): "geometry.J_CKM",
    ("ckmMatrix", "wolfensteinA"): "geometry.A_Wolfenstein",
    ("ckmMatrix", "wolfensteinLambda"): "geometry.lambda_Wolfenstein",

    # Proton Decay
    ("protonDecay", "tauProton"): "geometry.tau_proton",
}


def load_parameters() -> Dict[str, Any]:
    """Load parameters.json with UTF-8 encoding."""
    if not PARAMS_JSON.exists():
        raise FileNotFoundError(f"parameters.json not found at {PARAMS_JSON}")

    with open(PARAMS_JSON, 'r', encoding='utf-8') as f:
        data = json.load(f)

    # Handle nested structure
    return data.get('parameters', data)


def get_param_value(params: Dict[str, Any], path: str) -> Optional[Any]:
    """Extract value from parameter, handling nested structures."""
    if path not in params:
        return None

    param = params[path]
    if isinstance(param, dict) and 'value' in param:
        return param['value']
    return param


def format_js_number(value: Any) -> str:
    """Format a number for JavaScript."""
    if value is None:
        return None
    if isinstance(value, bool):
        return "true" if value else "false"
    if isinstance(value, int):
        return str(value)
    if isinstance(value, float):
        # Handle very large or small numbers with scientific notation
        if abs(value) >= 1e10 or (0 < abs(value) < 1e-4):
            # Use scientific notation
            return f"{value:.6e}".replace('e+', 'e+').replace('e-0', 'e-').replace('e+0', 'e+')
        # Normal decimal
        if value == int(value):
            return str(int(value))
        return f"{value:.6g}"
    return str(value)


def update_js_value(content: str, section: str, key: str, new_value: str) -> Tuple[str, bool]:
    """
    Update a specific value in JS content.
    Returns (updated_content, was_changed).
    """
    # Pattern to match: key: value, or key: value}
    # Within a section block
    pattern = rf'({key}\s*:\s*)([^,\n\}}]+)(,|\}})'

    def replacer(match):
        prefix = match.group(1)
        old_val = match.group(2).strip()
        suffix = match.group(3)
        return f"{prefix}{new_value}{suffix}"

    # Find the section first
    section_pattern = rf'({section}\s*:\s*\{{[^}}]*?)({key}\s*:\s*)([^,\n\}}]+)(,|\}})'

    new_content, count = re.subn(section_pattern,
                                  lambda m: m.group(1) + m.group(2) + new_value + m.group(4),
                                  content, flags=re.DOTALL)

    return new_content, count > 0


def apply_mappings(js_content: str, params: Dict[str, Any]) -> Tuple[str, list]:
    """Apply all parameter mappings to JS content."""
    changes = []
    updated_content = js_content

    for (section, key), param_path in PARAM_MAPPINGS.items():
        value = get_param_value(params, param_path)
        if value is None:
            continue

        js_value = format_js_number(value)
        if js_value is None:
            continue

        # Try to update the value
        new_content, changed = update_js_value(updated_content, section, key, js_value)
        if changed:
            updated_content = new_content
            changes.append({
                'section': section,
                'key': key,
                'param_path': param_path,
                'new_value': value,
                'js_value': js_value
            })

    return updated_content, changes


def update_metadata(content: str) -> str:
    """Update the metadata section with current timestamp."""
    # Update version
    content = re.sub(
        r'version:\s*"[^"]*"',
        'version: "16.2"',
        content
    )

    # Update lastGenerated
    today = datetime.now().strftime('%Y-%m-%d')
    content = re.sub(
        r'lastGenerated:\s*"[^"]*"',
        f'lastGenerated: "{today}"',
        content
    )

    # Update generatedFrom
    content = re.sub(
        r'generatedFrom:\s*"[^"]*"',
        'generatedFrom: "AutoGenerated/parameters.json via generate_js_constants.py"',
        content
    )

    return content


def generate_diff_report(changes: list, params: Dict[str, Any]) -> str:
    """Generate a report of all changes made."""
    lines = [
        "=" * 70,
        "JS CONSTANTS UPDATE REPORT",
        f"Generated: {datetime.now().isoformat()}",
        f"Source: {PARAMS_JSON}",
        f"Target: {TARGET_JS}",
        "=" * 70,
        "",
        f"Total mappings defined: {len(PARAM_MAPPINGS)}",
        f"Changes applied: {len(changes)}",
        "",
        "CHANGES APPLIED",
        "-" * 40,
    ]

    for change in changes:
        lines.append(f"  {change['section']}.{change['key']}:")
        lines.append(f"    Source: {change['param_path']}")
        lines.append(f"    Value:  {change['new_value']} -> {change['js_value']}")
        lines.append("")

    # Check for missing mappings
    missing = []
    for (section, key), param_path in PARAM_MAPPINGS.items():
        if get_param_value(params, param_path) is None:
            missing.append((section, key, param_path))

    if missing:
        lines.append("")
        lines.append("MISSING PARAMETERS (not in parameters.json)")
        lines.append("-" * 40)
        for section, key, path in missing:
            lines.append(f"  {section}.{key} -> {path}")

    lines.append("")
    lines.append("=" * 70)
    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(
        description='Update theory-constants.js from parameters.json'
    )
    parser.add_argument('--write', action='store_true',
                       help='Apply changes (default: dry run)')
    parser.add_argument('--verbose', '-v', action='store_true',
                       help='Show detailed output')
    args = parser.parse_args()

    print("Loading parameters.json...")
    params = load_parameters()
    print(f"  Loaded {len(params)} parameters")

    print(f"\nLoading {TARGET_JS}...")
    if not TARGET_JS.exists():
        print(f"  ERROR: Target file not found!")
        return 1

    js_content = TARGET_JS.read_text(encoding='utf-8')
    print(f"  Loaded {len(js_content)} bytes")

    print("\nApplying mappings...")
    updated_content, changes = apply_mappings(js_content, params)
    print(f"  Applied {len(changes)} changes")

    # Update metadata
    updated_content = update_metadata(updated_content)

    # Generate report
    report = generate_diff_report(changes, params)

    if args.verbose or not args.write:
        print("\n" + report)

    if args.write:
        # Write updated JS
        TARGET_JS.write_text(updated_content, encoding='utf-8')
        print(f"\n[OK] Updated {TARGET_JS}")

        # Write diff report
        DIFF_REPORT.parent.mkdir(exist_ok=True)
        DIFF_REPORT.write_text(report, encoding='utf-8')
        print(f"[OK] Report saved to {DIFF_REPORT}")
    else:
        print("\n[DRY RUN] No files modified. Use --write to apply changes.")

    return 0


if __name__ == "__main__":
    exit(main())
