#!/usr/bin/env python3
"""
Dimensional Reduction SSOT Validator
=====================================

Validates that dimensional reduction parameters are consistent across:
1. FormulasRegistry (SSOT source)
2. Simulation files (consumers)
3. AutoGenerated files (outputs)

Naming Convention (Gemini audit 2026-01-14):
- ANCESTRAL: Original 27D bosonic frame (Level 0) with signature (26,1)
- BRANE:     13D brane after S_PR(2) gauge fixing (Level 1)
- COMPACT:   G2 holonomy compactification (Level 2)
- VISIBLE:   Observable 4D spacetime (Level 3)

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
"""

import sys
import re
import json
from pathlib import Path
from typing import Dict, List, Tuple, Optional

# Add parent to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

try:
    from core.FormulasRegistry import FormulasRegistry
except ImportError as e:
    print(f"[ERROR] Cannot import FormulasRegistry: {e}")
    sys.exit(1)


class DimensionalSSOTValidator:
    """Validates dimensional reduction SSOT consistency."""

    # Expected 5-level dimensional chain values
    # Chain: 27D(26,1) → [Sp(2,R)] → 13D(12,1) → [G2(7,0)] → 6D(5,1) → [KK] → 4D(3,1)
    DIMENSIONAL_CHAIN = {
        # Level 0: ANCESTRAL (27D Bosonic) - Signature (26,1) = 24 G2 core + 2 bridge + 1 time
        "D_ancestral_total": 27,
        "D_ancestral_space": 26,
        "D_ancestral_time": 1,
        # Level 1: SHADOW (13D after Sp(2,R)) - Signature (12,1)
        "D_shadow_total": 13,
        "D_shadow_space": 12,
        "D_shadow_time": 1,
        # Level 2: G2 (7D G2 Holonomy) - Signature (7,0) RIEMANNIAN
        "D_G2_total": 7,
        "D_G2_space": 7,   # All spatial - G2 is Riemannian
        "D_G2_time": 0,    # NO time dimension
        # Level 3: EXTERNAL (6D Observable Bulk) - Signature (5,1)
        "D_external_total": 6,
        "D_external_space": 5,
        "D_external_time": 1,
        # Level 4: VISIBLE (4D Spacetime) - Signature (3,1)
        "D_visible_total": 4,
        "D_visible_space": 3,
        "D_visible_time": 1,
    }

    # Legacy aliases that must match semantic names
    LEGACY_ALIASES = {
        # Level 0 aliases (27D(26,1) bulk)
        "D_total_27": "D_ancestral_total",
        "D_space_26": "D_ancestral_space",
        "D_time_1": "D_ancestral_time",
        # Level 1 aliases (brane -> shadow)
        "D_brane_total": "D_shadow_total",
        "D_brane_space": "D_shadow_space",
        "D_brane_time": "D_shadow_time",
        "D_total_13": "D_shadow_total",
        "D_space_12": "D_shadow_space",
        # Level 2 aliases
        "D_compact_G2": "D_G2_total",
        "D_G2": "D_G2_total",
        # Level 3 aliases
        "D_compact_external": "D_external_total",
        "D_external_6": "D_external_total",
        # Level 4 aliases
        "D_total_4": "D_visible_total",
        "D_space_3": "D_visible_space",
        "D_time_1": "D_visible_time",
    }

    # Sector naming consistency
    SECTOR_PARAMS = {
        "chi_eff": 72,           # Per-sector Euler characteristic
        "chi_eff_total": 144,    # Total manifold (2 sectors)
        "roots_total": 288,      # Total roots (both sectors)
        "roots_per_sector": 144, # Roots per sector
        "visible_sector": 125,   # SM parameters
        "sterile_sector": 163,   # Dark sector (288 - 125)
        "shadow_sector": 135,    # Sophia gates (Gnostic)
        "christ_constant": 153,  # Christos (Gnostic)
    }

    # Compactification relations to verify
    COMPACTIFICATION_RELATIONS = [
        # D_ancestral = 2 * D_brane (two branes)
        ("D_ancestral_total", 2, "D_brane_total"),
        # D_brane = D_compact_G2 + D_compact_external
        ("D_brane_total", 1, "D_compact_G2", 1, "D_compact_external"),
        # D_compact_external = D_visible_total + 2
        ("D_compact_external", -2, "D_visible_total"),
    ]

    def __init__(self, base_path: Path = None):
        """Initialize validator."""
        if base_path is None:
            base_path = Path(__file__).parent.parent

        self.base_path = base_path
        self.registry = FormulasRegistry()
        self.errors: List[str] = []
        self.warnings: List[str] = []
        self.info: List[str] = []

    def validate_registry_values(self) -> bool:
        """Validate that FormulasRegistry has correct values."""
        print("\n[1] VALIDATING FormulasRegistry VALUES")
        print("-" * 50)

        success = True

        # Check dimensional chain values
        for param, expected in self.DIMENSIONAL_CHAIN.items():
            actual = getattr(self.registry, param, None)
            if actual is None:
                self.errors.append(f"Missing property: {param}")
                success = False
            elif actual != expected:
                self.errors.append(f"{param}: expected {expected}, got {actual}")
                success = False
            else:
                self.info.append(f"{param} = {actual} [OK]")

        # Check sector parameters
        for param, expected in self.SECTOR_PARAMS.items():
            actual = getattr(self.registry, param, None)
            if actual is None:
                self.errors.append(f"Missing sector param: {param}")
                success = False
            elif actual != expected:
                self.errors.append(f"{param}: expected {expected}, got {actual}")
                success = False
            else:
                self.info.append(f"{param} = {actual} [OK]")

        # Check legacy aliases match semantic names
        for legacy, semantic in self.LEGACY_ALIASES.items():
            legacy_val = getattr(self.registry, legacy, None)
            semantic_val = getattr(self.registry, semantic, None)

            if legacy_val is None:
                self.errors.append(f"Missing legacy alias: {legacy}")
                success = False
            elif semantic_val is None:
                self.errors.append(f"Missing semantic name: {semantic}")
                success = False
            elif legacy_val != semantic_val:
                self.errors.append(f"Alias mismatch: {legacy}={legacy_val} vs {semantic}={semantic_val}")
                success = False
            else:
                self.info.append(f"{legacy} == {semantic} = {legacy_val} [OK]")

        return success

    def validate_compactification_relations(self) -> bool:
        """Validate 5-level dimensional compactification relations."""
        print("\n[2] VALIDATING 5-LEVEL COMPACTIFICATION RELATIONS")
        print("-" * 50)

        success = True

        # Level 0→1: D_ancestral(25) = D_shadow(13) + D_shadow_compact(12) [Euclidean bridge]
        D_anc = self.registry.D_ancestral_total
        D_shadow = self.registry.D_shadow_total
        # Note: v22 Euclidean bridge model - relation changed from 2x shadow to shadow + compact
        if D_anc != D_shadow + 12:
            self.errors.append(f"Euclidean bridge relation failed: {D_anc} != {D_shadow} + 12")
            success = False
        else:
            self.info.append(f"D_ancestral(25) = D_shadow(13) + 12 [OK]")

        # Level 1→2,3: D_shadow(13) = D_G2(7) + D_external(6)
        D_G2 = self.registry.D_G2_total
        D_ext = self.registry.D_external_total
        if D_shadow != D_G2 + D_ext:
            self.errors.append(f"G2 split failed: {D_shadow} != {D_G2} + {D_ext}")
            success = False
        else:
            self.info.append(f"D_shadow(13) = D_G2(7) + D_external(6) [OK]")

        # G2 is RIEMANNIAN: signature (7,0) - no time dimension
        D_G2_space = self.registry.D_G2_space
        D_G2_time = self.registry.D_G2_time
        if D_G2_space != 7 or D_G2_time != 0:
            self.errors.append(f"G2 signature wrong: ({D_G2_space},{D_G2_time}) != (7,0)")
            success = False
        else:
            self.info.append(f"G2 signature (7,0) RIEMANNIAN [OK]")

        # Level 3→4: D_external(6) = D_visible(4) + 2 [KK reduction]
        D_vis = self.registry.D_visible_total
        if D_ext != D_vis + 2:
            self.errors.append(f"KK relation failed: {D_ext} != {D_vis} + 2")
            success = False
        else:
            self.info.append(f"D_external(6) = D_visible(4) + 2 [OK]")

        # Verify signatures
        # External: (5,1)
        D_ext_space = self.registry.D_external_space
        D_ext_time = self.registry.D_external_time
        if D_ext_space != 5 or D_ext_time != 1:
            self.errors.append(f"External signature wrong: ({D_ext_space},{D_ext_time}) != (5,1)")
            success = False
        else:
            self.info.append(f"D_external signature (5,1) [OK]")

        # Chi_eff relations
        chi_sector = self.registry.mephorash_chi
        chi_total = self.registry.chi_eff_total
        if chi_total != 2 * chi_sector:
            self.errors.append(f"Chi relation failed: {chi_total} != 2 * {chi_sector}")
            success = False
        else:
            self.info.append(f"chi_eff_total(144) = 2 * chi_eff(72) [OK]")

        # n_gen from chi_eff
        n_gen = self.registry.n_gen
        b3 = self.registry.elder_vessels
        if n_gen != chi_sector // b3:
            self.errors.append(f"n_gen relation failed: {n_gen} != {chi_sector}/{b3}")
            success = False
        else:
            self.info.append(f"n_gen(3) = chi_eff(72) / b3(24) [OK]")

        # Roots relations
        roots_total = self.registry.nitzotzin_roots
        roots_per_sector = self.registry.roots_per_sector
        if roots_total != 2 * roots_per_sector:
            self.errors.append(f"Roots relation failed: {roots_total} != 2 * {roots_per_sector}")
            success = False
        else:
            self.info.append(f"roots_total(288) = 2 * roots_per_sector(144) [OK]")

        # Sector partition
        visible = self.registry.visible_sector
        sterile = self.registry.sophian_pressure
        if roots_total != visible + sterile:
            self.errors.append(f"Sector partition failed: {roots_total} != {visible} + {sterile}")
            success = False
        else:
            self.info.append(f"roots_total(288) = visible(125) + sterile(163) [OK]")

        # Gnostic partition
        shadow = self.registry.demiurgic_gates
        christ = self.registry.logos_joint
        if roots_total != shadow + christ:
            self.errors.append(f"Gnostic partition failed: {roots_total} != {shadow} + {christ}")
            success = False
        else:
            self.info.append(f"roots_total(288) = shadow(135) + christ(153) [OK]")

        return success

    def scan_simulation_files(self) -> bool:
        """Scan simulation files for hardcoded dimensional values."""
        print("\n[3] SCANNING SIMULATION FILES FOR HARDCODED VALUES")
        print("-" * 50)

        sim_path = self.base_path / "simulations"
        if not sim_path.exists():
            self.warnings.append("Simulations directory not found")
            return True

        # Patterns to flag (hardcoded values that should use SSOT)
        patterns = {
            r'\b26\b': ("D_ancestral_total", 26, "dimensional"),
            r'\b24\b': ("D_ancestral_space/b3", 24, "dimensional"),
            r'\b13\b': ("D_brane_total", 13, "dimensional"),
            r'\b12\b': ("D_brane_space", 12, "dimensional"),
            r'\b72\b': ("chi_eff", 72, "sector"),
            r'\b144\b': ("chi_eff_total/roots_per_sector", 144, "sector"),
            r'\b288\b': ("roots_total", 288, "sector"),
            r'\b125\b': ("visible_sector", 125, "sector"),
            r'\b163\b': ("sterile_sector", 163, "sector"),
            r'\b135\b': ("shadow_sector", 135, "gnostic"),
            r'\b153\b': ("christ_constant", 153, "gnostic"),
        }

        # Count occurrences
        occurrences: Dict[str, List[Tuple[str, int]]] = {k: [] for k in patterns}

        for py_file in sim_path.rglob("*.py"):
            try:
                content = py_file.read_text(encoding='utf-8')
                for pattern, (param, value, category) in patterns.items():
                    matches = re.findall(pattern, content)
                    if matches:
                        occurrences[pattern].append((str(py_file.relative_to(self.base_path)), len(matches)))
            except Exception as e:
                self.warnings.append(f"Could not read {py_file}: {e}")

        # Report findings
        total_hardcoded = 0
        for pattern, (param, value, category) in patterns.items():
            files = occurrences[pattern]
            if files:
                count = sum(n for _, n in files)
                total_hardcoded += count
                # Only warn for high-count patterns (not all 24s are D_space_24)
                if count > 10:
                    self.info.append(f"{param}={value}: {count} occurrences in {len(files)} files")

        self.info.append(f"Total potential hardcoded values: {total_hardcoded}")
        return True  # This is informational, not a failure

    def validate_autogenerated_params(self) -> bool:
        """Validate AutoGenerated/parameters.json matches registry."""
        print("\n[4] VALIDATING AutoGenerated/parameters.json")
        print("-" * 50)

        params_file = self.base_path / "AutoGenerated" / "parameters.json"
        if not params_file.exists():
            self.warnings.append("parameters.json not found - run regeneration")
            return True

        try:
            with open(params_file, 'r', encoding='utf-8') as f:
                params_data = json.load(f)
        except Exception as e:
            self.errors.append(f"Could not load parameters.json: {e}")
            return False

        # Check key parameters exist
        params = params_data.get("parameters", {})

        # Map of expected params to check
        # Note: parameters.json uses topology.chi_eff for the total (144)
        # FormulasRegistry has chi_eff = 72 (per-sector) and chi_eff_total = 144
        # Most simulations use chi_eff = 144, so we allow either
        checks = {
            "topology.b3": self.registry.b3,
            "topology.n_gen": self.registry.n_gen,
        }

        # Check chi_eff - can be either 72 (per-sector) or 144 (total)
        chi_param = params.get("topology.chi_eff", {})
        chi_val = chi_param.get("value") if isinstance(chi_param, dict) else chi_param
        if chi_val is not None:
            if chi_val == 72:
                self.info.append(f"parameters.json: topology.chi_eff = 72 (per-sector) [OK]")
            elif chi_val == 144:
                self.info.append(f"parameters.json: topology.chi_eff = 144 (total/legacy) [OK]")
            else:
                self.errors.append(f"chi_eff unexpected value: {chi_val} (expected 72 or 144)")
                success = False

        success = True
        for key, expected in checks.items():
            entry = params.get(key, {})
            actual = entry.get("value") if isinstance(entry, dict) else entry

            if actual is None:
                self.warnings.append(f"Missing in parameters.json: {key}")
            elif actual != expected:
                self.errors.append(f"parameters.json mismatch: {key} = {actual}, expected {expected}")
                success = False
            else:
                self.info.append(f"parameters.json: {key} = {expected} [OK]")

        return success

    def print_report(self) -> int:
        """Print validation report and return exit code."""
        print("\n" + "=" * 60)
        print("DIMENSIONAL SSOT VALIDATION REPORT")
        print("=" * 60)

        if self.errors:
            print(f"\n[ERRORS] ({len(self.errors)}):")
            for err in self.errors:
                print(f"  - {err}")

        if self.warnings:
            print(f"\n[WARNINGS] ({len(self.warnings)}):")
            for warn in self.warnings:
                print(f"  - {warn}")

        if self.info:
            print(f"\n[INFO] ({len(self.info)} checks passed):")
            for info in self.info[:20]:  # Limit output
                print(f"  + {info}")
            if len(self.info) > 20:
                print(f"  ... and {len(self.info) - 20} more")

        print("\n" + "=" * 60)
        if self.errors:
            print("STATUS: FAILED")
            return 1
        elif self.warnings:
            print("STATUS: PASSED WITH WARNINGS")
            return 0
        else:
            print("STATUS: PASSED")
            return 0

    def run_all(self) -> int:
        """Run all validations."""
        print("Dimensional SSOT Validator v1.0")
        print("=" * 60)

        self.validate_registry_values()
        self.validate_compactification_relations()
        self.scan_simulation_files()
        self.validate_autogenerated_params()

        return self.print_report()


def main():
    """Main entry point."""
    validator = DimensionalSSOTValidator()
    sys.exit(validator.run_all())


if __name__ == "__main__":
    main()
