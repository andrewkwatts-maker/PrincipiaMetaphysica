#!/usr/bin/env python3
"""
High Sigma Parameter Analyzer

Analyzes PM parameters with high sigma deviations to identify:
1. Which params have the highest sigma (poorest agreement with experiment)
2. The order in which params are registered during simulation
3. Which formulas/simulations produce the high-sigma params
4. Potential root causes and propagation chains

This script is READ-ONLY - it does not modify any files.

Usage:
    python scripts/analyze_high_sigma_params.py [--threshold SIGMA]

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
"""

import argparse
import json
import os
import sys
from typing import Dict, Any, List, Tuple
from datetime import datetime

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
PARAMETERS_FILE = os.path.join(PROJECT_ROOT, "AutoGenerated", "parameters.json")
METADATA_FILE = os.path.join(PROJECT_ROOT, "AutoGenerated", "metadata.json")
THEORY_OUTPUT_FILE = os.path.join(PROJECT_ROOT, "AutoGenerated", "theory_output.json")


def load_json(filepath: str) -> Dict[str, Any]:
    """Load a JSON file."""
    if not os.path.exists(filepath):
        return {}
    with open(filepath, 'r', encoding='utf-8') as f:
        return json.load(f)


def extract_sigma_params(params_data: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Extract all params with sigma deviations."""
    sigma_params = []

    params = params_data.get('parameters', {})
    for path, param in params.items():
        if not isinstance(param, dict):
            continue

        sigma = param.get('sigma_deviation')
        if sigma is None or not isinstance(sigma, (int, float)):
            continue

        # Skip system/internal params
        status = param.get('status', '')
        if status in ['SYSTEM', 'AXIOM']:
            continue

        sigma_params.append({
            'path': path,
            'sigma': abs(sigma),
            'value': param.get('value'),
            'experimental_value': param.get('experimental_value'),
            'experimental_uncertainty': param.get('experimental_uncertainty'),
            'status': status,
            'source': param.get('source', ''),
            'timestamp': param.get('timestamp', ''),
            'validation_status': param.get('validation_status', '')
        })

    return sigma_params


def get_simulation_order(metadata: Dict[str, Any]) -> Dict[str, int]:
    """Extract simulation execution order from metadata."""
    sim_order = {}

    validation = metadata.get('validation', {})
    results = validation.get('results', [])

    for i, result in enumerate(results):
        sim_id = result.get('simulation_id', '')
        if sim_id:
            sim_order[sim_id] = i

    return sim_order


def get_param_registration_order(params: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Sort params by their registration timestamp."""
    # Parse timestamps and sort
    for param in params:
        ts = param.get('timestamp', '')
        if ts:
            try:
                param['_parsed_ts'] = datetime.fromisoformat(ts.replace('Z', '+00:00'))
            except:
                param['_parsed_ts'] = datetime.min
        else:
            param['_parsed_ts'] = datetime.min

    sorted_params = sorted(params, key=lambda x: x['_parsed_ts'])

    # Add registration order
    for i, param in enumerate(sorted_params):
        param['registration_order'] = i + 1
        del param['_parsed_ts']

    return sorted_params


def categorize_sigma(sigma: float) -> str:
    """Categorize sigma deviation."""
    if sigma < 1.0:
        return "EXCELLENT (<1s)"
    elif sigma < 2.0:
        return "GOOD (1-2s)"
    elif sigma < 3.0:
        return "MODERATE (2-3s)"
    elif sigma < 5.0:
        return "WEAK (3-5s)"
    else:
        return "POOR (>5s)"


def analyze_high_sigma_sources(
    high_sigma_params: List[Dict[str, Any]],
    sim_order: Dict[str, int]
) -> Dict[str, List[str]]:
    """Group high-sigma params by their source simulation."""
    by_source = {}

    for param in high_sigma_params:
        source = param.get('source', 'unknown')
        # Extract simulation ID from source
        if ':' in source:
            source = source.split(':')[0]

        if source not in by_source:
            by_source[source] = []
        by_source[source].append(param['path'])

    return by_source


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description='Analyze high sigma params')
    parser.add_argument('--threshold', type=float, default=2.0,
                        help='Sigma threshold for "high" (default: 2.0)')
    args = parser.parse_args()

    print("=" * 70)
    print("High Sigma Parameter Analyzer")
    print("=" * 70)

    # Load data
    params_data = load_json(PARAMETERS_FILE)
    metadata = load_json(METADATA_FILE)

    # Extract sigma params
    sigma_params = extract_sigma_params(params_data)
    sigma_params = get_param_registration_order(sigma_params)

    print(f"\nLoaded {len(sigma_params)} parameters with sigma deviations")

    # Statistics
    print("\n" + "-" * 70)
    print("SIGMA DISTRIBUTION")
    print("-" * 70)

    categories = {
        "EXCELLENT (<1s)": 0,
        "GOOD (1-2s)": 0,
        "MODERATE (2-3s)": 0,
        "WEAK (3-5s)": 0,
        "POOR (>5s)": 0
    }

    for param in sigma_params:
        cat = categorize_sigma(param['sigma'])
        categories[cat] += 1

    for cat, count in categories.items():
        pct = count / len(sigma_params) * 100 if sigma_params else 0
        bar = "#" * int(pct / 5)
        print(f"  {cat}: {count:3d} ({pct:5.1f}%) {bar}")

    # High sigma params (sorted by sigma, descending)
    high_sigma = [p for p in sigma_params if p['sigma'] >= args.threshold]
    high_sigma = sorted(high_sigma, key=lambda x: x['sigma'], reverse=True)

    print("\n" + "-" * 70)
    print(f"HIGH SIGMA PARAMS (>={args.threshold}s) - Sorted by Sigma")
    print("-" * 70)

    if high_sigma:
        print(f"\nFound {len(high_sigma)} parameters with sigma >= {args.threshold}")
        print("\n{:<45} {:>8} {:>6} {:>15} {:>15}".format(
            "Parameter", "Sigma", "Order", "Computed", "Experimental"
        ))
        print("-" * 95)

        for param in high_sigma[:25]:
            value = param['value']
            exp = param['experimental_value']

            # Format values
            if isinstance(value, float):
                if abs(value) < 0.01 or abs(value) > 1e6:
                    value_str = f"{value:.2e}"
                else:
                    value_str = f"{value:.4g}"
            else:
                value_str = str(value)[:15]

            if isinstance(exp, float):
                if abs(exp) < 0.01 or abs(exp) > 1e6:
                    exp_str = f"{exp:.2e}"
                else:
                    exp_str = f"{exp:.4g}"
            else:
                exp_str = str(exp)[:15] if exp else "N/A"

            print(f"{param['path']:<45} {param['sigma']:>8.2f} {param['registration_order']:>6} {value_str:>15} {exp_str:>15}")

        if len(high_sigma) > 25:
            print(f"\n  ... and {len(high_sigma) - 25} more")
    else:
        print(f"\n[PASS] No parameters with sigma >= {args.threshold}")

    # Group by source simulation
    sim_order = get_simulation_order(metadata)
    by_source = analyze_high_sigma_sources(high_sigma, sim_order)

    if by_source:
        print("\n" + "-" * 70)
        print("HIGH SIGMA BY SOURCE SIMULATION")
        print("-" * 70)

        # Sort by simulation order
        sorted_sources = sorted(by_source.items(),
                                key=lambda x: sim_order.get(x[0], 999))

        for source, params in sorted_sources:
            phase = sim_order.get(source, '?')
            print(f"\n  {source} (phase {phase}):")
            for path in params[:5]:
                matching = next((p for p in high_sigma if p['path'] == path), None)
                if matching:
                    print(f"    - {path}: {matching['sigma']:.2f}s")
            if len(params) > 5:
                print(f"    ... and {len(params) - 5} more")

    # Root cause analysis hints
    print("\n" + "-" * 70)
    print("ROOT CAUSE ANALYSIS HINTS")
    print("-" * 70)

    if high_sigma:
        # Find earliest high-sigma params
        earliest = sorted(high_sigma, key=lambda x: x['registration_order'])[:5]
        print("\nEarliest registered high-sigma params (potential root causes):")
        for param in earliest:
            print(f"  {param['registration_order']:3d}. {param['path']}: {param['sigma']:.2f}s")
            print(f"       Source: {param['source']}")

        # Find params with highest impact (sigma * occurrences)
        print("\nParams to investigate first:")
        for param in high_sigma[:5]:
            print(f"  - {param['path']}")
            print(f"    Sigma: {param['sigma']:.2f}, Status: {param['status']}")
            unc = param.get('experimental_uncertainty')
            if unc:
                print(f"    Uncertainty: {unc} (check if reasonable)")
            print()

    # Summary
    print("=" * 70)
    print("SUMMARY")
    print("=" * 70)

    total = len(sigma_params)
    good = categories["EXCELLENT (<1s)"] + categories["GOOD (1-2s)"]
    pct_good = good / total * 100 if total else 0

    print(f"\n  Total params with sigma: {total}")
    print(f"  Within 2s (good): {good} ({pct_good:.1f}%)")
    print(f"  Above {args.threshold}s threshold: {len(high_sigma)}")

    if len(high_sigma) > 0:
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())
