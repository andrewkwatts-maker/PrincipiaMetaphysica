#!/usr/bin/env python3
"""
Validate all 72 Gates that have numerical Wolfram queries.
Generates comprehensive wolfram_results.json with all gate validations.
"""

import json
import urllib.request
import urllib.parse
import time
import sys
import os
import re
import math

# Add simulations to path for secrets
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'simulations'))

try:
    from secrets_config import WOLFRAM_APP_ID
except ImportError:
    WOLFRAM_APP_ID = None
    print("No API key found in secrets_config.py")


def query_wolfram(query_string: str, app_id: str) -> dict:
    """Query Wolfram Alpha API via HTTP."""
    encoded_query = urllib.parse.quote(query_string)
    url = f'http://api.wolframalpha.com/v2/query?appid={app_id}&input={encoded_query}&output=json'

    try:
        with urllib.request.urlopen(url, timeout=30) as response:
            data = json.loads(response.read().decode('utf-8'))
            return data
    except Exception as e:
        return {"error": str(e)}


def extract_result(response: dict) -> tuple:
    """Extract result value from Wolfram response."""
    if "error" in response:
        return None, response["error"]

    queryresult = response.get("queryresult", {})
    if not queryresult.get("success", False):
        return None, "Query failed"

    pods = queryresult.get("pods", [])
    for pod in pods:
        title = pod.get("title", "").lower()
        if title in ["result", "decimal approximation", "exact result"]:
            subpods = pod.get("subpods", [])
            if subpods:
                text = subpods[0].get("plaintext", "")
                if text:
                    return text, None

    for pod in pods:
        subpods = pod.get("subpods", [])
        for subpod in subpods:
            text = subpod.get("plaintext", "")
            if text and any(c.isdigit() for c in text):
                return text, None

    return None, "No result found"


def parse_numeric(text: str) -> float:
    """Parse numeric value from Wolfram result text."""
    if not text:
        return None

    # Clean up - remove extra info in parentheses
    text = re.sub(r'\s*\([^)]*\)', '', text).strip()

    # Handle simple numbers
    try:
        return float(text)
    except ValueError:
        pass

    # Handle fractions like "-23/24" or "136/5"
    fraction_match = re.match(r'^(-?\d+)/(\d+)$', text)
    if fraction_match:
        try:
            num = float(fraction_match.group(1))
            den = float(fraction_match.group(2))
            return num / den
        except:
            pass

    # Handle expressions with pi
    if 'pi' in text.lower() or 'π' in text:
        parts = text.split('+')
        try:
            int_part = float(parts[0].strip())
            pi_part = parts[1].strip() if len(parts) > 1 else "0"
            if '/π' in pi_part or '/pi' in pi_part.lower():
                num_match = re.search(r'(\d+)/[πp]', pi_part, re.IGNORECASE)
                if num_match:
                    pi_frac = float(num_match.group(1)) / math.pi
                    return int_part + pi_frac
        except:
            pass

    # Handle degree symbol
    degree_match = re.match(r'^([\d.]+)[°]', text)
    if degree_match:
        try:
            return float(degree_match.group(1))
        except:
            pass

    # Extract first number
    match = re.search(r'-?[\d.]+', text)
    if match:
        try:
            return float(match.group())
        except:
            pass

    return None


def convert_mathematica_to_query(wolfram_code: str) -> str:
    """Convert Mathematica syntax to Wolfram Alpha query."""
    if not wolfram_code:
        return None

    # Simple conversions
    query = wolfram_code

    # Remove Mathematica-specific constructs
    if 'If[' in query or ':=' in query or ';' in query:
        # Try to extract the numerical part
        # Look for N[...] or simple expressions
        n_match = re.search(r'N\[([^,\]]+)', query)
        if n_match:
            query = n_match.group(1)
        else:
            return None

    # ArcSin -> arcsin
    query = re.sub(r'ArcSin\[', 'arcsin(', query)
    query = re.sub(r'ArcCos\[', 'arccos(', query)
    query = re.sub(r'ArcTan\[', 'arctan(', query)
    query = re.sub(r'Sqrt\[', 'sqrt(', query)
    query = re.sub(r'Log\[', 'log(', query)
    query = re.sub(r'Exp\[', 'exp(', query)

    # Square brackets to parentheses
    query = query.replace('[', '(').replace(']', ')')

    # Pi -> pi
    query = query.replace('Pi', 'pi')

    # Clean up
    query = query.strip()
    if query.endswith(';'):
        query = query[:-1]

    # If still complex, skip
    if any(x in query for x in ['Module', 'Block', 'Function', 'Table']):
        return None

    return query


def load_gates() -> list:
    """Load gates from JSON."""
    gates_path = os.path.join(os.path.dirname(__file__), '..', 'AutoGenerated', 'GATES_72_v16_2.json')
    with open(gates_path, 'r', encoding='utf-8') as f:
        data = json.load(f)
    return data.get('gates', [])


def validate_gate(gate: dict, app_id: str) -> dict:
    """Validate a single gate."""
    gate_id = gate.get('id', 0)
    name = gate.get('name', '')
    formula = gate.get('formula', '')
    wolfram_code = gate.get('wolfram', '')
    expected = gate.get('derived')

    print(f"G{gate_id:02d}: {name}... ", end='', flush=True)

    # Convert Mathematica to query
    query = convert_mathematica_to_query(wolfram_code)

    result = {
        "gate_id": gate_id,
        "name": name,
        "formula": formula,
        "domain": gate.get('domain', ''),
        "block": gate.get('block', ''),
        "phase": gate.get('phase', 0),
        "wolfram_link": None,
        "status": "NOT_TESTABLE"
    }

    if not query:
        print("SKIP (complex Mathematica)")
        return result

    result["query"] = query
    result["wolfram_link"] = f"https://www.wolframalpha.com/input/?i={urllib.parse.quote(query)}"

    # Query Wolfram Alpha
    response = query_wolfram(query, app_id)
    wolfram_text, error = extract_result(response)

    if error:
        result["status"] = "ERROR"
        result["error"] = error
        print(f"ERROR: {error}")
        return result

    result["wolfram_result"] = wolfram_text
    wolfram_numeric = parse_numeric(wolfram_text)

    if wolfram_numeric is not None:
        result["wolfram_numeric"] = wolfram_numeric

        if expected is not None:
            expected_float = float(expected)
            if abs(expected_float) > 1e-10:
                rel_error = abs(wolfram_numeric - expected_float) / abs(expected_float)
            else:
                rel_error = abs(wolfram_numeric - expected_float)

            result["expected"] = expected
            result["relative_error"] = rel_error

            if rel_error < 0.001:
                result["status"] = "MATCH"
                result["match"] = True
                print(f"MATCH: {wolfram_text}")
            elif rel_error < 0.01:
                result["status"] = "CLOSE"
                result["match"] = True
                print(f"CLOSE: {wolfram_text}")
            else:
                result["status"] = "MISMATCH"
                result["match"] = False
                print(f"MISMATCH: {wolfram_text} (expected {expected})")
        else:
            result["status"] = "COMPUTED"
            result["match"] = True
            print(f"COMPUTED: {wolfram_text}")
    else:
        result["status"] = "PARSE_ERROR"
        result["match"] = False
        print(f"PARSE_ERROR: {wolfram_text}")

    return result


def main():
    if not WOLFRAM_APP_ID:
        print("ERROR: No Wolfram App ID configured")
        sys.exit(1)

    print("=" * 60)
    print("PRINCIPIA METAPHYSICA v16.2 - 72 Gates Validation")
    print("=" * 60)
    print()

    gates = load_gates()
    print(f"Loaded {len(gates)} gates from GATES_72_v16_2.json")
    print()

    results = []
    validated = 0
    skipped = 0

    for gate in gates:
        result = validate_gate(gate, WOLFRAM_APP_ID)
        results.append(result)

        if result["status"] in ["MATCH", "CLOSE", "COMPUTED"]:
            validated += 1
        elif result["status"] == "NOT_TESTABLE":
            skipped += 1

        # Rate limit
        if result.get("query"):
            time.sleep(1)

    # Summary
    print()
    print("=" * 60)
    print(f"VALIDATION COMPLETE")
    print(f"  Validated: {validated}")
    print(f"  Skipped (complex Mathematica): {skipped}")
    print(f"  Errors: {len(results) - validated - skipped}")
    print("=" * 60)

    # Save results
    output_path = os.path.join(os.path.dirname(__file__), '..', 'AutoGenerated', 'wolfram_results.json')
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump({
            "version": "16.2",
            "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S"),
            "total_gates": len(gates),
            "validated": validated,
            "skipped": skipped,
            "results": results
        }, f, indent=2, ensure_ascii=False)

    print(f"\nResults saved to: {output_path}")


if __name__ == "__main__":
    main()
