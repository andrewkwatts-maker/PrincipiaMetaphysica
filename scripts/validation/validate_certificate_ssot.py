#!/usr/bin/env python3
"""
Certificate SSOT (Single Source of Truth) Compliance Validator
===============================================================

This script validates that certificates in CERTIFICATES_v16_2_FINAL.json
are in sync with computed parameters in parameters.json and formulas in
formulas.json.

For each certificate:
1. Extracts the parameter it claims to validate
2. Gets the computed value from parameters.json
3. Gets the experimental target and uncertainty
4. Recomputes sigma_deviation = |computed - experimental| / uncertainty
5. Compares to the sigma_deviation stored in the certificate
6. Reports any inconsistencies

Validation checks:
- All certificate parameters exist in parameters.json
- All certificate formulas exist in formulas.json
- sigma_deviation values are current (not stale from old runs)

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.

Dedicated To:
    My Wife: Elizabeth May Watts
    Our Messiah: Jesus Of Nazareth
"""

import json
import os
import sys
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple
from pathlib import Path

# Tolerance for sigma deviation comparison (floating point tolerance)
SIGMA_TOLERANCE = 0.05


@dataclass
class CertificateIssue:
    """Represents an issue found during certificate validation."""
    cert_id: str
    issue_type: str  # 'missing_param', 'missing_formula', 'stale_sigma', 'value_mismatch'
    message: str
    severity: str = "WARNING"  # 'ERROR', 'WARNING', 'INFO'
    details: Dict[str, Any] = field(default_factory=dict)


@dataclass
class CertificateValidation:
    """Validation result for a single certificate."""
    cert_id: str
    parameter: str
    is_compliant: bool
    computed_value: Optional[float]
    target_value: float
    experimental_target: float
    experimental_uncertainty: float
    stored_sigma: float
    recomputed_sigma: Optional[float]
    issues: List[CertificateIssue] = field(default_factory=list)


@dataclass
class ComplianceReport:
    """Overall compliance report."""
    timestamp: str
    certificates_file: str
    parameters_file: str
    formulas_file: str
    total_certificates: int
    fully_compliant: int
    stale_sigma_values: int
    missing_parameters: int
    missing_formulas: int
    value_mismatches: int
    validations: List[CertificateValidation] = field(default_factory=list)
    issues: List[CertificateIssue] = field(default_factory=list)


class CertificateSSOTValidator:
    """
    Validates certificate SSOT compliance.

    Ensures certificates, parameters, and formulas are in sync.
    """

    def __init__(self, base_path: str = None):
        """
        Initialize the validator.

        Args:
            base_path: Base path to the repository. If None, auto-detect.
        """
        if base_path is None:
            # Auto-detect: go up from scripts directory
            script_dir = Path(__file__).parent
            base_path = script_dir.parent

        self.base_path = Path(base_path)
        self.autogen_path = self.base_path / "AutoGenerated"

        # File paths
        self.certificates_file = self.autogen_path / "CERTIFICATES_v16_2_FINAL.json"
        self.parameters_file = self.autogen_path / "parameters.json"
        self.formulas_file = self.autogen_path / "formulas.json"

        # Loaded data
        self.certificates: Dict[str, Any] = {}
        self.parameters: Dict[str, Any] = {}
        self.formulas: Dict[str, Any] = {}

        # Parameter name mapping (certificate param -> parameters.json keys)
        self.param_mapping = self._build_param_mapping()

    def _build_param_mapping(self) -> Dict[str, List[str]]:
        """
        Build mapping from certificate parameter names to parameters.json keys.

        The certificates use human-readable names like 'hubble_constant',
        while parameters.json uses dotted paths like 'cosmology.H0'.
        """
        return {
            # Cosmology
            "hubble_constant": [
                "cosmology.H0_local", "cosmology.H0_late_evolved", "cosmology.H0",
                "cosmology.H0_derived", "pneuma.H0_predicted", "desi.H0"
            ],
            "w0_dark_energy": [
                "cosmology.w0_derived", "cosmology.w0_thawing", "cosmology.w0",
                "desi.w0", "geometry.w0"
            ],
            "wa_evolution": [
                "cosmology.wa_derived", "cosmology.wa_thawing", "cosmology.wa",
                "desi.wa", "geometry.wa"
            ],
            "sigma8_amplitude": [
                "geometry.sigma8", "cosmology.sigma8_pred", "cosmology.sigma8",
                "desi.sigma8"
            ],
            "s8_structure": [
                "desi.S8", "cosmology.S8", "cosmology.S8_derived", "planck.S8"
            ],
            "spectral_index": [
                "geometry.n_s", "cosmology.n_s_pred", "cosmology.n_s",
                "cosmology.ns_derived", "planck.n_s"
            ],
            "cmb_temperature": [
                "cosmology.T_CMB", "thermal.T_CMB", "planck.T_CMB",
                "geometry.T_CMB", "constants.T_CMB"
            ],
            "baryon_photon_ratio": [
                "cosmology.eta_baryon", "cosmology.eta", "bbn.eta",
                "geometry.eta_baryon", "constants.eta_baryon"
            ],

            # Electroweak / QED
            "alpha_inverse": [
                "geometry.alpha_inverse", "qed.alpha_inverse",
                "constants.alpha_em_inverse", "geometric.alpha_inverse"
            ],
            "alpha_s_MZ": [
                "pdg.alpha_s_MZ", "geometry.alpha_s", "constants.alpha_s_pred",
                "gauge.alpha_s_MZ", "qed.alpha_s", "constants.alpha_s"
            ],
            "sin2_theta_W": [
                "pdg.sin2_theta_W", "geometry.sin2_theta_W", "constants.sin2_theta_W_pred",
                "gauge.sin2_theta_W", "qed.sin2_theta_W", "constants.sin2_theta_W"
            ],
            "fermi_constant": [
                "geometry.G_F", "constants.G_F_pred", "gauge.G_F",
                "constants.G_F", "qed.G_F", "pdg.G_F"
            ],
            "gut_coupling": [
                "gauge.ALPHA_GUT", "gauge.alpha_GUT", "gauge.ALPHA_GUT_GEOMETRIC",
                "gut.alpha_GUT", "geometry.alpha_GUT"
            ],

            # Higgs
            "higgs_vev": [
                "higgs.v_derived", "higgs.v", "higgs.vev", "geometry.higgs_vev"
            ],
            "higgs_mass": [
                "pdg.m_higgs", "higgs.m_H", "higgs.m_higgs", "geometry.m_higgs"
            ],

            # Planck scale - use derived 4D mass, not input reduced mass
            "M_Pl_4D": [
                "geometry.m_planck_4d", "cosmology.M_Pl_4D", "planck.M_Pl_4D",
                "gauge.M_Pl_4D", "geometry.M_Pl"
            ],

            # Mass ratios
            "proton_electron_ratio": [
                "fermion.mu_pe", "constants.mu_pe", "proton.mu_pe", "geometry.mu_pe"
            ],

            # Neutrino
            "neutrino_theta_12": [
                "neutrino.theta_12", "pmns.theta_12", "geometry.theta_12"
            ],
            "neutrino_theta_23": [
                "neutrino.theta_23", "pmns.theta_23", "geometry.theta_23"
            ],
            "neutrino_theta_13": [
                "neutrino.theta_13", "pmns.theta_13", "geometry.theta_13"
            ],
            "neutrino_delta_cp": [
                "neutrino.delta_cp", "pmns.delta_cp", "geometry.delta_cp"
            ],
            "neutrino_mass_sum": [
                "neutrino.sum_m_nu", "neutrino.mass_sum", "geometry.sum_m_nu"
            ],

            # CKM
            "CKM_V_us": [
                "pdg.V_us", "geometry.V_us", "ckm.V_us", "ckm.V_us_triality",
                "fermion.V_us"
            ],
            "CKM_V_cb": [
                "pdg.V_cb", "geometry.V_cb", "ckm.V_cb", "ckm.V_cb_triality",
                "fermion.V_cb"
            ],
            "CKM_V_ub": [
                "pdg.V_ub", "geometry.V_ub", "ckm.V_ub", "ckm.V_ub_triality",
                "fermion.V_ub"
            ],
            "jarlskog_invariant": [
                "pdg.J_CP", "ckm.jarlskog_invariant", "ckm.jarlskog_triality",
                "geometry.J_CP", "fermion.J_CP"
            ],

            # Meta
            "unity_seal": [
                "geometry.unity_seal", "validation.unity_seal",
                "unity.I_unity", "topology.unity_seal"
            ],
        }

    def load_data(self) -> bool:
        """
        Load certificates, parameters, and formulas from JSON files.

        Returns:
            True if all files loaded successfully, False otherwise.
        """
        success = True

        # Load certificates
        try:
            with open(self.certificates_file, 'r', encoding='utf-8') as f:
                self.certificates = json.load(f)
            print(f"[OK] Loaded certificates from {self.certificates_file.name}")
        except FileNotFoundError:
            print(f"[ERROR] Certificates file not found: {self.certificates_file}")
            success = False
        except json.JSONDecodeError as e:
            print(f"[ERROR] Invalid JSON in certificates file: {e}")
            success = False

        # Load parameters
        try:
            with open(self.parameters_file, 'r', encoding='utf-8') as f:
                self.parameters = json.load(f)
            print(f"[OK] Loaded parameters from {self.parameters_file.name}")
        except FileNotFoundError:
            print(f"[ERROR] Parameters file not found: {self.parameters_file}")
            success = False
        except json.JSONDecodeError as e:
            print(f"[ERROR] Invalid JSON in parameters file: {e}")
            success = False

        # Load formulas
        try:
            with open(self.formulas_file, 'r', encoding='utf-8') as f:
                self.formulas = json.load(f)
            print(f"[OK] Loaded formulas from {self.formulas_file.name}")
        except FileNotFoundError:
            print(f"[ERROR] Formulas file not found: {self.formulas_file}")
            success = False
        except json.JSONDecodeError as e:
            print(f"[ERROR] Invalid JSON in formulas file: {e}")
            success = False

        return success

    def get_parameter_value(self, cert_param: str) -> Tuple[Optional[float], Optional[str]]:
        """
        Get the computed value for a certificate parameter.

        Args:
            cert_param: Certificate parameter name (e.g., 'hubble_constant')

        Returns:
            Tuple of (value, source_key) or (None, None) if not found
        """
        params_data = self.parameters.get("parameters", {})

        # Try mapped keys first
        if cert_param in self.param_mapping:
            for key in self.param_mapping[cert_param]:
                if key in params_data:
                    entry = params_data[key]
                    if isinstance(entry, dict) and "value" in entry:
                        return entry["value"], key
                    elif isinstance(entry, (int, float)):
                        return entry, key

        # Try direct match (parameter name as-is)
        if cert_param in params_data:
            entry = params_data[cert_param]
            if isinstance(entry, dict) and "value" in entry:
                return entry["value"], cert_param
            elif isinstance(entry, (int, float)):
                return entry, cert_param

        # Try fuzzy match (search for substring)
        for key, entry in params_data.items():
            if cert_param.lower().replace('_', '') in key.lower().replace('_', '').replace('.', ''):
                if isinstance(entry, dict) and "value" in entry:
                    return entry["value"], key
                elif isinstance(entry, (int, float)):
                    return entry, key

        return None, None

    def formula_exists(self, formula_text: str) -> bool:
        """
        Check if a formula (or similar) exists in formulas.json.

        This does a fuzzy match since certificate formulas may be
        simplified versions of the full formula entries.

        Args:
            formula_text: The formula string from the certificate

        Returns:
            True if a matching formula exists
        """
        formulas_data = self.formulas.get("formulas", {})

        # Extract key terms from the formula
        formula_lower = formula_text.lower()

        for formula_id, formula_entry in formulas_data.items():
            if not isinstance(formula_entry, dict):
                continue

            # Check formula ID match
            if formula_id.lower() in formula_lower or formula_lower in formula_id.lower():
                return True

            # Check plain_text match
            plain_text = formula_entry.get("plain_text", "").lower()
            if plain_text and (plain_text in formula_lower or formula_lower in plain_text):
                return True

            # Check description match
            desc = formula_entry.get("description", "").lower()
            if desc:
                # Check for key parameter names
                for param in ["alpha", "theta", "higgs", "planck", "hubble", "w0", "wa"]:
                    if param in formula_lower and param in desc:
                        return True

        # If we can't find an exact match, check if the formula uses known symbols
        known_symbols = ["k_gimel", "b3", "phi", "chi_eff", "pi"]
        for symbol in known_symbols:
            if symbol in formula_lower:
                # Formula uses PM constants, assume it's defined somewhere
                return True

        return False

    def compute_sigma_deviation(
        self,
        computed: float,
        experimental: float,
        uncertainty: float
    ) -> float:
        """
        Compute sigma deviation between computed and experimental values.

        sigma = |computed - experimental| / uncertainty

        Args:
            computed: Computed/predicted value
            experimental: Experimental target value
            uncertainty: Experimental uncertainty (1-sigma)

        Returns:
            Sigma deviation
        """
        if uncertainty <= 0:
            return float('inf')
        return abs(computed - experimental) / uncertainty

    def validate_certificate(self, cert: Dict[str, Any]) -> CertificateValidation:
        """
        Validate a single certificate.

        Args:
            cert: Certificate dictionary

        Returns:
            CertificateValidation result
        """
        cert_id = cert.get("id", "UNKNOWN")
        parameter = cert.get("parameter", "")
        target_value = cert.get("target_value", 0.0)
        exp_target = cert.get("experimental_target", 0.0)
        exp_uncertainty = cert.get("experimental_uncertainty", 1.0)
        stored_sigma = cert.get("sigma_deviation", 0.0)
        formula = cert.get("formula", "")

        issues: List[CertificateIssue] = []

        # Get computed value from parameters
        computed_value, param_source = self.get_parameter_value(parameter)

        # Check if parameter exists
        if computed_value is None:
            issues.append(CertificateIssue(
                cert_id=cert_id,
                issue_type="missing_param",
                message=f"Parameter '{parameter}' not found in parameters.json",
                severity="ERROR",
                details={"searched_keys": self.param_mapping.get(parameter, [parameter])}
            ))

        # Check if formula exists
        if formula and not self.formula_exists(formula):
            issues.append(CertificateIssue(
                cert_id=cert_id,
                issue_type="missing_formula",
                message=f"Formula not found in formulas.json: {formula[:50]}...",
                severity="WARNING",
                details={"formula": formula}
            ))

        # Compute sigma deviation
        recomputed_sigma = None
        if computed_value is not None and exp_uncertainty > 0:
            recomputed_sigma = self.compute_sigma_deviation(
                computed_value, exp_target, exp_uncertainty
            )

            # Check if sigma is stale
            sigma_diff = abs(recomputed_sigma - stored_sigma)
            if sigma_diff > SIGMA_TOLERANCE:
                issues.append(CertificateIssue(
                    cert_id=cert_id,
                    issue_type="stale_sigma",
                    message=(
                        f"Stale sigma: stored={stored_sigma:.2f}, "
                        f"recomputed={recomputed_sigma:.2f} (diff={sigma_diff:.2f})"
                    ),
                    severity="WARNING",
                    details={
                        "stored_sigma": stored_sigma,
                        "recomputed_sigma": recomputed_sigma,
                        "difference": sigma_diff,
                        "computed_value": computed_value,
                        "param_source": param_source,
                        "experimental_target": exp_target,
                        "experimental_uncertainty": exp_uncertainty,
                    }
                ))

            # Check if computed matches target
            if target_value != 0:
                value_diff_pct = abs(computed_value - target_value) / abs(target_value) * 100
                if value_diff_pct > 1.0:  # More than 1% difference
                    issues.append(CertificateIssue(
                        cert_id=cert_id,
                        issue_type="value_mismatch",
                        message=(
                            f"Value mismatch: computed={computed_value:.6g}, "
                            f"cert_target={target_value:.6g} ({value_diff_pct:.2f}% diff)"
                        ),
                        severity="INFO",
                        details={
                            "computed_value": computed_value,
                            "target_value": target_value,
                            "difference_percent": value_diff_pct,
                        }
                    ))

        is_compliant = len([i for i in issues if i.severity == "ERROR"]) == 0

        return CertificateValidation(
            cert_id=cert_id,
            parameter=parameter,
            is_compliant=is_compliant,
            computed_value=computed_value,
            target_value=target_value,
            experimental_target=exp_target,
            experimental_uncertainty=exp_uncertainty,
            stored_sigma=stored_sigma,
            recomputed_sigma=recomputed_sigma,
            issues=issues,
        )

    def validate_all(self) -> ComplianceReport:
        """
        Validate all certificates and generate compliance report.

        Returns:
            ComplianceReport with all validation results
        """
        certs = self.certificates.get("certificates", [])
        validations: List[CertificateValidation] = []
        all_issues: List[CertificateIssue] = []

        # Counters
        fully_compliant = 0
        stale_sigma = 0
        missing_params = 0
        missing_formulas = 0
        value_mismatches = 0

        for cert in certs:
            validation = self.validate_certificate(cert)
            validations.append(validation)
            all_issues.extend(validation.issues)

            if validation.is_compliant and len(validation.issues) == 0:
                fully_compliant += 1

            for issue in validation.issues:
                if issue.issue_type == "stale_sigma":
                    stale_sigma += 1
                elif issue.issue_type == "missing_param":
                    missing_params += 1
                elif issue.issue_type == "missing_formula":
                    missing_formulas += 1
                elif issue.issue_type == "value_mismatch":
                    value_mismatches += 1

        return ComplianceReport(
            timestamp=datetime.now().isoformat(),
            certificates_file=str(self.certificates_file),
            parameters_file=str(self.parameters_file),
            formulas_file=str(self.formulas_file),
            total_certificates=len(certs),
            fully_compliant=fully_compliant,
            stale_sigma_values=stale_sigma,
            missing_parameters=missing_params,
            missing_formulas=missing_formulas,
            value_mismatches=value_mismatches,
            validations=validations,
            issues=all_issues,
        )

    def print_report(self, report: ComplianceReport) -> None:
        """
        Print a formatted compliance report.

        Args:
            report: The compliance report to print
        """
        print("\n" + "=" * 80)
        print("CERTIFICATE SSOT COMPLIANCE REPORT")
        print("=" * 80)
        print(f"Timestamp: {report.timestamp}")
        print(f"Certificates: {report.certificates_file}")
        print(f"Parameters: {report.parameters_file}")
        print(f"Formulas: {report.formulas_file}")
        print("-" * 80)

        # Summary statistics
        print("\nSUMMARY:")
        print(f"  Total Certificates:    {report.total_certificates}")
        print(f"  Fully Compliant:       {report.fully_compliant}")
        print(f"  Stale Sigma Values:    {report.stale_sigma_values}")
        print(f"  Missing Parameters:    {report.missing_parameters}")
        print(f"  Missing Formulas:      {report.missing_formulas}")
        print(f"  Value Mismatches:      {report.value_mismatches}")

        compliance_pct = (report.fully_compliant / report.total_certificates * 100
                         if report.total_certificates > 0 else 0)
        print(f"\n  Compliance Rate:       {compliance_pct:.1f}%")

        # Detailed issues
        if report.issues:
            print("\n" + "-" * 80)
            print("ISSUES FOUND:")
            print("-" * 80)

            # Group by severity
            errors = [i for i in report.issues if i.severity == "ERROR"]
            warnings = [i for i in report.issues if i.severity == "WARNING"]
            infos = [i for i in report.issues if i.severity == "INFO"]

            if errors:
                print(f"\n[ERRORS] ({len(errors)}):")
                for issue in errors:
                    print(f"  [{issue.cert_id}] {issue.message}")

            if warnings:
                print(f"\n[WARNINGS] ({len(warnings)}):")
                for issue in warnings:
                    print(f"  [{issue.cert_id}] {issue.message}")
                    if issue.issue_type == "stale_sigma" and "details" in issue.__dict__:
                        details = issue.details
                        print(f"    - Computed value: {details.get('computed_value', 'N/A')}")
                        print(f"    - Source param: {details.get('param_source', 'N/A')}")
                        print(f"    - Exp. target: {details.get('experimental_target', 'N/A')}")
                        print(f"    - Exp. uncertainty: {details.get('experimental_uncertainty', 'N/A')}")

            if infos:
                print(f"\n[INFO] ({len(infos)}):")
                for issue in infos[:10]:  # Limit to first 10
                    print(f"  [{issue.cert_id}] {issue.message}")
                if len(infos) > 10:
                    print(f"  ... and {len(infos) - 10} more")

        # Certificate detail table
        print("\n" + "-" * 80)
        print("CERTIFICATE VALIDATION DETAILS:")
        print("-" * 80)
        print(f"{'ID':<20} {'Parameter':<25} {'Stored sig':>10} {'Recomp sig':>10} {'Status':>10}")
        print("-" * 80)

        for v in report.validations:
            recomp = f"{v.recomputed_sigma:.2f}" if v.recomputed_sigma is not None else "N/A"
            status = "OK" if v.is_compliant and len(v.issues) == 0 else "ISSUES"
            if not v.is_compliant:
                status = "FAIL"
            print(f"{v.cert_id:<20} {v.parameter:<25} {v.stored_sigma:>10.2f} {recomp:>10} {status:>10}")

        print("=" * 80)

    def save_report(self, report: ComplianceReport, output_file: str = None) -> str:
        """
        Save the compliance report to a JSON file.

        Args:
            report: The compliance report
            output_file: Output file path. If None, auto-generate.

        Returns:
            Path to the saved report
        """
        if output_file is None:
            output_file = self.autogen_path / "certificate_compliance_report.json"

        # Convert dataclasses to dicts for JSON serialization
        report_dict = {
            "timestamp": report.timestamp,
            "certificates_file": report.certificates_file,
            "parameters_file": report.parameters_file,
            "formulas_file": report.formulas_file,
            "summary": {
                "total_certificates": report.total_certificates,
                "fully_compliant": report.fully_compliant,
                "stale_sigma_values": report.stale_sigma_values,
                "missing_parameters": report.missing_parameters,
                "missing_formulas": report.missing_formulas,
                "value_mismatches": report.value_mismatches,
                "compliance_rate": (
                    report.fully_compliant / report.total_certificates * 100
                    if report.total_certificates > 0 else 0
                ),
            },
            "validations": [
                {
                    "cert_id": v.cert_id,
                    "parameter": v.parameter,
                    "is_compliant": v.is_compliant,
                    "computed_value": v.computed_value,
                    "target_value": v.target_value,
                    "experimental_target": v.experimental_target,
                    "experimental_uncertainty": v.experimental_uncertainty,
                    "stored_sigma": v.stored_sigma,
                    "recomputed_sigma": v.recomputed_sigma,
                    "issues": [
                        {
                            "issue_type": i.issue_type,
                            "message": i.message,
                            "severity": i.severity,
                            "details": i.details,
                        }
                        for i in v.issues
                    ],
                }
                for v in report.validations
            ],
        }

        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(report_dict, f, indent=2)

        print(f"\nReport saved to: {output_file}")
        return str(output_file)


def main():
    """Main entry point for certificate SSOT validation."""
    print("Certificate SSOT Compliance Validator v1.0")
    print("-" * 50)

    # Initialize validator
    validator = CertificateSSOTValidator()

    # Load data
    if not validator.load_data():
        print("\n[FATAL] Failed to load required data files. Exiting.")
        sys.exit(1)

    # Run validation
    print("\nValidating certificates...")
    report = validator.validate_all()

    # Print report
    validator.print_report(report)

    # Save report
    validator.save_report(report)

    # Exit with appropriate code
    if report.missing_parameters > 0:
        sys.exit(2)  # Missing parameters is a critical issue
    elif report.stale_sigma_values > 0:
        sys.exit(1)  # Stale sigma values need attention
    else:
        sys.exit(0)  # All good


if __name__ == "__main__":
    main()
