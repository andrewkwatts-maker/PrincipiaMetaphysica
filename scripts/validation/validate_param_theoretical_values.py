#!/usr/bin/env python3
"""
Validate that all PM Parameters have theoretical values.

This script identifies parameters that are missing:
1. theoretical_value - the predicted value from the framework
2. experimental_value - the measured value for comparison
3. uncertainty - the experimental error

For the OOM table to work correctly, each testable parameter needs:
- A theoretical value (from simulation derivation)
- An experimental value (from PDG/CODATA/etc.)
- An uncertainty (for sigma deviation calculation)

Usage:
    python scripts/validate_param_theoretical_values.py

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
"""

import json
import os
import sys
from typing import Dict, Any, List, Tuple

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
PARAMETERS_FILE = os.path.join(PROJECT_ROOT, "AutoGenerated", "parameters.json")
CERTIFICATES_FILE = os.path.join(PROJECT_ROOT, "AutoGenerated", "CERTIFICATES_v16_2_FINAL.json")


def load_json(filepath: str) -> Dict[str, Any]:
    """Load a JSON file."""
    with open(filepath, 'r', encoding='utf-8') as f:
        return json.load(f)


def is_testable_param(param: Dict[str, Any], path: str = '') -> bool:
    """Check if a parameter is testable (needs experimental comparison)."""
    status = param.get('status', '')
    metadata = param.get('metadata', {})

    # Skip system params (non-scientific)
    if status == 'SYSTEM':
        return False

    # Skip framework_statistics.* and validation.* (computed stats)
    if 'framework_statistics' in str(param.get('source', '')):
        return False
    if 'generate_statistics' in str(param.get('source', '')):
        return False

    # Skip if explicitly marked as not scientific
    if metadata.get('is_scientific') is False:
        return False
    if metadata.get('display_in_params') is False:
        return False

    # Skip purely mathematical/topological constants
    if status in ['GEOMETRIC', 'AXIOM']:
        return False

    # Skip internal framework quantities by path prefix
    internal_prefixes = [
        'chirality.',      # Internal index computations
        'moduli.',         # Moduli space parameters
        'ckm.',            # CKM matrix elements (computed internally)
        'pmns.',           # PMNS matrix elements (computed internally)
        'unitary.',        # Unitarity checks
        'brane.',          # Internal brane parameters
        'flux.',           # Flux quantization
        'bulk.',           # Bulk parameters
        'validation.',     # Validation stats
        'framework_statistics.',  # Framework stats
        'cosmology.',      # Internal cosmology calculations (except key observables)
        'geometry.',       # Internal geometric quantities
        'topology.',       # Internal topological quantities
        'gauge.',          # Internal gauge quantities
        'higgs.',          # Internal Higgs quantities (except mass)
        'neutrino.delta_m', # Delta m squared differences (internal)
        'qcd.',            # Internal QCD quantities
        'pneuma.',         # Internal pneuma quantities
        'thermal.',        # Internal thermal quantities
        'dirac.',          # Internal Dirac operator quantities
        'master_action.',  # Internal master action quantities
        'qed.',            # Internal QED quantities
        'quantum_bio.',    # Internal quantum bio quantities
        'fermion.',        # Internal fermion quantities (except masses)
        'proton.',         # Internal proton quantities
        'gates.',          # Gate verification stats
        'predictions.',    # Prediction summaries
        'proton_decay.',   # Proton decay predictions (future)
        'registry.',       # Registry stats
        'electromagnetic.',# EM internal quantities
        'funnel.',         # Funnel compression stats
        'physics.',        # Generic physics quantities
        'neutrino.',       # Neutrino internal (except mixing angles in observables)
        'seal.',           # Seal verification status
        'sterile.',        # Sterile sector verification
        'terminal.',       # Terminal state verification
        'triality.',       # Triality mixing (internal)
    ]

    # But allow certain key observable params
    observable_params = {
        'cosmology.H0', 'cosmology.w0', 'cosmology.wa',
        'cosmology.omega_m', 'cosmology.omega_lambda',
        'higgs.mass', 'higgs.vev',
        'neutrino.theta12', 'neutrino.theta13', 'neutrino.theta23',
        'fermion.m_electron', 'fermion.m_muon', 'fermion.m_tau',
        'proton.mass', 'proton.radius',
    }

    if path in observable_params:
        return True

    for prefix in internal_prefixes:
        if path.startswith(prefix):
            return False

    # Testable statuses need experimental comparison
    return status in ['DERIVED', 'PREDICTED', 'ESTABLISHED', 'CALIBRATED', 'NUMEROLOGICAL_FIT']


def find_missing_theoretical_values(params: Dict[str, Any]) -> List[Tuple[str, str]]:
    """Find parameters missing theoretical values."""
    missing = []

    for path, param in params.items():
        if not isinstance(param, dict):
            continue

        if not is_testable_param(param, path):
            continue

        # Check for theoretical value
        has_theoretical = (
            param.get('theoretical_value') is not None or
            param.get('derived_value') is not None or
            param.get('value') is not None
        )

        if not has_theoretical:
            missing.append((path, 'theoretical_value'))

    return missing


def find_missing_experimental_values(params: Dict[str, Any]) -> List[Tuple[str, str]]:
    """Find parameters missing experimental values."""
    missing = []

    for path, param in params.items():
        if not isinstance(param, dict):
            continue

        if not is_testable_param(param, path):
            continue

        # Skip if marked as no experimental value
        if param.get('no_experimental_value') or param.get('metadata', {}).get('no_experimental_value'):
            continue

        # Check for experimental value
        has_experimental = (
            param.get('experimental_value') is not None or
            param.get('experimental_bound') is not None or
            param.get('metadata', {}).get('experimental_value') is not None or
            param.get('metadata', {}).get('experimental_bound') is not None
        )

        if not has_experimental:
            missing.append((path, 'experimental_value'))

    return missing


def find_missing_uncertainty(params: Dict[str, Any]) -> List[Tuple[str, str]]:
    """Find parameters missing uncertainty values."""
    missing = []

    for path, param in params.items():
        if not isinstance(param, dict):
            continue

        if not is_testable_param(param, path):
            continue

        # Skip if marked as no experimental value
        if param.get('no_experimental_value') or param.get('metadata', {}).get('no_experimental_value'):
            continue

        # Check for uncertainty
        has_uncertainty = (
            param.get('uncertainty') is not None or
            param.get('experimental_uncertainty') is not None or
            param.get('metadata', {}).get('uncertainty') is not None or
            param.get('metadata', {}).get('experimental_uncertainty') is not None or
            param.get('validation', {}).get('uncertainty') is not None
        )

        if not has_uncertainty:
            missing.append((path, 'uncertainty'))

    return missing


def analyze_certificates(certs_data: Dict[str, Any]) -> Dict[str, Any]:
    """Analyze certificate coverage."""
    certs = certs_data.get('certificates', [])

    covered_params = set()
    for cert in certs:
        param = cert.get('parameter', '')
        if param:
            covered_params.add(param)

    return {
        'total_certs': len(certs),
        'covered_params': covered_params,
        'certified_count': len(covered_params)
    }


def main():
    """Main entry point."""
    print("=" * 70)
    print("PM Parameter Theoretical Value Validator")
    print("=" * 70)

    # Load data
    params_data = load_json(PARAMETERS_FILE)
    params = params_data.get('parameters', {})

    print(f"\nLoaded {len(params)} parameters from parameters.json")

    # Find missing values
    missing_theoretical = find_missing_theoretical_values(params)
    missing_experimental = find_missing_experimental_values(params)
    missing_uncertainty = find_missing_uncertainty(params)

    # Report
    print("\n" + "-" * 70)
    print("MISSING THEORETICAL VALUES")
    print("-" * 70)
    if missing_theoretical:
        for path, field in sorted(missing_theoretical)[:20]:
            print(f"  {path}")
        if len(missing_theoretical) > 20:
            print(f"  ... and {len(missing_theoretical) - 20} more")
    else:
        print("  None - all testable parameters have theoretical values")
    print(f"\nTotal missing: {len(missing_theoretical)}")

    print("\n" + "-" * 70)
    print("MISSING EXPERIMENTAL VALUES (for testable predictions)")
    print("-" * 70)
    if missing_experimental:
        for path, field in sorted(missing_experimental)[:20]:
            print(f"  {path}")
        if len(missing_experimental) > 20:
            print(f"  ... and {len(missing_experimental) - 20} more")
    else:
        print("  None - all testable parameters have experimental values")
    print(f"\nTotal missing: {len(missing_experimental)}")

    print("\n" + "-" * 70)
    print("MISSING UNCERTAINTY VALUES")
    print("-" * 70)
    if missing_uncertainty:
        for path, field in sorted(missing_uncertainty)[:20]:
            print(f"  {path}")
        if len(missing_uncertainty) > 20:
            print(f"  ... and {len(missing_uncertainty) - 20} more")
    else:
        print("  None - all testable parameters have uncertainty values")
    print(f"\nTotal missing: {len(missing_uncertainty)}")

    # Certificate analysis
    if os.path.exists(CERTIFICATES_FILE):
        print("\n" + "-" * 70)
        print("CERTIFICATE ANALYSIS")
        print("-" * 70)
        certs_data = load_json(CERTIFICATES_FILE)
        cert_analysis = analyze_certificates(certs_data)
        print(f"  Total certificates: {cert_analysis['total_certs']}")
        print(f"  Covered parameters: {cert_analysis['certified_count']}")

    # Summary
    print("\n" + "=" * 70)
    print("SUMMARY")
    print("=" * 70)
    all_good = (
        len(missing_theoretical) == 0 and
        len(missing_experimental) == 0 and
        len(missing_uncertainty) == 0
    )

    if all_good:
        print("[PASS] All testable parameters have required values for OOM table")
        return 0
    else:
        print(f"[WARN] {len(missing_theoretical)} params missing theoretical values")
        print(f"[WARN] {len(missing_experimental)} params missing experimental values")
        print(f"[WARN] {len(missing_uncertainty)} params missing uncertainty values")
        print("\nTo fix: Add values to simulation output_param_definitions or update source data")
        return 1


if __name__ == "__main__":
    sys.exit(main())
