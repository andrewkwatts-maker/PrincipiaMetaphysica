#!/usr/bin/env python3
"""
Random Formula Validator - Principia Metaphysica

Pops a random formula from theory_output.json and validates:
  a) Uses code names for params, LaTeX from FormulasRegistry (not hardcoded)
  b) Has adequate metadata for derivations (steps, source sections/appendices)
  c) Has a related certificate
  d) Input/output params exist with required metadata

Run repeatedly to spot-check formula quality across the entire registry.

Usage:
    python scripts/validation/validate_random_formula.py
    python scripts/validation/validate_random_formula.py --all       # Check every formula
    python scripts/validation/validate_random_formula.py --id euler-characteristic  # Check specific
"""

import json
import os
import sys
import random
import re

# Ensure UTF-8 output on Windows
if hasattr(sys.stdout, 'reconfigure'):
    sys.stdout.reconfigure(encoding='utf-8')
from pathlib import Path

# Project root
PROJECT_ROOT = Path(__file__).parent.parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

# ─── Load Data ────────────────────────────────────────────────────────────────

def load_theory_output():
    path = PROJECT_ROOT / "AutoGenerated" / "theory_output.json"
    with open(path, 'r', encoding='utf-8') as f:
        return json.load(f)


def load_certificates():
    """Load all certificate files and build a lookup by gate/formula id."""
    cert_dir = PROJECT_ROOT / "AutoGenerated" / "certificates"
    certs = {}
    cert_list = []  # Keep raw list for fuzzy matching
    if cert_dir.exists():
        for cf in cert_dir.rglob("*.json"):
            try:
                with open(cf, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                data["_file"] = cf.stem
                data["_subdir"] = cf.parent.name
                cert_list.append(data)
                # Index by all available ID fields
                for key_field in ("id", "cert_id", "gate_id", "proof_id"):
                    key = data.get(key_field)
                    if key:
                        certs[str(key)] = data
                # Index by file stem
                certs[cf.stem] = data
                # Index by gate_name (normalized)
                gate_name = data.get("gate_name", "")
                if gate_name:
                    certs[gate_name.lower().replace(" ", "-")] = data
                    certs[gate_name.lower().replace(" ", "_")] = data
                # Index by formula_id or related_formulas if present
                if "formula_id" in data:
                    certs[data["formula_id"]] = data
                if "related_formulas" in data:
                    for rf in data["related_formulas"]:
                        if rf not in certs:
                            certs[rf] = data
            except (json.JSONDecodeError, KeyError):
                pass
    return certs, cert_list


def load_gates_certificates():
    """Load the 72-gate certificate master file."""
    path = PROJECT_ROOT / "AutoGenerated" / "GATES_72_CERTIFICATES.json"
    if path.exists():
        with open(path, 'r', encoding='utf-8') as f:
            return json.load(f)
    return {}


def load_latex_registry():
    """Load the FormulasRegistry for LaTeX lookup."""
    try:
        from simulations.core.FormulasRegistry import FormulasRegistry
        return FormulasRegistry
    except ImportError:
        return None


# ─── Validation Checks ───────────────────────────────────────────────────────

class FormulaValidationResult:
    def __init__(self, formula_id):
        self.formula_id = formula_id
        self.checks = []  # list of (check_name, passed: bool, detail: str)

    def add(self, name, passed, detail=""):
        self.checks.append((name, passed, detail))

    @property
    def passed(self):
        return all(c[1] for c in self.checks)

    @property
    def pass_count(self):
        return sum(1 for c in self.checks if c[1])

    @property
    def fail_count(self):
        return sum(1 for c in self.checks if not c[1])

    @property
    def warn_count(self):
        return sum(1 for c in self.checks if c[2].startswith("WARN"))

    def display(self):
        status = "PASS" if self.passed else "FAIL"
        print(f"\n{'='*72}")
        print(f"  FORMULA: {self.formula_id}")
        print(f"  STATUS:  {status} ({self.pass_count}/{len(self.checks)} checks passed)")
        print(f"{'='*72}")
        for name, passed, detail in self.checks:
            icon = "[OK]  " if passed else "[FAIL]"
            print(f"  {icon} {name}")
            if detail:
                # Indent detail lines
                for line in detail.split("\n"):
                    print(f"         {line}")
        print()


def validate_formula(formula_id, formula_data, theory_data, certs, cert_list, gates, registry):
    """Run all validation checks on a single formula."""
    result = FormulaValidationResult(formula_id)

    # ── Check A: Code names and LaTeX ─────────────────────────────────────

    # A1: Formula has an id matching its key
    result.add(
        "A1: Formula has valid ID",
        formula_data.get("id") == formula_id,
        f"id='{formula_data.get('id')}' vs key='{formula_id}'"
    )

    # A2: Formula has LaTeX
    latex = formula_data.get("latex", "")
    result.add(
        "A2: Has LaTeX expression",
        bool(latex),
        f"latex={latex[:80]}..." if len(latex) > 80 else f"latex={latex}"
    )

    # A3: Input params use code names (dot-notation like "topology.elder_kads")
    input_params = formula_data.get("input_params", [])
    output_params = formula_data.get("output_params", [])
    all_params = input_params + output_params

    if all_params:
        valid_names = all(
            re.match(r'^[a-z_]+\.[a-zA-Z0-9_.]+$', p) or
            re.match(r'^[a-z_]+$', p)
            for p in all_params
        )
        result.add(
            "A3: Params use code names",
            valid_names,
            f"params: {all_params[:5]}{'...' if len(all_params) > 5 else ''}"
        )
    else:
        result.add(
            "A3: Params use code names",
            True,
            "WARN: No input/output params declared"
        )

    # A4: LaTeX from registry (spot check - verify formula terms reference registry)
    if registry:
        terms = formula_data.get("terms", {})
        if terms and isinstance(terms, dict):
            registry_hits = 0
            registry_misses = []
            for term_key, term_data in terms.items():
                if isinstance(term_data, dict):
                    param_id = term_data.get("param_id", "")
                    # Extract the short name from param_id
                    short_name = param_id.split(".")[-1] if "." in param_id else param_id
                    try:
                        registry.get_latex(short_name)
                        registry_hits += 1
                    except (KeyError, AttributeError):
                        # Try the term key itself
                        try:
                            registry.get_latex(term_key)
                            registry_hits += 1
                        except (KeyError, AttributeError):
                            registry_misses.append(term_key)

            total = registry_hits + len(registry_misses)
            if total > 0:
                coverage = registry_hits / total
                result.add(
                    "A4: Terms have LaTeX registry entries",
                    coverage >= 0.5,
                    f"{registry_hits}/{total} terms found in registry" +
                    (f", missing: {registry_misses[:3]}" if registry_misses else "")
                )
            else:
                result.add("A4: Terms have LaTeX registry entries", True, "No terms to check")
        else:
            result.add(
                "A4: Terms have LaTeX registry entries",
                False,
                "WARN: No terms dict in formula"
            )
    else:
        result.add("A4: Terms have LaTeX registry entries", True, "WARN: Registry not loaded")

    # ── Check B: Derivation metadata ──────────────────────────────────────

    derivation = formula_data.get("derivation")
    if derivation and isinstance(derivation, dict):
        # B1: Has derivation steps
        steps = derivation.get("steps", [])
        result.add(
            "B1: Has derivation steps",
            len(steps) >= 1,
            f"{len(steps)} steps" + (f": {str(steps[0])[:60]}..." if steps else "")
        )

        # B2: Has source reference
        source = derivation.get("source", "")
        result.add(
            "B2: Has derivation source",
            bool(source),
            f"source: {source}" if source else "No source specified"
        )
    else:
        result.add("B1: Has derivation steps", False, "No derivation metadata")
        result.add("B2: Has derivation source", False, "No derivation metadata")

    # B3: Has label (section reference)
    label = formula_data.get("label", "")
    result.add(
        "B3: Has section label",
        bool(label),
        f"label: {label}"
    )

    # B4: Has category
    category = formula_data.get("category", "")
    result.add(
        "B4: Has category",
        bool(category),
        f"category: {category}"
    )

    # B5: Has description
    description = formula_data.get("description", "")
    result.add(
        "B5: Has description",
        bool(description) and len(description) > 10,
        f"description: {description[:80]}" if description else "No description"
    )

    # ── Check C: Related certificate ──────────────────────────────────────

    # Look for certificate by formula id or related keywords
    cert_match = None
    has_cert = (
        formula_id in certs or
        formula_id.replace("-", "_") in certs
    )

    # Check if formula category matches a certificate subdirectory
    if not has_cert:
        formula_cat = formula_data.get("category", "").lower()
        # Map formula categories to certificate subdirectories
        cat_map = {
            "geometry": "geometry", "topology": "geometry",
            "gauge": "gauge", "qcd": "gauge", "electroweak": "electroweak",
            "cosmology": "cosmology", "dark_energy": "cosmology",
            "gravity": "gravity", "gr": "gravity",
            "neutrino": "neutrino", "fermion": "particle",
            "higgs": "particle", "particle": "particle",
            "quantum": "field_dynamics", "field": "field_dynamics",
            "validation": "integrity", "integrity": "integrity",
        }
        target_subdir = cat_map.get(formula_cat, "")

        # Search cert_list for category-based match with keyword overlap
        fid_words = set(formula_id.replace("-", " ").replace("_", " ").lower().split())
        for cert in cert_list:
            cert_subdir = cert.get("_subdir", "")
            cert_name = cert.get("gate_name", "").lower()
            cert_words = set(cert_name.replace("-", " ").replace("_", " ").split())
            # Match if shared subdirectory AND keyword overlap
            if (cert_subdir == target_subdir and len(fid_words & cert_words) >= 1):
                has_cert = True
                cert_match = cert.get("gate_name", cert.get("_file", "?"))
                break

    # Also check 72-gate certificates
    if not has_cert and gates:
        gate_list = gates if isinstance(gates, list) else gates.get("certificates", [])
        for gate in gate_list:
            if isinstance(gate, dict):
                # Check by category match
                gate_cat = gate.get("category", "").lower()
                formula_cat = formula_data.get("category", "").lower()
                gate_name = gate.get("gate_name", "").lower()
                fid_lower = formula_id.lower().replace("-", " ")
                if gate_cat == formula_cat and any(w in gate_name for w in fid_lower.split() if len(w) > 3):
                    has_cert = True
                    cert_match = gate.get("gate_name", f"Gate #{gate.get('gate_id')}")
                    break

    result.add(
        "C1: Has related certificate",
        has_cert,
        f"Certificate: {cert_match}" if cert_match else
        (f"Certificate found for '{formula_id}'" if has_cert else
         f"No certificate found for '{formula_id}' (category: {formula_data.get('category', 'N/A')})")
    )

    # ── Check D: Input/output param metadata ──────────────────────────────

    params_data = theory_data.get("parameters", {})

    if input_params:
        missing_inputs = [p for p in input_params if p not in params_data]
        result.add(
            "D1: Input params exist in registry",
            len(missing_inputs) == 0,
            f"All {len(input_params)} inputs found" if not missing_inputs else
            f"Missing: {missing_inputs[:5]}"
        )

        # Check input param metadata quality
        metadata_issues = []
        for p in input_params:
            if p in params_data:
                pd = params_data[p]
                if isinstance(pd, dict):
                    if not pd.get("metadata", {}).get("description"):
                        metadata_issues.append(f"{p}: no description")
                    if pd.get("source") in (None, "", "UNKNOWN"):
                        metadata_issues.append(f"{p}: no source")

        result.add(
            "D2: Input params have metadata",
            len(metadata_issues) == 0,
            f"All inputs have metadata" if not metadata_issues else
            f"Issues: {'; '.join(metadata_issues[:3])}"
        )
    else:
        result.add("D1: Input params exist in registry", True, "No inputs declared")
        result.add("D2: Input params have metadata", True, "No inputs to check")

    if output_params:
        missing_outputs = [p for p in output_params if p not in params_data]
        result.add(
            "D3: Output params exist in registry",
            len(missing_outputs) == 0,
            f"All {len(output_params)} outputs found" if not missing_outputs else
            f"Missing: {missing_outputs[:5]}"
        )
    else:
        result.add("D3: Output params exist in registry", True,
                    "WARN: No output params declared")

    return result


# ─── Main ─────────────────────────────────────────────────────────────────────

def main():
    import argparse
    parser = argparse.ArgumentParser(description="Random Formula Validator")
    parser.add_argument("--all", action="store_true", help="Validate all formulas")
    parser.add_argument("--id", type=str, help="Validate a specific formula by ID")
    parser.add_argument("--count", type=int, default=1, help="Number of random formulas to check")
    parser.add_argument("--summary", action="store_true", help="Show summary statistics only")
    args = parser.parse_args()

    print("=" * 72)
    print("  PRINCIPIA METAPHYSICA - Random Formula Validator")
    print("=" * 72)

    # Load data
    theory = load_theory_output()
    certs, cert_list = load_certificates()
    gates = load_gates_certificates()
    registry = load_latex_registry()

    formulas = theory.get("formulas", {})
    formula_ids = list(formulas.keys())

    if not formula_ids:
        print("[ERROR] No formulas found in theory_output.json")
        sys.exit(1)

    print(f"\n  Loaded: {len(formula_ids)} formulas, {len(cert_list)} certificates")
    print(f"  Registry: {'loaded' if registry else 'NOT available'}")

    # Select formulas to validate
    if args.id:
        if args.id not in formulas:
            print(f"\n[ERROR] Formula '{args.id}' not found")
            print(f"  Available: {formula_ids[:10]}...")
            sys.exit(1)
        selected = [args.id]
    elif args.all:
        selected = formula_ids
    else:
        selected = random.sample(formula_ids, min(args.count, len(formula_ids)))

    # Run validation
    results = []
    for fid in selected:
        r = validate_formula(fid, formulas[fid], theory, certs, cert_list, gates, registry)
        results.append(r)
        if not args.summary:
            r.display()

    # Summary
    total_checks = sum(len(r.checks) for r in results)
    total_pass = sum(r.pass_count for r in results)
    total_fail = sum(r.fail_count for r in results)
    formulas_pass = sum(1 for r in results if r.passed)

    print("=" * 72)
    print("  SUMMARY")
    print("=" * 72)
    print(f"  Formulas checked:  {len(results)}/{len(formula_ids)}")
    print(f"  Formulas passing:  {formulas_pass}/{len(results)}")
    print(f"  Total checks:      {total_pass}/{total_checks} passed, {total_fail} failed")

    if total_fail > 0:
        print(f"\n  Failed formulas:")
        for r in results:
            if not r.passed:
                fails = [c[0] for c in r.checks if not c[1]]
                print(f"    {r.formula_id}: {', '.join(fails)}")

    print()
    return 0 if total_fail == 0 else 1


if __name__ == "__main__":
    sys.exit(main())
