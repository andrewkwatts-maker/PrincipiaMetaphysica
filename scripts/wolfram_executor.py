#!/usr/bin/env python3
"""
Wolfram Code Executor for Principia Metaphysica v16.2
======================================================

Executes Wolfram/Mathematica code from certificate JSON files and stores
results in a unified wolfram_results.json file.

Execution Methods (in order of preference):
1. wolframscript CLI (requires Wolfram Mathematica installed)
2. Wolfram Cloud API (requires API key)
3. Local symbolic approximation (fallback - limited accuracy)

Usage:
    python scripts/wolfram_executor.py [--method METHOD] [--force]

Options:
    --method    Execution method: wolframscript, cloud, or local (default: auto)
    --force     Re-execute even if results exist
    --verbose   Show detailed output

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
"""

import json
import os
import sys
import subprocess
import hashlib
import re
from pathlib import Path
from datetime import datetime, timezone
from typing import Dict, Any, Optional, List, Tuple

# Configuration
VERSION = "16.2"
CERTIFICATES_DIR = Path(__file__).parent.parent / "simulations" / "AutoGenerated" / "certificates"
RESULTS_FILE = Path(__file__).parent.parent / "simulations" / "AutoGenerated" / "wolfram_results.json"

# Wolfram Cloud API endpoint (if using cloud execution)
WOLFRAM_CLOUD_API = "https://www.wolframcloud.com/obj/api/compute"


def find_wolframscript() -> Optional[str]:
    """Find wolframscript executable on the system."""
    import shutil

    # Check PATH first
    ws = shutil.which("wolframscript")
    if ws:
        return ws

    # Check common installation paths
    if sys.platform == 'win32':
        common_paths = [
            r"C:\Program Files\Wolfram Research\Mathematica\*\wolframscript.exe",
            r"C:\Program Files\Wolfram Research\Wolfram Player\*\wolframscript.exe",
        ]
    elif sys.platform == 'darwin':
        common_paths = [
            "/Applications/Mathematica.app/Contents/MacOS/wolframscript",
            "/usr/local/bin/wolframscript",
        ]
    else:  # Linux
        common_paths = [
            "/usr/local/bin/wolframscript",
            "/opt/Wolfram/Mathematica/*/Executables/wolframscript",
        ]

    import glob
    for pattern in common_paths:
        matches = glob.glob(pattern)
        if matches:
            return matches[0]

    return None


def execute_wolframscript(code: str, timeout: int = 30) -> Tuple[bool, str, str]:
    """
    Execute Wolfram code using wolframscript CLI.

    Args:
        code: Wolfram Language code to execute
        timeout: Timeout in seconds

    Returns:
        Tuple of (success, result, error_message)
    """
    wolframscript = find_wolframscript()
    if not wolframscript:
        return False, "", "wolframscript not found"

    try:
        # Run wolframscript with the code
        result = subprocess.run(
            [wolframscript, "-code", code],
            capture_output=True,
            text=True,
            timeout=timeout
        )

        if result.returncode == 0:
            return True, result.stdout.strip(), ""
        else:
            return False, "", result.stderr.strip() or "Unknown error"

    except subprocess.TimeoutExpired:
        return False, "", f"Execution timed out after {timeout}s"
    except Exception as e:
        return False, "", str(e)


def execute_local_approximation(code: str) -> Tuple[bool, str, str]:
    """
    Execute Wolfram code using local Python approximation.
    This is a fallback that handles common Wolfram patterns.

    Args:
        code: Wolfram Language code

    Returns:
        Tuple of (success, result, error_message)
    """
    import math

    try:
        # Extract the With block variables and compute expression
        # This is a simplified parser for common PM certificate patterns

        # Common constants
        env = {
            'Pi': math.pi,
            'E': math.e,
            'GoldenRatio': (1 + math.sqrt(5)) / 2,
            'EulerGamma': 0.5772156649,
        }

        # Extract variable assignments from With block
        with_match = re.search(r'With\[\{([^}]+)\}', code, re.DOTALL)
        if with_match:
            vars_block = with_match.group(1)
            # Parse variable assignments
            for line in vars_block.split(','):
                line = line.strip()
                if '=' in line and not line.startswith('(*'):
                    # Remove comments
                    line = re.sub(r'\(\*.*?\*\)', '', line).strip()
                    if '=' in line:
                        parts = line.split('=', 1)
                        if len(parts) == 2:
                            var_name = parts[0].strip()
                            var_value = parts[1].strip()
                            try:
                                # Evaluate simple expressions
                                val = eval(var_value, {"__builtins__": {}}, env)
                                env[var_name] = val
                            except:
                                pass

        # Try to extract and evaluate the final expression
        # Look for N[...] calls
        n_matches = re.findall(r'N\[([^,\]]+)(?:,\s*(\d+))?\]', code)
        results = []
        for expr, precision in n_matches:
            try:
                # Simple expression evaluation
                expr_clean = expr.replace('^', '**').replace('Sqrt', 'math.sqrt')
                val = eval(expr_clean, {"__builtins__": {}, "math": math}, env)
                prec = int(precision) if precision else 6
                results.append(f"{val:.{prec}g}")
            except:
                results.append("?")

        if results:
            return True, "{" + ", ".join(results) + "}", "local_approximation"
        else:
            return False, "", "Could not parse expression"

    except Exception as e:
        return False, "", f"Local execution failed: {e}"


def compute_code_hash(code: str) -> str:
    """Compute SHA-256 hash of Wolfram code for caching."""
    return hashlib.sha256(code.encode('utf-8')).hexdigest()[:16]


def load_existing_results() -> Dict[str, Any]:
    """Load existing results from wolfram_results.json if it exists."""
    if RESULTS_FILE.exists():
        try:
            with open(RESULTS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            pass
    return {
        "version": VERSION,
        "generated": None,
        "execution_method": None,
        "certificates": {}
    }


def save_results(results: Dict[str, Any]) -> None:
    """Save results to wolfram_results.json."""
    results["generated"] = datetime.now(timezone.utc).isoformat().replace('+00:00', 'Z')

    RESULTS_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(RESULTS_FILE, 'w', encoding='utf-8') as f:
        json.dump(results, f, indent=2, ensure_ascii=False)


def execute_certificate(cert_data: Dict[str, Any], method: str = "auto",
                        force: bool = False, existing_results: Dict = None) -> Dict[str, Any]:
    """
    Execute Wolfram code from a certificate.

    Args:
        cert_data: Certificate JSON data
        method: Execution method (wolframscript, cloud, local, auto)
        force: Re-execute even if cached result exists
        existing_results: Previously computed results for caching

    Returns:
        Dictionary with execution results
    """
    proof_id = cert_data.get("proof_id", "unknown")
    wolfram_code = cert_data.get("wolfram_code", "")
    expected_result = cert_data.get("expected_result", "")

    if not wolfram_code:
        return {
            "status": "NO_CODE",
            "message": "No wolfram_code field in certificate"
        }

    # Check cache
    code_hash = compute_code_hash(wolfram_code)
    if not force and existing_results:
        cached = existing_results.get("certificates", {}).get(proof_id)
        if cached and cached.get("code_hash") == code_hash:
            return {
                **cached,
                "status": "CACHED"
            }

    # Execute based on method
    success = False
    result = ""
    error = ""
    execution_method = method

    if method == "auto" or method == "wolframscript":
        success, result, error = execute_wolframscript(wolfram_code)
        if success:
            execution_method = "wolframscript"
        elif method == "wolframscript":
            return {
                "status": "FAILED",
                "error": error,
                "execution_method": "wolframscript"
            }

    if not success and (method == "auto" or method == "local"):
        success, result, error = execute_local_approximation(wolfram_code)
        if success:
            execution_method = "local_approximation"

    if not success:
        return {
            "status": "FAILED",
            "error": error or "All execution methods failed",
            "execution_method": execution_method
        }

    # Compare with expected result
    matches_expected = False
    if expected_result:
        # Normalize for comparison (remove whitespace, handle sigma symbol)
        norm_result = result.replace(" ", "").replace("\\n", "").lower()
        norm_expected = expected_result.replace(" ", "").replace("\\n", "").lower()
        norm_expected = norm_expected.replace("sigma", "σ").replace("σ", "sigma")
        norm_result = norm_result.replace("sigma", "σ").replace("σ", "sigma")
        matches_expected = norm_result == norm_expected or expected_result in result

    return {
        "status": "SUCCESS",
        "result": result,
        "expected_result": expected_result,
        "matches_expected": matches_expected,
        "execution_method": execution_method,
        "code_hash": code_hash,
        "executed_at": datetime.now(timezone.utc).isoformat().replace('+00:00', 'Z')
    }


def update_certificate_references(results: Dict[str, Any]) -> int:
    """
    Update certificate JSON files with references to their Wolfram results.

    Adds a 'wolfram_result_ref' field to each certificate pointing to
    the wolfram_results.json file and its entry.

    Args:
        results: The wolfram_results.json data

    Returns:
        Number of certificates updated
    """
    updated = 0

    for cert_file in CERTIFICATES_DIR.glob("*.json"):
        try:
            with open(cert_file, 'r', encoding='utf-8') as f:
                cert_data = json.load(f)

            proof_id = cert_data.get("proof_id")
            if not proof_id:
                continue

            # Check if we have results for this certificate
            cert_results = results.get("certificates", {}).get(proof_id)
            if not cert_results:
                continue

            # Add reference to results
            cert_data["wolfram_result_ref"] = {
                "file": "wolfram_results.json",
                "proof_id": proof_id,
                "status": cert_results.get("status"),
                "executed_at": cert_results.get("executed_at"),
                "matches_expected": cert_results.get("matches_expected")
            }

            # Write back
            with open(cert_file, 'w', encoding='utf-8') as f:
                json.dump(cert_data, f, indent=2, ensure_ascii=False)

            updated += 1

        except Exception as e:
            print(f"  [WARN] Could not update {cert_file.name}: {e}")

    return updated


def main():
    """Main entry point for Wolfram executor."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Execute Wolfram code from PM certificates",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument("--method", "-m",
                        choices=["auto", "wolframscript", "local"],
                        default="auto",
                        help="Execution method (default: auto)")
    parser.add_argument("--force", "-f",
                        action="store_true",
                        help="Re-execute even if cached results exist")
    parser.add_argument("--verbose", "-v",
                        action="store_true",
                        help="Show detailed output")
    parser.add_argument("--update-refs",
                        action="store_true",
                        help="Update certificate JSONs with result references")

    args = parser.parse_args()

    print("=" * 70)
    print(f" PRINCIPIA METAPHYSICA - Wolfram Executor v{VERSION}")
    print("=" * 70)

    # Check for wolframscript
    ws = find_wolframscript()
    if ws:
        print(f"\n[OK] Found wolframscript: {ws}")
    else:
        print("\n[INFO] wolframscript not found - will use local approximation")
        if args.method == "wolframscript":
            print("[ERROR] --method=wolframscript requires Wolfram Mathematica")
            sys.exit(1)

    # Load existing results for caching
    existing_results = load_existing_results()

    # Find all certificate files
    cert_files = list(CERTIFICATES_DIR.glob("*.json"))
    print(f"\n[INFO] Found {len(cert_files)} certificate files")

    # Execute each certificate
    results = {
        "version": VERSION,
        "generated": None,
        "execution_method": args.method,
        "wolframscript_available": ws is not None,
        "certificates": {},
        "summary": {
            "total": 0,
            "success": 0,
            "failed": 0,
            "cached": 0,
            "no_code": 0,
            "matches_expected": 0
        }
    }

    print("\n[EXECUTING] Processing certificates...")
    print("-" * 70)

    for cert_file in sorted(cert_files):
        try:
            with open(cert_file, 'r', encoding='utf-8') as f:
                cert_data = json.load(f)

            proof_id = cert_data.get("proof_id", cert_file.stem)
            cert_id = cert_data.get("cert_id", "")

            # Execute
            exec_result = execute_certificate(
                cert_data,
                method=args.method,
                force=args.force,
                existing_results=existing_results
            )

            results["certificates"][proof_id] = exec_result
            results["summary"]["total"] += 1

            status = exec_result.get("status", "UNKNOWN")
            if status == "SUCCESS":
                results["summary"]["success"] += 1
                if exec_result.get("matches_expected"):
                    results["summary"]["matches_expected"] += 1
            elif status == "CACHED":
                results["summary"]["cached"] += 1
                if exec_result.get("matches_expected"):
                    results["summary"]["matches_expected"] += 1
            elif status == "NO_CODE":
                results["summary"]["no_code"] += 1
            else:
                results["summary"]["failed"] += 1

            # Print status
            status_icon = {
                "SUCCESS": "[OK]",
                "CACHED": "[CACHED]",
                "FAILED": "[X]",
                "NO_CODE": "[SKIP]"
            }.get(status, "[?]")

            if args.verbose or status == "FAILED":
                method = exec_result.get("execution_method", "")
                match = "MATCH" if exec_result.get("matches_expected") else ""
                print(f"  {status_icon} {cert_id}: {proof_id} ({method}) {match}")
                if status == "FAILED" and args.verbose:
                    print(f"       Error: {exec_result.get('error', 'Unknown')}")

        except Exception as e:
            print(f"  [ERROR] {cert_file.name}: {e}")
            results["summary"]["failed"] += 1

    # Save results
    print("\n[SAVING] Writing wolfram_results.json...")
    save_results(results)
    print(f"  Created: {RESULTS_FILE}")

    # Update certificate references if requested
    if args.update_refs:
        print("\n[UPDATING] Adding result references to certificates...")
        updated = update_certificate_references(results)
        print(f"  Updated: {updated} certificates")

    # Summary
    print("\n" + "=" * 70)
    print(" SUMMARY")
    print("=" * 70)
    summary = results["summary"]
    print(f"  Total:           {summary['total']}")
    print(f"  Success:         {summary['success']}")
    print(f"  Cached:          {summary['cached']}")
    print(f"  Failed:          {summary['failed']}")
    print(f"  No Code:         {summary['no_code']}")
    print(f"  Matches Expected: {summary['matches_expected']}")
    print("=" * 70)

    # Return exit code
    sys.exit(0 if summary['failed'] == 0 else 1)


if __name__ == "__main__":
    main()
