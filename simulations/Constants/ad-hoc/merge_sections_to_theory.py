"""
Merge Section JSONs into theory_output.json
===========================================

Merges detailed section JSON files from AutoGenerated/sections/ into
the sections array of theory_output.json.

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
"""

import json
from pathlib import Path
from typing import Dict, Any, List


def load_json(path: Path) -> Dict[str, Any]:
    """Load JSON file with UTF-8 encoding."""
    with open(path, 'r', encoding='utf-8') as f:
        return json.load(f)


def save_json(path: Path, data: Dict[str, Any]) -> None:
    """Save JSON file with UTF-8 encoding and proper formatting."""
    with open(path, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)


def get_section_id(filename: str) -> str:
    """Extract section ID from filename."""
    name = Path(filename).stem
    if name.startswith('section-'):
        return name.replace('section-', '')
    elif name.startswith('appendix-'):
        return name.replace('appendix-', '').upper()
    return name


def merge_section_content(existing: Dict[str, Any], detailed: Dict[str, Any]) -> Dict[str, Any]:
    """Merge detailed section content into existing section."""
    merged = existing.copy()

    # Fields to merge from detailed JSON (overwrite if present)
    merge_fields = [
        'subsections', 'content_blocks', 'contentBlocks',
        'abstract', 'websiteOnlyContent', 'website_only',
        'beginnerSummary', 'keyTakeaways', 'learningObjectives',
        'relatedConcepts', 'citations', 'simulationFile',
        'metadata', 'testability'
    ]

    for field in merge_fields:
        if field in detailed and detailed[field]:
            merged[field] = detailed[field]

    # Replace reference fields from detailed JSON (overwrite existing)
    ref_fields = ['formulaRefs', 'paramRefs']
    for field in ref_fields:
        if field in detailed:
            # Extract string refs only, skip dicts
            new_list = detailed[field] if isinstance(detailed[field], list) else []
            new_refs = [r for r in new_list if isinstance(r, str)]
            merged[field] = new_refs  # Replace, don't merge

    # crossRefs can be merged since they're typically different
    if 'crossRefs' in detailed and isinstance(detailed['crossRefs'], list):
        existing_list = existing.get('crossRefs', []) if isinstance(existing.get('crossRefs'), list) else []
        existing_refs = set(r for r in existing_list if isinstance(r, str))
        new_list = detailed['crossRefs'] if isinstance(detailed['crossRefs'], list) else []
        new_refs = [r for r in new_list if isinstance(r, str)]
        merged['crossRefs'] = list(existing_refs.union(set(new_refs)))

    # Handle crossRefs as object
    if 'crossRefs' in detailed and isinstance(detailed['crossRefs'], dict):
        merged['crossRefs'] = detailed['crossRefs']

    # Preserve navigation
    if 'navigation' in detailed:
        merged['prevSection'] = detailed['navigation'].get('prevSection', merged.get('prevSection', ''))
        merged['nextSection'] = detailed['navigation'].get('nextSection', merged.get('nextSection', ''))

    return merged


def merge_sections(theory_path: Path, sections_dir: Path) -> Dict[str, Any]:
    """Merge all section JSONs into theory_output."""
    # Load theory_output
    theory = load_json(theory_path)

    if 'sections' not in theory:
        theory['sections'] = {}

    # Find all section JSON files
    section_files = list(sections_dir.glob('*.json'))

    print(f"Found {len(section_files)} section files to merge")

    for section_file in section_files:
        section_id = get_section_id(section_file.name)
        detailed = load_json(section_file)

        # Determine the key for this section in theory_output
        # Main sections use numeric IDs, appendices use letter IDs
        if section_id.isdigit():
            key = section_id
        elif len(section_id) == 1 and section_id.isalpha():
            key = section_id  # Appendix letter
        else:
            key = section_id  # Supplementary section name

        if key in theory['sections']:
            # Merge with existing
            theory['sections'][key] = merge_section_content(
                theory['sections'][key],
                detailed
            )
            print(f"  Merged: {section_file.name} -> sections['{key}']")
        else:
            # Add as new section
            new_section = {
                'id': key,
                'title': detailed.get('title', section_id),
                'sectionType': detailed.get('type', 'section'),
                'parentId': '',
                'abstract': detailed.get('abstract', ''),
                'contentBlocks': detailed.get('content_blocks', detailed.get('contentBlocks', [])),
                'subsections': detailed.get('subsections', []),
                'appendices': [],
                'formulaRefs': detailed.get('formulaRefs', []),
                'paramRefs': detailed.get('paramRefs', []),
                'figureRefs': [],
                'citationRefs': detailed.get('citations', []),
                'prevSection': detailed.get('navigation', {}).get('prevSection', ''),
                'nextSection': detailed.get('navigation', {}).get('nextSection', ''),
                'sectionFile': detailed.get('sectionFile', f"sections/{section_file.stem}.html"),
                'beginnerSummary': detailed.get('beginnerSummary', ''),
                'keyTakeaways': detailed.get('keyTakeaways', []),
                'learningObjectives': detailed.get('learningObjectives', []),
                'websiteOnlyContent': detailed.get('websiteOnlyContent', detailed.get('website_only', [])),
                'order': int(key) if key.isdigit() else 100 + ord(key[0]) if key else 999,
                'category': detailed.get('category', 'content'),
                'description': detailed.get('abstract', '')[:200]
            }
            theory['sections'][key] = new_section
            print(f"  Added new: {section_file.name} -> sections['{key}']")

    return theory


def validate_sections(theory: Dict[str, Any]) -> List[str]:
    """Validate merged sections structure."""
    issues = []
    sections = theory.get('sections', {})

    # Check main sections 1-9 exist
    for i in range(1, 10):
        if str(i) not in sections:
            issues.append(f"Missing main section {i}")

    # Check appendices A-N exist
    for letter in 'ABCDEFGHIJKLMN':
        if letter not in sections:
            issues.append(f"Missing appendix {letter}")

    # Check navigation consistency
    for key, section in sections.items():
        if section.get('nextSection'):
            next_key = section['nextSection']
            if next_key not in sections:
                issues.append(f"Section {key} points to missing next section {next_key}")

    return issues


def main():
    """Main entry point."""
    base_dir = Path(__file__).parent.parent.parent
    theory_path = base_dir / 'AutoGenerated' / 'theory_output.json'
    sections_dir = base_dir / 'AutoGenerated' / 'sections'

    print(f"Theory output: {theory_path}")
    print(f"Sections dir: {sections_dir}")

    if not theory_path.exists():
        print(f"Error: {theory_path} not found")
        return

    if not sections_dir.exists():
        print(f"Error: {sections_dir} not found")
        return

    # Merge sections
    theory = merge_sections(theory_path, sections_dir)

    # Validate
    issues = validate_sections(theory)
    if issues:
        print("\nValidation issues:")
        for issue in issues:
            print(f"  - {issue}")
    else:
        print("\nValidation passed!")

    # Save updated theory_output
    save_json(theory_path, theory)
    print(f"\nSaved updated theory_output.json")
    print(f"Total sections: {len(theory.get('sections', {}))}")


if __name__ == "__main__":
    main()
