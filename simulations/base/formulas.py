"""
Formula Registry for Principia Metaphysica
============================================

Manages all 110 formulas with derivation chains and category tracking.
Loads from AutoGenerated/formulas.json when available.

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Set
import json
import os
from collections import deque


class FormulaCategory:
    """Formula category constants."""
    ESTABLISHED = "ESTABLISHED"  # Standard physics (no parents)
    THEORY = "THEORY"           # PM-specific theory (from ESTABLISHED)
    DERIVED = "DERIVED"         # Computed results (from THEORY + ESTABLISHED)
    PREDICTIONS = "PREDICTIONS" # Testable predictions (from DERIVED)

    @classmethod
    def all_categories(cls) -> List[str]:
        return [cls.ESTABLISHED, cls.THEORY, cls.DERIVED, cls.PREDICTIONS]

    @classmethod
    def validate(cls, category: str) -> bool:
        return category in cls.all_categories()


@dataclass
class FormulaMetadata:
    """Complete metadata for a formula."""
    id: str
    label: str
    section_id: str
    latex: str
    plain_text: str
    category: str
    description: str

    # Parameter linkage
    input_params: List[str] = field(default_factory=list)
    output_params: List[str] = field(default_factory=list)

    # Derivation tracking
    parent_formulas: List[str] = field(default_factory=list)
    derivation_steps: List[str] = field(default_factory=list)
    derivation_method: str = ""

    # Additional metadata
    terms: Dict[str, Any] = field(default_factory=dict)
    computed_value: Optional[Any] = None
    units: str = ""
    experimental_value: Optional[Any] = None
    sigma_deviation: Optional[float] = None
    status: str = "active"
    validated: bool = False
    simulation_file: str = ""
    references: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            'id': self.id,
            'label': self.label,
            'section_id': self.section_id,
            'latex': self.latex,
            'plain_text': self.plain_text,
            'category': self.category,
            'description': self.description,
            'input_params': self.input_params,
            'output_params': self.output_params,
            'parent_formulas': self.parent_formulas,
            'derivation_steps': self.derivation_steps,
            'derivation_method': self.derivation_method,
            'terms': self.terms,
            'computed_value': self.computed_value,
            'units': self.units,
            'experimental_value': self.experimental_value,
            'sigma_deviation': self.sigma_deviation,
            'status': self.status,
            'validated': self.validated,
            'simulation_file': self.simulation_file,
            'references': self.references,
        }


class FormulaRegistry:
    """
    Registry for all PM formulas with derivation tracking.

    Usage:
        registry = FormulaRegistry()

        # Get formula by ID
        formula = registry.get_formula("proton-lifetime")

        # Get derivation chain back to ESTABLISHED physics
        chain = registry.get_derivation_chain("proton-lifetime")

        # Get all formulas in a section
        section_formulas = registry.get_by_section("4")

        # Validate completeness
        issues = registry.validate_completeness()
    """

    # Category normalization map
    CATEGORY_MAP = {
        'TOPOLOGY': FormulaCategory.DERIVED,
        'GEOMETRY': FormulaCategory.THEORY,
        'GAUGE': FormulaCategory.DERIVED,
        'COSMOLOGY': FormulaCategory.PREDICTIONS,
        'DARK_ENERGY': FormulaCategory.PREDICTIONS,
        'neutrino_mixing': FormulaCategory.DERIVED,
        'neutrino_mass': FormulaCategory.DERIVED,
        'String Theory Consistency': FormulaCategory.THEORY,
        FormulaCategory.ESTABLISHED: FormulaCategory.ESTABLISHED,
        FormulaCategory.THEORY: FormulaCategory.THEORY,
        FormulaCategory.DERIVED: FormulaCategory.DERIVED,
        FormulaCategory.PREDICTIONS: FormulaCategory.PREDICTIONS,
    }

    def __init__(self, formulas_path: Optional[str] = None):
        """Initialize the formula registry."""
        self.formulas: Dict[str, FormulaMetadata] = {}
        self._derivation_graph: Dict[str, Set[str]] = {}  # formula -> parents
        self._reverse_graph: Dict[str, Set[str]] = {}     # formula -> children

        if formulas_path is None:
            formulas_path = os.path.join(
                os.path.dirname(os.path.dirname(os.path.dirname(__file__))),
                "AutoGenerated", "formulas.json"
            )

        if os.path.exists(formulas_path):
            self._load_from_json(formulas_path)

        self._build_derivation_graph()

    def _load_from_json(self, path: str) -> None:
        """Load formulas from JSON file."""
        try:
            with open(path, 'r', encoding='utf-8') as f:
                data = json.load(f)

            formulas_list = data if isinstance(data, list) else data.get('formulas', [])

            for formula_data in formulas_list:
                formula_id = formula_data.get('id', '')
                if not formula_id:
                    continue

                # Normalize category
                raw_category = formula_data.get('category', FormulaCategory.DERIVED)
                category = self._normalize_category(raw_category)

                # Extract derivation info
                derivation = formula_data.get('derivation', {})
                if isinstance(derivation, dict):
                    parent_formulas = derivation.get('parentFormulas', [])
                    derivation_steps = derivation.get('steps', [])
                    derivation_method = derivation.get('method', '')
                else:
                    parent_formulas, derivation_steps, derivation_method = [], [], ''

                metadata = FormulaMetadata(
                    id=formula_id,
                    label=formula_data.get('label', formula_data.get('equationNumber', '')),
                    section_id=formula_data.get('sectionId', formula_data.get('section', '')),
                    latex=formula_data.get('latex', ''),
                    plain_text=formula_data.get('plainText', formula_data.get('plain_text', '')),
                    category=category,
                    description=formula_data.get('description', ''),
                    input_params=formula_data.get('inputParams', []),
                    output_params=formula_data.get('outputParams', []),
                    parent_formulas=parent_formulas,
                    derivation_steps=derivation_steps,
                    derivation_method=derivation_method,
                    terms=formula_data.get('terms', {}),
                    computed_value=formula_data.get('computedValue'),
                    units=formula_data.get('units', ''),
                    experimental_value=formula_data.get('experimentalValue'),
                    sigma_deviation=formula_data.get('sigmaDeviation'),
                    status=formula_data.get('status', 'active'),
                    validated=formula_data.get('validated', False),
                    simulation_file=formula_data.get('simulationFile', ''),
                    references=formula_data.get('references', []),
                )

                self.formulas[formula_id] = metadata

        except Exception as e:
            import warnings
            warnings.warn(f"Could not load formulas from {path}: {e}")

    def _normalize_category(self, category: str) -> str:
        """Normalize category to standard FormulaCategory value."""
        return self.CATEGORY_MAP.get(category, FormulaCategory.DERIVED)

    def _build_derivation_graph(self) -> None:
        """Build bidirectional derivation graph."""
        for formula_id, metadata in self.formulas.items():
            parents = set(metadata.parent_formulas)
            self._derivation_graph[formula_id] = parents

            for parent_id in parents:
                if parent_id not in self._reverse_graph:
                    self._reverse_graph[parent_id] = set()
                self._reverse_graph[parent_id].add(formula_id)

    def get_formula(self, formula_id: str) -> Optional[FormulaMetadata]:
        """Get formula by ID."""
        return self.formulas.get(formula_id)

    def get_by_section(self, section_id: str) -> List[FormulaMetadata]:
        """Get all formulas in a section."""
        results = []
        for formula in self.formulas.values():
            if formula.section_id == section_id or formula.section_id.startswith(f"{section_id}."):
                results.append(formula)
        return results

    def get_by_category(self, category: str) -> List[FormulaMetadata]:
        """Get all formulas by category."""
        return [f for f in self.formulas.values() if f.category == category]

    def get_all_ids(self) -> List[str]:
        """Get all formula IDs."""
        return list(self.formulas.keys())

    def register_formula(self, formula_id: str, metadata: FormulaMetadata) -> None:
        """Register a new formula."""
        self.formulas[formula_id] = metadata

        # Update graphs
        parents = set(metadata.parent_formulas)
        self._derivation_graph[formula_id] = parents

        for parent_id in parents:
            if parent_id not in self._reverse_graph:
                self._reverse_graph[parent_id] = set()
            self._reverse_graph[parent_id].add(formula_id)

    def get_derivation_chain(self, formula_id: str) -> List[str]:
        """
        Trace derivation chain back to ESTABLISHED formulas using BFS.

        Returns formulas in topological order (parents before children).
        """
        if formula_id not in self.formulas:
            return []

        visited = set()
        queue = deque([formula_id])
        chain = []

        while queue:
            current = queue.popleft()
            if current in visited:
                continue
            visited.add(current)

            parents = self._derivation_graph.get(current, set())
            for parent in parents:
                if parent not in visited and parent in self.formulas:
                    queue.append(parent)

            chain.append(current)

        # Reverse to get topological order
        chain.reverse()
        return chain

    def get_dependencies(self, formula_id: str) -> List[str]:
        """Get direct parent formulas."""
        return list(self._derivation_graph.get(formula_id, set()))

    def get_dependents(self, formula_id: str) -> List[str]:
        """Get direct child formulas."""
        return list(self._reverse_graph.get(formula_id, set()))

    def validate_completeness(self) -> Dict[str, List[str]]:
        """Check all formulas have required fields."""
        issues: Dict[str, List[str]] = {
            'missing_latex': [],
            'missing_category': [],
            'invalid_category': [],
            'broken_parent_refs': [],
            'missing_derivation': [],
        }

        for formula_id, formula in self.formulas.items():
            if not formula.latex:
                issues['missing_latex'].append(formula_id)

            if not formula.category:
                issues['missing_category'].append(formula_id)
            elif not FormulaCategory.validate(formula.category):
                issues['invalid_category'].append(formula_id)

            # Check parent references
            for parent_id in formula.parent_formulas:
                if parent_id not in self.formulas:
                    issues['broken_parent_refs'].append(f"{formula_id} -> {parent_id}")

            # Non-ESTABLISHED should have derivation
            if formula.category != FormulaCategory.ESTABLISHED:
                if not formula.parent_formulas and not formula.derivation_steps:
                    issues['missing_derivation'].append(formula_id)

        return {k: v for k, v in issues.items() if v}

    def get_statistics(self) -> Dict[str, Any]:
        """Get registry statistics."""
        by_category: Dict[str, int] = {}
        by_section: Dict[str, int] = {}
        validated_count = 0

        for formula in self.formulas.values():
            cat = formula.category
            by_category[cat] = by_category.get(cat, 0) + 1

            sec = formula.section_id.split('.')[0] if formula.section_id else 'unknown'
            by_section[sec] = by_section.get(sec, 0) + 1

            if formula.validated:
                validated_count += 1

        return {
            'total_formulas': len(self.formulas),
            'by_category': by_category,
            'by_section': by_section,
            'validated': validated_count,
            'unvalidated': len(self.formulas) - validated_count,
        }

    def export_to_json(self, output_path: str) -> None:
        """Export registry to JSON file."""
        formulas_list = [f.to_dict() for f in self.formulas.values()]

        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump({'formulas': formulas_list}, f, indent=2)


# Global registry instance (lazy loaded)
_global_registry: Optional[FormulaRegistry] = None


def get_registry() -> FormulaRegistry:
    """Get the global formula registry (lazy loading)."""
    global _global_registry
    if _global_registry is None:
        _global_registry = FormulaRegistry()
    return _global_registry


# Convenience functions
def get_formula(formula_id: str) -> Optional[FormulaMetadata]:
    """Get a formula by ID."""
    return get_registry().get_formula(formula_id)


def get_formulas_by_section(section_id: str) -> List[FormulaMetadata]:
    """Get all formulas in a section."""
    return get_registry().get_by_section(section_id)


def get_formulas_by_category(category: str) -> List[FormulaMetadata]:
    """Get all formulas by category."""
    return get_registry().get_by_category(category)


def get_derivation_chain(formula_id: str) -> List[str]:
    """Get derivation chain for a formula."""
    return get_registry().get_derivation_chain(formula_id)
