#!/usr/bin/env python3
"""
Publication Plotter - High-Quality Scientific Graphics
========================================================

Generates publication-ready plots for Principia Metaphysica.
Uses standardized styling for academic journals (Physical Review,
JHEP, Nature, etc.).

Features:
- Consistent font styling (serif, proper sizing)
- High DPI for print quality
- Error bars and confidence regions
- LaTeX-compatible output
- Color-blind friendly palettes

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
"""

import numpy as np
import json
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple

try:
    import matplotlib.pyplot as plt
    import matplotlib.patches as mpatches
    from matplotlib.ticker import AutoMinorLocator
    HAS_MATPLOTLIB = True
except ImportError:
    HAS_MATPLOTLIB = False
    print("Warning: matplotlib not available. Plotting functions disabled.")


def set_pub_style():
    """Set publication-quality matplotlib style."""
    if not HAS_MATPLOTLIB:
        return

    plt.rcParams.update({
        # Font settings
        "font.family": "serif",
        "font.serif": ["Times New Roman", "Times", "DejaVu Serif"],
        "font.size": 11,

        # Axes
        "axes.labelsize": 12,
        "axes.titlesize": 12,
        "axes.linewidth": 1.0,
        "axes.grid": True,
        "axes.grid.which": "major",

        # Ticks
        "xtick.labelsize": 10,
        "ytick.labelsize": 10,
        "xtick.major.size": 5,
        "ytick.major.size": 5,
        "xtick.minor.size": 2.5,
        "ytick.minor.size": 2.5,
        "xtick.direction": "in",
        "ytick.direction": "in",

        # Legend
        "legend.fontsize": 10,
        "legend.framealpha": 0.9,
        "legend.edgecolor": "gray",

        # Figure
        "figure.figsize": (6, 4),
        "figure.dpi": 150,
        "savefig.dpi": 300,
        "savefig.bbox": "tight",
        "savefig.pad_inches": 0.1,

        # Grid
        "grid.alpha": 0.3,
        "grid.linewidth": 0.5,

        # LaTeX
        "text.usetex": False,  # Set True if LaTeX is installed
        "mathtext.fontset": "stix",
    })


# Color palettes (color-blind friendly)
COLORS = {
    "primary": "#2E86AB",     # Blue
    "secondary": "#E94F37",   # Red
    "tertiary": "#F39237",    # Orange
    "quaternary": "#3A7D44",  # Green
    "experiment": "#1A1A2E",  # Dark
    "prediction": "#E94F37",  # Red
    "theory": "#2E86AB",      # Blue
}


def plot_neutrino_fits(
    pm_predictions: Dict[str, float],
    nufit_data: Dict[str, Tuple[float, float]],
    output_path: str = "AutoGenerated/neutrino_fit_pub.png"
):
    """
    Generate neutrino mixing angle comparison plot.

    Args:
        pm_predictions: Dict with theta12, theta13, theta23, delta_cp
        nufit_data: Dict with (value, error) tuples for each angle
        output_path: Output file path
    """
    if not HAS_MATPLOTLIB:
        print("Cannot generate plot: matplotlib not available")
        return

    set_pub_style()
    fig, ax = plt.subplots(figsize=(7, 5))

    angles = ['θ₁₂', 'θ₁₃', 'θ₂₃', 'δ_CP/10']
    keys = ['theta12', 'theta13', 'theta23', 'delta_cp']
    x = np.arange(len(angles))
    width = 0.35

    # Extract values
    pm_vals = [pm_predictions.get(k, 0) for k in keys]
    pm_vals[3] /= 10  # Scale delta_CP for display

    exp_vals = [nufit_data.get(k, (0, 0))[0] for k in keys]
    exp_vals[3] /= 10
    exp_errs = [nufit_data.get(k, (0, 0))[1] for k in keys]
    exp_errs[3] /= 10

    # Plot bars
    bars1 = ax.bar(x - width/2, exp_vals, width, yerr=exp_errs,
                   label='NuFIT 6.0', color=COLORS["experiment"],
                   capsize=4, alpha=0.8)
    bars2 = ax.bar(x + width/2, pm_vals, width,
                   label='PM v16.0', color=COLORS["prediction"],
                   alpha=0.8)

    # Labels and formatting
    ax.set_ylabel('Degrees')
    ax.set_xlabel('Mixing Parameter')
    ax.set_xticks(x)
    ax.set_xticklabels(angles)
    ax.legend(loc='upper right')
    ax.set_ylim(0, 55)

    ax.yaxis.set_minor_locator(AutoMinorLocator())

    # Title
    ax.set_title('PMNS Mixing Angles: G₂ Prediction vs Experiment', fontsize=12)

    # Save
    Path(output_path).parent.mkdir(exist_ok=True)
    plt.tight_layout()
    plt.savefig(output_path)
    plt.close()
    print(f"Plot saved to {output_path}")


def plot_dark_energy_evolution(
    pm_w0: float = -0.846,
    pm_wa: float = 0.21,
    desi_data: Dict[str, Tuple[float, float]] = None,
    output_path: str = "AutoGenerated/dark_energy_pub.png"
):
    """
    Generate dark energy equation of state evolution plot.

    Shows w(a) = w0 + wa(1-a) for PM prediction and DESI constraint.
    """
    if not HAS_MATPLOTLIB:
        return

    if desi_data is None:
        desi_data = {
            "w0": (-0.827, 0.063),
            "wa": (0.75, 0.28)
        }

    set_pub_style()
    fig, ax = plt.subplots(figsize=(7, 5))

    # Scale factor range
    a = np.linspace(0.3, 1.0, 100)
    z = 1/a - 1

    # PM prediction
    w_pm = pm_w0 + pm_wa * (1 - a)

    # DESI central + uncertainty band
    w0_desi, w0_err = desi_data["w0"]
    wa_desi, wa_err = desi_data["wa"]
    w_desi = w0_desi + wa_desi * (1 - a)
    w_desi_up = (w0_desi + w0_err) + (wa_desi + wa_err) * (1 - a)
    w_desi_down = (w0_desi - w0_err) + (wa_desi - wa_err) * (1 - a)

    # Cosmological constant
    w_lambda = np.ones_like(a) * (-1)

    # Plot
    ax.fill_between(a, w_desi_down, w_desi_up, alpha=0.3,
                    color=COLORS["experiment"], label='DESI DR2 (1σ)')
    ax.plot(a, w_desi, '--', color=COLORS["experiment"],
            linewidth=1.5, label='DESI best fit')
    ax.plot(a, w_pm, '-', color=COLORS["prediction"],
            linewidth=2, label=f'PM: w₀={pm_w0:.3f}, wₐ={pm_wa:.2f}')
    ax.plot(a, w_lambda, ':', color='gray', linewidth=1, label='ΛCDM (w=-1)')

    # Labels
    ax.set_xlabel('Scale Factor a')
    ax.set_ylabel('Dark Energy EoS w(a)')
    ax.set_xlim(0.3, 1.0)
    ax.set_ylim(-1.5, -0.3)
    ax.legend(loc='lower right')
    ax.set_title('Dark Energy Evolution: Dimensional Reduction Prediction', fontsize=12)

    ax.xaxis.set_minor_locator(AutoMinorLocator())
    ax.yaxis.set_minor_locator(AutoMinorLocator())

    # Add redshift axis on top
    ax2 = ax.twiny()
    ax2.set_xlim(ax.get_xlim())
    z_ticks = [0, 0.5, 1.0, 1.5, 2.0]
    a_ticks = [1/(1+z) for z in z_ticks]
    ax2.set_xticks(a_ticks)
    ax2.set_xticklabels([f'{z:.1f}' for z in z_ticks])
    ax2.set_xlabel('Redshift z')

    plt.tight_layout()
    plt.savefig(output_path)
    plt.close()
    print(f"Plot saved to {output_path}")


def plot_proton_decay_prediction(
    tau_pm: float = 4.8e34,
    tau_superK_bound: float = 1.67e34,
    tau_hyperK_sensitivity: float = 1.3e35,
    output_path: str = "AutoGenerated/proton_decay_pub.png"
):
    """
    Generate proton decay lifetime comparison plot.
    """
    if not HAS_MATPLOTLIB:
        return

    set_pub_style()
    fig, ax = plt.subplots(figsize=(7, 4))

    # Data
    models = ['PM v16.0\n(G₂ geometry)', 'Super-K\n(Current bound)', 'Hyper-K\n(2027+ sensitivity)']
    values = [np.log10(tau_pm), np.log10(tau_superK_bound), np.log10(tau_hyperK_sensitivity)]
    colors = [COLORS["prediction"], COLORS["experiment"], COLORS["tertiary"]]

    # Plot
    bars = ax.barh(models, values, color=colors, alpha=0.8, height=0.5)

    # Labels
    ax.set_xlabel('log₁₀(τ_p / years)')
    ax.set_xlim(33, 36)
    ax.set_title('Proton Decay Lifetime: p → e⁺π⁰', fontsize=12)

    # Add value labels
    for bar, val in zip(bars, values):
        ax.text(val + 0.1, bar.get_y() + bar.get_height()/2,
                f'10^{val:.1f} yr', va='center', fontsize=10)

    ax.xaxis.set_minor_locator(AutoMinorLocator())

    plt.tight_layout()
    plt.savefig(output_path)
    plt.close()
    print(f"Plot saved to {output_path}")


def plot_rg_running(
    alpha_gut: float = 1/24,
    M_GUT: float = 2.1e16,
    output_path: str = "AutoGenerated/rg_running_pub.png"
):
    """
    Generate RG running of gauge couplings plot.
    """
    if not HAS_MATPLOTLIB:
        return

    set_pub_style()
    fig, ax = plt.subplots(figsize=(7, 5))

    # Energy scale
    log_E = np.linspace(2, 17, 200)  # log10(E/GeV)
    E = 10**log_E

    # SM beta coefficients
    b1 = 41/10
    b2 = -19/6
    b3 = -7

    # Coupling evolution (1-loop)
    alpha_1_inv = 1/alpha_gut - (b1 / (2*np.pi)) * np.log(M_GUT / E)
    alpha_2_inv = 1/alpha_gut - (b2 / (2*np.pi)) * np.log(M_GUT / E)
    alpha_3_inv = 1/alpha_gut - (b3 / (2*np.pi)) * np.log(M_GUT / E)

    # Plot
    ax.plot(log_E, alpha_1_inv, '-', color=COLORS["tertiary"],
            linewidth=2, label=r'U(1)$_Y$ (α₁⁻¹)')
    ax.plot(log_E, alpha_2_inv, '-', color=COLORS["secondary"],
            linewidth=2, label=r'SU(2)$_L$ (α₂⁻¹)')
    ax.plot(log_E, alpha_3_inv, '-', color=COLORS["quaternary"],
            linewidth=2, label=r'SU(3)$_c$ (α₃⁻¹)')

    # Markers at key scales
    ax.axvline(x=np.log10(91.2), color='gray', linestyle=':', alpha=0.5)
    ax.text(np.log10(91.2), 65, 'M_Z', ha='center', fontsize=9)

    ax.axvline(x=np.log10(M_GUT), color='gray', linestyle=':', alpha=0.5)
    ax.text(np.log10(M_GUT), 65, 'M_GUT', ha='center', fontsize=9)

    # Unification point
    ax.plot(np.log10(M_GUT), 1/alpha_gut, 'ko', markersize=10,
            label=f'Unification: α⁻¹={1/alpha_gut:.1f}')

    # Labels
    ax.set_xlabel('log₁₀(E/GeV)')
    ax.set_ylabel('1/α_i')
    ax.set_xlim(2, 17)
    ax.set_ylim(0, 70)
    ax.legend(loc='upper right')
    ax.set_title('Gauge Coupling Unification from G₂ Holonomy', fontsize=12)

    ax.xaxis.set_minor_locator(AutoMinorLocator())
    ax.yaxis.set_minor_locator(AutoMinorLocator())

    plt.tight_layout()
    plt.savefig(output_path)
    plt.close()
    print(f"Plot saved to {output_path}")


def generate_all_plots(theory_output_path: str = "AutoGenerated/theory_output.json"):
    """
    Generate all publication plots from theory output.

    Args:
        theory_output_path: Path to theory_output.json
    """
    if not HAS_MATPLOTLIB:
        print("Matplotlib not available. Skipping plot generation.")
        return

    print("=" * 60)
    print("GENERATING PUBLICATION PLOTS")
    print("=" * 60)

    # Load theory output if available
    try:
        with open(theory_output_path, 'r') as f:
            data = json.load(f)
        params = data.get('parameters', {})
    except FileNotFoundError:
        print(f"Warning: {theory_output_path} not found. Using default values.")
        params = {}

    # 1. Neutrino mixing
    print("\n1. Neutrino Mixing Angles...")
    pm_neutrino = {
        'theta12': params.get('neutrino.theta_12_pred', {}).get('value', 33.59),
        'theta13': params.get('neutrino.theta_13_pred', {}).get('value', 8.33),
        'theta23': params.get('neutrino.theta_23_pred', {}).get('value', 45.75),
        'delta_cp': params.get('neutrino.delta_CP_pred', {}).get('value', 232.5)
    }
    nufit_data = {
        'theta12': (33.41, 0.75),
        'theta13': (8.54, 0.11),
        'theta23': (45.9, 1.5),
        'delta_cp': (230.0, 28.0)
    }
    plot_neutrino_fits(pm_neutrino, nufit_data)

    # 2. Dark energy
    print("2. Dark Energy Evolution...")
    w0 = params.get('cosmology.w0_derived', {}).get('value', -0.846)
    wa = params.get('cosmology.wa_derived', {}).get('value', 0.21)
    plot_dark_energy_evolution(w0, wa)

    # 3. Proton decay
    print("3. Proton Decay Lifetime...")
    tau_p = params.get('proton_decay.tau_p_years', {}).get('value', 4.8e34)
    plot_proton_decay_prediction(tau_p)

    # 4. RG running
    print("4. Gauge Coupling Unification...")
    plot_rg_running()

    print("\n" + "=" * 60)
    print("All plots generated successfully!")
    print("=" * 60)


if __name__ == "__main__":
    generate_all_plots()
