#!/usr/bin/env python3
"""
Add Simulation File Links to theory_output.json

This script updates theory_output.json to add bi-directional links:
1. Adds 'simulationFile' field to formula objects
2. Creates new formula entries for formulas that don't exist yet
3. Ensures consistency between simulations and theory data

Copyright (c) 2025 Andrew Keith Watts. All rights reserved.
"""

import json
from pathlib import Path
from typing import Dict

# Mapping of formula IDs to their simulation files
FORMULA_TO_SIMULATION = {
    # Existing formulas
    'proton-lifetime': 'simulations/proton_lifetime_mc_v12_8.py',
    'kk-graviton-mass': 'simulations/kk_graviton_mass_v12_fixed.py',

    # New formulas that need to be added
    'proton-decay-branching-ratio': 'simulations/proton_decay_br_v12_8.py',
    'gut-unification': 'simulations/gauge_unification_precision_v12_4.py',
    'gut-coupling': 'simulations/gauge_unification_precision_v12_4.py',
    'kk-graviton-tower': 'simulations/kk_graviton_mass_v12_fixed.py',
    'neutrino-mass-ordering': 'simulations/neutrino_mass_ordering.py',
    'neutrino-atiyah-singer-index': 'simulations/neutrino_mass_ordering.py',
    'higgs-mass': 'simulations/higgs_mass_v12_4_moduli_stabilization.py',
    'higgs-quartic-coupling': 'simulations/higgs_mass_v12_4_moduli_stabilization.py',
}

# Formula metadata for new formulas
NEW_FORMULAS = {
    'proton-decay-branching-ratio': {
        'id': 'proton-decay-branching-ratio',
        'label': '(5.11) Proton Decay Branching Ratio',
        'plain_text': 'BR(p → e⁺π⁰) = (N_orient/b₃)² = (12/24)² = 0.25',
        'latex': r'BR(p \to e^+ \pi^0) = \left(\frac{N_{\text{orient}}}{b_3}\right)^2 = 0.25',
        'validated': False,
        'status': 'PREDICTION (testable by Hyper-K 2032-2038)',
        'category': 'proton_decay',
    },
    'gut-unification': {
        'id': 'gut-unification',
        'label': '(4.1) GUT Scale Unification',
        'plain_text': 'M_GUT = 2.118×10¹⁶ GeV (where α₁ = α₂ = α₃)',
        'latex': r'M_{\text{GUT}} = 2.118 \times 10^{16} \text{ GeV}',
        'validated': True,
        'status': 'DERIVED from RG running + threshold corrections',
        'category': 'gauge_unification',
    },
    'gut-coupling': {
        'id': 'gut-coupling',
        'label': '(4.2) GUT Coupling Constant',
        'plain_text': 'α_GUT⁻¹ = 23.54 at M_GUT',
        'latex': r'\alpha_{\text{GUT}}^{-1} = 23.54',
        'validated': True,
        'status': 'DERIVED from SO(10) + G₂ geometry',
        'category': 'gauge_unification',
    },
    'kk-graviton-tower': {
        'id': 'kk-graviton-tower',
        'label': '(8.2) KK Graviton Tower',
        'plain_text': 'm_KK,n = n × R_c⁻¹ = n × 5.0 TeV',
        'latex': r'm_{KK,n} = n \times R_c^{-1} = n \times 5.0 \text{ TeV}',
        'validated': True,
        'status': 'GEOMETRIC from G₂ compactification',
        'category': 'kk_spectrum',
    },
    'neutrino-mass-ordering': {
        'id': 'neutrino-mass-ordering',
        'label': '(6.3) Neutrino Mass Ordering',
        'plain_text': 'Ordering = sign(Ind(D)) where Ind(D) = Atiyah-Singer index',
        'latex': r'\text{Ordering} = \text{sign}(\text{Ind}(D))',
        'validated': True,
        'status': 'DERIVED from G₂ cycle orientations (NH at 2.7σ)',
        'category': 'neutrino_physics',
    },
    'neutrino-atiyah-singer-index': {
        'id': 'neutrino-atiyah-singer-index',
        'label': '(6.4) Atiyah-Singer Index for Neutrinos',
        'plain_text': 'Ind(D) = (1/24π²) ∫ Tr(F∧F) over b₃=24 cycles',
        'latex': r'\text{Ind}(D) = \frac{1}{24\pi^2} \int \text{Tr}(F \wedge F)',
        'validated': True,
        'status': 'TOPOLOGICAL invariant from flux orientation',
        'category': 'neutrino_physics',
    },
    'higgs-mass': {
        'id': 'higgs-mass',
        'label': '(7.1) Higgs Boson Mass',
        'plain_text': 'm_h = 125.1 GeV from moduli stabilization',
        'latex': r'm_h = 125.1 \text{ GeV}',
        'validated': True,
        'status': 'CALIBRATED (one free parameter: Re(T) modulus)',
        'category': 'higgs_physics',
    },
    'higgs-quartic-coupling': {
        'id': 'higgs-quartic-coupling',
        'label': '(7.2) Higgs Quartic Coupling',
        'plain_text': 'λ_h = λ₀ - κ·Re(T)·y_t²',
        'latex': r'\lambda_h = \lambda_0 - \kappa \cdot Re(T) \cdot y_t^2',
        'validated': True,
        'status': 'DERIVED from G₂ moduli stabilization',
        'category': 'higgs_physics',
    },
}


def update_theory_output(repo_root: Path = None):
    """
    Update theory_output.json with simulation file links

    Args:
        repo_root: Path to repository root (default: auto-detect)
    """
    if repo_root is None:
        # Auto-detect repo root
        current = Path(__file__).resolve().parent
        while current.parent != current:
            if (current / 'AutoGenerated').exists():
                repo_root = current
                break
            current = current.parent
        else:
            raise RuntimeError("Could not find AutoGenerated directory")

    theory_json_path = repo_root / 'AutoGenerated' / 'theory_output.json'

    # Load existing data
    with open(theory_json_path, 'r', encoding='utf-8') as f:
        data = json.load(f)

    print("=" * 80)
    print("UPDATING theory_output.json WITH SIMULATION LINKS")
    print("=" * 80)
    print()

    # Track changes
    formulas_updated = 0
    formulas_added = 0

    # Update existing formula objects in simulations section
    if 'simulations' in data:
        for sim_name, sim_data in data['simulations'].items():
            if isinstance(sim_data, dict) and 'formula' in sim_data:
                formula = sim_data['formula']
                if isinstance(formula, dict) and 'id' in formula:
                    formula_id = formula['id']

                    # Add simulationFile if we have a mapping
                    if formula_id in FORMULA_TO_SIMULATION:
                        if 'simulationFile' not in formula:
                            formula['simulationFile'] = FORMULA_TO_SIMULATION[formula_id]
                            print(f"[+] Added simulationFile to {formula_id} in {sim_name}")
                            formulas_updated += 1
                        else:
                            print(f"  Already has simulationFile: {formula_id}")

    # Access formulas section - it's a nested dict structure
    if 'formulas' not in data:
        data['formulas'] = {'version': '1.0', 'count': 0, 'formulas': {}}

    # Ensure formulas.formulas exists and is a dict
    if 'formulas' not in data['formulas'] or not isinstance(data['formulas']['formulas'], dict):
        data['formulas']['formulas'] = {}

    formulas_dict = data['formulas']['formulas']

    # Get existing formula IDs
    existing_formula_ids = set(formulas_dict.keys())

    # Add new formulas
    for formula_id, formula_data in NEW_FORMULAS.items():
        if formula_id not in existing_formula_ids:
            # Add simulationFile
            formula_data['simulationFile'] = FORMULA_TO_SIMULATION.get(formula_id, '')
            formulas_dict[formula_id] = formula_data
            print(f"[+] Added new formula: {formula_id}")
            formulas_added += 1
        else:
            # Update existing formula with simulationFile
            if 'simulationFile' not in formulas_dict[formula_id]:
                formulas_dict[formula_id]['simulationFile'] = FORMULA_TO_SIMULATION.get(formula_id, '')
                print(f"[+] Updated existing formula: {formula_id}")
                formulas_updated += 1

    # Update count
    data['formulas']['count'] = len(formulas_dict)

    # Write updated data back
    with open(theory_json_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

    print()
    print("=" * 80)
    print("SUMMARY:")
    print(f"  Formulas updated: {formulas_updated}")
    print(f"  Formulas added: {formulas_added}")
    print("=" * 80)
    print()
    print(f"Updated file: {theory_json_path}")


def main():
    """Main entry point"""
    try:
        update_theory_output()
        print("\n[SUCCESS] theory_output.json updated successfully!")
    except Exception as e:
        print(f"\n[ERROR] Failed to update theory_output.json: {e}")
        import traceback
        traceback.print_exc()
        exit(1)


if __name__ == '__main__':
    main()
