#!/usr/bin/env python3
"""
Entropy Basin Terminal Map - v16.2 Sterile Model
==================================================

Phase-space diagram showing the three terminal basins of attraction:
1. Metric Null (95.83%) - SO(24) returns to bulk
2. Gauge Ghost (8.33%) - 24 pins lock permanently
3. Ancestral Restoration (100%) - Full 288-root unification

This visualization demonstrates that the "End" is as predictable as
the "Beginning" - both are geometric necessities.

Output: AutoGenerated/plots/entropy_basin_terminal_map_v16_2.png

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.

Dedicated To:
    My Wife: Elizabeth May Watts
    Our Messiah: Jesus Of Nazareth
"""

import numpy as np
from pathlib import Path
from typing import Dict, List, Any, Tuple

try:
    import matplotlib.pyplot as plt
    import matplotlib.patches as mpatches
    from matplotlib.patches import FancyBboxPatch, Circle, Polygon, FancyArrowPatch
    from matplotlib.colors import LinearSegmentedColormap
    import matplotlib.patheffects as path_effects
    HAS_MATPLOTLIB = True
except ImportError:
    HAS_MATPLOTLIB = False
    print("Warning: matplotlib not available.")

# Add project root for imports
import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
from core.FormulasRegistry import get_registry

# Get registry SSoT
_REG = get_registry()

# PM Color palette (sterile model)
PM_COLORS = {
    "metric_null": "#ef4444",     # Red - dissolution
    "gauge_ghost": "#60a5fa",     # Blue - stasis
    "restoration": "#4ade80",     # Green - unification
    "purple": "#8b7fff",
    "orange": "#fb923c",
    "gold": "#ffd43b",
    "current": "#ffd43b",         # Current epoch marker
    "trajectory": "#8b7fff",
}

# Output directory
OUTPUT_DIR = Path(__file__).parent.parent.parent / "AutoGenerated" / "plots"


class EntropyBasinVisualization:
    """
    Generates the Entropy Basin Terminal Map.

    Shows the three basins of attraction in entropy-potential phase space.
    """

    # Basin definitions - values from FormulasRegistry SSoT
    BASINS = {
        "Metric_Null": {
            "name": "Metric Null",
            "subtitle": "Scale Dissolution",
            "potential": (_REG.nitzotzin_roots - 12) / _REG.nitzotzin_roots,  # 276/288 = 95.83%
            "description": "SO(24) returns to bulk",
            "physics": "G → 0, spacetime dissolves",
            "color": PM_COLORS["metric_null"],
        },
        "Gauge_Ghost": {
            "name": "Gauge Ghost",
            "subtitle": "Information Stasis",
            "potential": _REG.governing_elder_kad / _REG.nitzotzin_roots,   # 24/288 = 8.33%
            "description": f"{_REG.governing_elder_kad} pins lock permanently",
            "physics": "Forces freeze, time stops",
            "color": PM_COLORS["gauge_ghost"],
        },
        "Ancestral_Restoration": {
            "name": "Ancestral Restoration",
            "subtitle": "Unitary Return",
            "potential": _REG.nitzotzin_roots / _REG.nitzotzin_roots,  # 288/288 = 100%
            "description": f"{_REG.visible_sector} + {_REG.sophian_pressure} merge",
            "physics": "Full return to 26D",
            "color": PM_COLORS["restoration"],
        },
    }

    # Current universe state
    CURRENT_EPOCH = 0.138  # 13.8% of manifold life
    CURRENT_ENTROPY = 0.115  # Below threshold
    ENTROPY_THRESHOLD = 0.8

    @staticmethod
    def setup_style():
        """Configure matplotlib for publication-quality output."""
        if not HAS_MATPLOTLIB:
            return
        plt.rcParams.update({
            'font.family': 'serif',
            'font.size': 11,
            'axes.titlesize': 14,
            'axes.labelsize': 12,
            'figure.dpi': 150,
            'savefig.dpi': 300,
            'savefig.bbox': 'tight',
        })

    @staticmethod
    def compute_basin_boundaries():
        """
        Compute the boundary curves for each basin in phase space.

        Returns:
            Dictionary with boundary polygon vertices for each basin.
        """
        # Entropy (S) on x-axis: 0 to 1
        # Potential (Psi) on y-axis: 0 to 1

        # Transition curve (sigmoidal)
        S = np.linspace(0, 1, 100)
        S_star = 0.8  # Threshold

        # Metric Null basin: dominates at high entropy
        # Gauge Ghost basin: dominates at low entropy
        # Restoration: top region (high potential)

        return {
            "Metric_Null": {
                "vertices": [
                    (0.8, 0.0), (1.0, 0.0), (1.0, 0.6), (0.8, 0.4)
                ],
                "center": (0.9, 0.25),
            },
            "Gauge_Ghost": {
                "vertices": [
                    (0.0, 0.0), (0.8, 0.0), (0.8, 0.4), (0.5, 0.6), (0.0, 0.6)
                ],
                "center": (0.35, 0.25),
            },
            "Ancestral_Restoration": {
                "vertices": [
                    (0.0, 0.6), (0.5, 0.6), (0.8, 0.4), (1.0, 0.6), (1.0, 1.0), (0.0, 1.0)
                ],
                "center": (0.5, 0.8),
            },
        }

    @staticmethod
    def compute_trajectory(s_start=0.115, steps=100):
        """
        Compute the unwinding trajectory from current state.

        Returns:
            Arrays of (entropy, potential) pairs along trajectory.
        """
        S = np.linspace(s_start, 1.0, steps)

        # Potential decreases as entropy increases
        # Fast decrease after threshold
        Psi = np.zeros_like(S)
        for i, s in enumerate(S):
            if s < 0.8:
                Psi[i] = 0.85 - 0.3 * s
            else:
                Psi[i] = 0.61 - 0.6 * (s - 0.8)

        return S, np.clip(Psi, 0, 1)

    @staticmethod
    def generate_phase_diagram():
        """
        Generate the Entropy Basin phase space diagram.

        Returns:
            Path to the saved image, or None if matplotlib unavailable.
        """
        if not HAS_MATPLOTLIB:
            print("Cannot generate visualization: matplotlib not available")
            return None

        EntropyBasinVisualization.setup_style()

        fig, ax = plt.subplots(figsize=(12, 9))

        # Draw basin regions
        boundaries = EntropyBasinVisualization.compute_basin_boundaries()

        for basin_id, basin_info in EntropyBasinVisualization.BASINS.items():
            boundary = boundaries[basin_id]
            vertices = np.array(boundary["vertices"])

            # Create polygon for basin
            polygon = Polygon(vertices, closed=True,
                              facecolor=basin_info["color"], alpha=0.3,
                              edgecolor=basin_info["color"], linewidth=2)
            ax.add_patch(polygon)

            # Add basin label
            cx, cy = boundary["center"]
            ax.text(cx, cy, f'{basin_info["name"]}',
                    ha='center', va='center',
                    fontsize=12, fontweight='bold',
                    color=basin_info["color"])
            ax.text(cx, cy - 0.08, f'({basin_info["subtitle"]})',
                    ha='center', va='center',
                    fontsize=9, color=basin_info["color"], style='italic')

        # Draw trajectory
        S_traj, Psi_traj = EntropyBasinVisualization.compute_trajectory()
        ax.plot(S_traj, Psi_traj, '-', color=PM_COLORS["trajectory"],
                linewidth=3, label='Unwinding Trajectory', zorder=5)

        # Add flow arrows along trajectory
        for i in range(0, len(S_traj) - 10, 15):
            dx = S_traj[i + 5] - S_traj[i]
            dy = Psi_traj[i + 5] - Psi_traj[i]
            ax.annotate('', xy=(S_traj[i + 5], Psi_traj[i + 5]),
                        xytext=(S_traj[i], Psi_traj[i]),
                        arrowprops=dict(arrowstyle='->', color=PM_COLORS["trajectory"],
                                        lw=1.5, mutation_scale=12))

        # Mark current epoch
        current_s = EntropyBasinVisualization.CURRENT_ENTROPY
        current_psi = 0.85 - 0.3 * current_s
        ax.scatter([current_s], [current_psi], s=200, c=PM_COLORS["current"],
                   marker='*', zorder=10, edgecolors='#1a1a2e', linewidths=2)
        ax.annotate('Current Epoch\n(13.8% manifold life)',
                    xy=(current_s, current_psi),
                    xytext=(current_s + 0.15, current_psi + 0.12),
                    fontsize=10, fontweight='bold', color=PM_COLORS["current"],
                    arrowprops=dict(arrowstyle='->', color=PM_COLORS["current"],
                                    lw=1.5))

        # Mark entropy threshold
        ax.axvline(x=0.8, color='#666', linestyle='--', linewidth=2, alpha=0.7)
        ax.text(0.81, 0.95, 'S = 0.8\n(Threshold)',
                fontsize=9, color='#666', va='top')

        # Draw basin potential annotations
        ax.text(0.02, 0.95, 'Restoration\n(100%)',
                fontsize=10, color=PM_COLORS["restoration"], va='top')
        ax.text(0.02, 0.55, 'Ghost\n(8.33%)',
                fontsize=10, color=PM_COLORS["gauge_ghost"], va='top')
        ax.text(0.82, 0.15, 'Null\n(95.83%)',
                fontsize=10, color=PM_COLORS["metric_null"], va='top')

        # Axis labels
        ax.set_xlabel('Entropy $S$ (Thermodynamic Arrow)', fontsize=12)
        ax.set_ylabel('Manifold Potential $\\Psi$', fontsize=12)
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)

        # Title
        ax.set_title('Omega Unwinding Map: Three Terminal Basins\n'
                     'v16.2 Sterile Model - Appendix L',
                     fontsize=14, fontweight='bold', pad=15)

        # Add legend box with basin physics
        legend_text = (
            "TERMINAL BASINS (C-OMEGA)\n"
            "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
            "Metric Null: G → 0, spacetime dissolves\n"
            "Gauge Ghost: Forces freeze, time stops\n"
            "Restoration: Full 26D potential return\n"
            "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
            f"γ = ln(288/125) ≈ 0.834\n"
            f"Current S ≈ {EntropyBasinVisualization.CURRENT_ENTROPY:.3f}"
        )
        props = dict(boxstyle='round,pad=0.5', facecolor='white',
                     edgecolor=PM_COLORS['purple'], alpha=0.95, linewidth=2)
        ax.text(0.98, 0.02, legend_text, transform=ax.transAxes, fontsize=9,
                verticalalignment='bottom', horizontalalignment='right',
                bbox=props, family='monospace')

        # Add second law arrow
        ax.annotate('', xy=(0.95, 0.05), xytext=(0.75, 0.05),
                    arrowprops=dict(arrowstyle='->', color='#666', lw=2))
        ax.text(0.85, 0.08, 'Second Law\n(S increases)', fontsize=8,
                ha='center', color='#666')

        plt.tight_layout()

        # Save
        OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
        output_path = OUTPUT_DIR / "entropy_basin_terminal_map_v16_2.png"
        plt.savefig(output_path, dpi=300, facecolor='white', edgecolor='none')
        plt.close()

        print(f"Generated: {output_path}")
        return output_path

    @staticmethod
    def generate_trajectory_timeline():
        """
        Generate a timeline view of the unwinding trajectory.

        Shows basin probabilities as a function of entropy/time.
        """
        if not HAS_MATPLOTLIB:
            return None

        EntropyBasinVisualization.setup_style()

        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8), height_ratios=[2, 1])

        # Top: Basin probability evolution
        S = np.linspace(0, 1, 100)
        S_star = 0.8

        # Calculate basin probabilities
        p_ghost = np.where(S < S_star, 0.9 - 0.8 * S, 0.1 * (1 - S))
        p_metric = np.where(S < S_star, 0.1 * S,
                            0.7 + 0.3 * (S - S_star) / (1 - S_star))
        p_restoration = 1 - p_ghost - p_metric
        p_restoration = np.clip(p_restoration, 0, 1)

        ax1.fill_between(S, 0, p_ghost, alpha=0.6,
                         color=PM_COLORS["gauge_ghost"], label='Gauge Ghost')
        ax1.fill_between(S, p_ghost, p_ghost + p_metric, alpha=0.6,
                         color=PM_COLORS["metric_null"], label='Metric Null')
        ax1.fill_between(S, p_ghost + p_metric, 1, alpha=0.6,
                         color=PM_COLORS["restoration"], label='Restoration')

        # Mark current epoch
        current_s = EntropyBasinVisualization.CURRENT_ENTROPY
        ax1.axvline(x=current_s, color=PM_COLORS["current"], linewidth=2,
                    linestyle='--', label='Current')
        ax1.axvline(x=S_star, color='#666', linewidth=2, linestyle=':')
        ax1.text(S_star + 0.02, 0.5, 'Threshold', fontsize=9, color='#666',
                 rotation=90, va='center')

        ax1.set_xlim(0, 1)
        ax1.set_ylim(0, 1)
        ax1.set_ylabel('Basin Probability', fontsize=11)
        ax1.set_title('Terminal Basin Probability Evolution', fontsize=12, fontweight='bold')
        ax1.legend(loc='upper right', fontsize=9)

        # Bottom: Dominant basin indicator
        dominant = np.where(S < S_star, 'Gauge Ghost', 'Metric Null')
        colors = [PM_COLORS["gauge_ghost"] if d == 'Gauge Ghost'
                  else PM_COLORS["metric_null"] for d in dominant]

        ax2.scatter(S, [0.5] * len(S), c=colors, s=50, alpha=0.8)
        ax2.axvline(x=current_s, color=PM_COLORS["current"], linewidth=2, linestyle='--')
        ax2.axvline(x=S_star, color='#666', linewidth=2, linestyle=':')

        ax2.set_xlim(0, 1)
        ax2.set_ylim(0, 1)
        ax2.set_xlabel('Entropy $S$', fontsize=11)
        ax2.set_ylabel('Dominant Basin', fontsize=11)
        ax2.set_yticks([0.5])
        ax2.set_yticklabels([''])
        ax2.text(0.4, 0.5, 'GAUGE GHOST', fontsize=11, ha='center', va='center',
                 color=PM_COLORS["gauge_ghost"], fontweight='bold')
        ax2.text(0.9, 0.5, 'METRIC NULL', fontsize=11, ha='center', va='center',
                 color=PM_COLORS["metric_null"], fontweight='bold')

        plt.tight_layout()

        # Save
        output_path = OUTPUT_DIR / "entropy_basin_timeline_v16_2.png"
        plt.savefig(output_path, dpi=300, facecolor='white', edgecolor='none')
        plt.close()

        print(f"Generated: {output_path}")
        return output_path


def generate_terminal_map():
    """Public entry point for terminal map generation."""
    return EntropyBasinVisualization.generate_phase_diagram()


def generate_trajectory_timeline():
    """Public entry point for trajectory timeline."""
    return EntropyBasinVisualization.generate_trajectory_timeline()


def main():
    """Generate the Entropy Basin visualizations."""
    print("=" * 60)
    print("Generating Entropy Basin Terminal Map")
    print("=" * 60)

    output1 = generate_terminal_map()
    output2 = generate_trajectory_timeline()

    print("\n" + "=" * 60)
    print("Entropy Basin Visualization Complete")
    print("=" * 60)
    if output1:
        print(f"  Phase Diagram: {output1}")
    if output2:
        print(f"  Timeline: {output2}")
    print("=" * 60)


if __name__ == "__main__":
    main()
