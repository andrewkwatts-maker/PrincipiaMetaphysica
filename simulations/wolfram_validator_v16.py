#!/usr/bin/env python3
"""
PRINCIPIA METAPHYSICA v16.1 - Wolfram Alpha Validation Framework
=================================================================

Provides symbolic validation of PM physics formulas against established
physics using the Wolfram Alpha Full Results API.

This serves as the "Truth Service" for all physics derivations, enabling:
1. Automated verification of computed values
2. Step-by-step derivation proofs
3. Self-run verification links for readers
4. Audit trail for publication appendices

USAGE:
    python wolfram_validator_v16.py

REQUIREMENTS:
    pip install wolframalpha

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.

Dedicated To:
    My Wife: Elizabeth May Watts
    Our Messiah: Jesus Of Nazareth
"""

import json
import os
import urllib.parse
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from datetime import datetime

try:
    import wolframalpha
    WOLFRAM_AVAILABLE = True
except ImportError:
    WOLFRAM_AVAILABLE = False
    print("Warning: wolframalpha package not installed. Run: pip install wolframalpha")


@dataclass
class ValidationEntry:
    """A single validation result."""
    id: str
    label: str
    category: str
    theory_formula: str
    wolfram_query: str
    pm_value: float
    wolfram_result: Optional[str] = None
    status: str = "PENDING"
    verify_link: str = ""
    derivation_steps: List[str] = None
    notes: str = ""
    timestamp: str = ""

    def __post_init__(self):
        if self.derivation_steps is None:
            self.derivation_steps = []
        if not self.timestamp:
            self.timestamp = datetime.now().isoformat()
        if not self.verify_link:
            encoded = urllib.parse.quote(self.wolfram_query)
            self.verify_link = f"https://www.wolframalpha.com/input/?i={encoded}"


class WolframValidator:
    """
    Validates PM physics formulas against Wolfram Alpha.

    This is the core validation engine that:
    1. Sends queries to Wolfram Alpha API
    2. Extracts results and step-by-step derivations
    3. Generates proof manifests for the website
    4. Creates self-verification links
    """

    def __init__(self, app_id: str = None):
        """
        Initialize the validator.

        Args:
            app_id: Wolfram Alpha App ID. If None, loads from secrets_config.
        """
        if app_id is None:
            try:
                from secrets_config import WOLFRAM_APP_ID
                app_id = WOLFRAM_APP_ID
            except ImportError:
                raise ValueError(
                    "No Wolfram App ID provided. Either pass app_id or create "
                    "simulations/secrets_config.py with WOLFRAM_APP_ID"
                )

        self.app_id = app_id
        if WOLFRAM_AVAILABLE:
            self.client = wolframalpha.Client(app_id)
        else:
            self.client = None

        # Ensure output directories exist
        os.makedirs("AutoGenerated/validations", exist_ok=True)
        os.makedirs("AutoGenerated/proofs", exist_ok=True)

    def query(self, query_string: str) -> Dict[str, Any]:
        """
        Send a query to Wolfram Alpha and extract all pods.

        Args:
            query_string: The query to send

        Returns:
            Dictionary with result, pods, and step-by-step info
        """
        if not WOLFRAM_AVAILABLE or self.client is None:
            return {
                "success": False,
                "error": "Wolfram Alpha client not available",
                "query": query_string
            }

        try:
            res = self.client.query(query_string)

            pods = {}
            result_text = None
            steps = []

            for pod in res.pods:
                pod_data = {
                    "title": pod.title,
                    "subpods": []
                }

                for subpod in pod.subpods:
                    subpod_data = {
                        "text": subpod.plaintext,
                        "img": subpod.img.src if hasattr(subpod, 'img') and subpod.img else None
                    }
                    pod_data["subpods"].append(subpod_data)

                    # Extract result
                    if pod.title in ['Result', 'Decimal approximation', 'Exact result']:
                        if subpod.plaintext:
                            result_text = subpod.plaintext

                    # Extract derivation steps
                    if 'step' in pod.title.lower() or 'derivation' in pod.title.lower():
                        if subpod.plaintext:
                            steps.append(subpod.plaintext)

                pods[pod.title] = pod_data

            return {
                "success": True,
                "query": query_string,
                "result": result_text,
                "steps": steps,
                "pods": pods
            }

        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "query": query_string
            }

    def validate_formula(self, entry: ValidationEntry) -> ValidationEntry:
        """
        Validate a single formula against Wolfram Alpha.

        Args:
            entry: ValidationEntry with the formula details

        Returns:
            Updated ValidationEntry with results
        """
        print(f"üîç Validating: {entry.label}")

        response = self.query(entry.wolfram_query)

        if response["success"]:
            entry.wolfram_result = response["result"]
            entry.derivation_steps = response.get("steps", [])

            # Check if result matches PM prediction
            if entry.wolfram_result:
                try:
                    # Extract numeric value from result
                    wolfram_numeric = self._extract_numeric(entry.wolfram_result)
                    if wolfram_numeric is not None:
                        rel_error = abs(wolfram_numeric - entry.pm_value) / max(abs(entry.pm_value), 1e-10)
                        if rel_error < 0.01:  # Within 1%
                            entry.status = "VERIFIED"
                        elif rel_error < 0.05:  # Within 5%
                            entry.status = "CLOSE"
                        else:
                            entry.status = "MISMATCH"
                    else:
                        entry.status = "SYMBOLIC"  # Non-numeric result
                except:
                    entry.status = "SYMBOLIC"
            else:
                entry.status = "NO_RESULT"
        else:
            entry.status = "ERROR"
            entry.notes = response.get("error", "Unknown error")

        entry.timestamp = datetime.now().isoformat()

        # Save individual validation
        self._save_validation(entry)

        return entry

    def _extract_numeric(self, text: str) -> Optional[float]:
        """Extract numeric value from Wolfram result text."""
        import re
        # Try to find a number in the text
        match = re.search(r'[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?', text.replace('√ó10^', 'e'))
        if match:
            try:
                return float(match.group())
            except:
                pass
        return None

    def _save_validation(self, entry: ValidationEntry):
        """Save a validation entry to JSON file."""
        filepath = f"AutoGenerated/validations/{entry.id}.json"
        with open(filepath, 'w') as f:
            json.dump(asdict(entry), f, indent=2)

    def validate_batch(self, entries: List[ValidationEntry]) -> List[ValidationEntry]:
        """
        Validate multiple formulas.

        Args:
            entries: List of ValidationEntry objects

        Returns:
            List of updated entries with results
        """
        results = []
        for entry in entries:
            result = self.validate_formula(entry)
            results.append(result)
            print(f"  ‚Üí Status: {result.status}")
        return results

    def generate_proof_manifest(self, entries: List[ValidationEntry], output_path: str = None):
        """
        Generate the proof manifest JSON for the website.

        Args:
            entries: List of validation entries
            output_path: Output file path
        """
        if output_path is None:
            output_path = "AutoGenerated/proof_manifest.json"

        manifest = {
            "version": "16.1",
            "generated": datetime.now().isoformat(),
            "total_validations": len(entries),
            "verified": sum(1 for e in entries if e.status == "VERIFIED"),
            "entries": [asdict(e) for e in entries]
        }

        with open(output_path, 'w') as f:
            json.dump(manifest, f, indent=2)

        print(f"\n‚úÖ Proof manifest saved to: {output_path}")
        print(f"   Total: {manifest['total_validations']}, Verified: {manifest['verified']}")


# =============================================================================
# VALIDATION REGISTRY - All PM formulas requiring Wolfram verification
# =============================================================================

def get_validation_registry() -> List[ValidationEntry]:
    """
    Returns the complete registry of formulas to validate.

    Categories:
    - GEOMETRIC: Topological constants from b‚ÇÉ=24
    - GAUGE: Coupling evolution and unification
    - COSMOLOGY: Hubble tension, dark energy
    - FERMION: Masses, mixing, generations
    - NEUTRINO: PMNS angles, masses
    - QUANTUM: Collapse times, coherence
    """

    return [
        # === GEOMETRIC ANCHORS ===
        ValidationEntry(
            id="k_gimel",
            label="Warp Factor k_gimel",
            category="GEOMETRIC",
            theory_formula="k_gimel = b‚ÇÉ/2 + 1/œÄ",
            wolfram_query="24/2 + 1/pi",
            pm_value=12.318310,
            notes="From TCS G2 topology"
        ),
        ValidationEntry(
            id="c_kaf",
            label="Flux Constraint C_kaf",
            category="GEOMETRIC",
            theory_formula="C_kaf = b‚ÇÉ(b‚ÇÉ-7)/(b‚ÇÉ-9)",
            wolfram_query="24 * (24-7) / (24-9)",
            pm_value=27.2,
            notes="G2 intersection matrix"
        ),
        ValidationEntry(
            id="chi_eff",
            label="Effective Euler Characteristic",
            category="GEOMETRIC",
            theory_formula="œá_eff = 6 √ó b‚ÇÉ",
            wolfram_query="6 * 24",
            pm_value=144,
            notes="Topological charge"
        ),
        ValidationEntry(
            id="alpha_gut_inv",
            label="GUT Coupling Inverse",
            category="GEOMETRIC",
            theory_formula="1/Œ±_GUT = b‚ÇÉ + 1/10 + 1/(5√ób‚ÇÉ)",
            wolfram_query="24 + 1/10 + 1/(5*24)",
            pm_value=24.108333,
            notes="Derived from b‚ÇÉ"
        ),

        # === COSMOLOGY ===
        ValidationEntry(
            id="h0_resolution",
            label="Hubble Constant Resolution",
            category="COSMOLOGY",
            theory_formula="H‚ÇÄ = H_early √ó (1 + k_gimel/200)",
            wolfram_query="67.4 * (1 + 12.318/200)",
            pm_value=72.55,
            notes="EDE mechanism at z=3540"
        ),
        ValidationEntry(
            id="w0_dark_energy",
            label="Dark Energy w‚ÇÄ",
            category="COSMOLOGY",
            theory_formula="w‚ÇÄ = -(d_eff - 1)/(d_eff + 1)",
            wolfram_query="-(7 - 1)/(7 + 1)",
            pm_value=-0.75,
            notes="From 7D compactification"
        ),
        ValidationEntry(
            id="dm_ratio",
            label="Dark Matter Ratio Œ©_DM/Œ©_b",
            category="COSMOLOGY",
            theory_formula="Œ©_DM/Œ©_b = (T'/T)^4 √ó volume_ratio",
            wolfram_query="0.57^4 * 55.1",
            pm_value=5.82,
            notes="Mirror sector thermal history"
        ),

        # === GAUGE SECTOR ===
        ValidationEntry(
            id="m_gut",
            label="GUT Scale",
            category="GAUGE",
            theory_formula="M_GUT = M_P √ó exp(-œÄ √ó œá_eff / b‚ÇÉ)",
            wolfram_query="2.435e18 * exp(-pi * 144 / 24)",
            pm_value=2.1e16,
            notes="Gauge unification scale"
        ),
        ValidationEntry(
            id="sin2_theta_w",
            label="Weinberg Angle",
            category="GAUGE",
            theory_formula="sin¬≤Œ∏_W = 3/8 at M_GUT, runs to 0.2312",
            wolfram_query="3/8",
            pm_value=0.375,
            notes="GUT prediction (high scale)"
        ),

        # === FERMION SECTOR ===
        ValidationEntry(
            id="n_generations",
            label="Number of Generations",
            category="FERMION",
            theory_formula="N_gen = b‚ÇÉ/8",
            wolfram_query="24/8",
            pm_value=3,
            notes="From G2 3-cycles"
        ),
        ValidationEntry(
            id="tau_proton",
            label="Proton Lifetime",
            category="FERMION",
            theory_formula="œÑ_p ‚àù M_GUT‚Å¥/(Œ±_GUT¬≤ m_p‚Åµ) √ó S¬≤",
            wolfram_query="(2.1e16)^4 / ((1/24)^2 * (0.938)^5) * (2.125)^2 in years",
            pm_value=8.15e34,
            notes="With geometric suppression S=2.125"
        ),

        # === NEUTRINO SECTOR ===
        ValidationEntry(
            id="theta_12",
            label="Solar Mixing Angle Œ∏‚ÇÅ‚ÇÇ",
            category="NEUTRINO",
            theory_formula="Œ∏‚ÇÅ‚ÇÇ = arcsin(‚àö(1/3 + Œµ)) where Œµ from b‚ÇÉ",
            wolfram_query="arcsin(sqrt(1/3)) in degrees",
            pm_value=33.41,
            notes="Tribimaximal base + correction"
        ),
        ValidationEntry(
            id="theta_23",
            label="Atmospheric Mixing Œ∏‚ÇÇ‚ÇÉ",
            category="NEUTRINO",
            theory_formula="Œ∏‚ÇÇ‚ÇÉ = 45¬∞ + Œ¥(b‚ÇÉ)",
            wolfram_query="45 + 4.75",
            pm_value=49.75,
            notes="Maximal + G2 correction"
        ),
        ValidationEntry(
            id="delta_cp",
            label="CP Phase Œ¥_CP",
            category="NEUTRINO",
            theory_formula="Œ¥_CP from G2 complex structure",
            wolfram_query="232.5 degrees in radians",
            pm_value=232.5,
            notes="NuFIT 6.0 NO best fit: 232¬∞"
        ),

        # === QUANTUM BIOLOGY ===
        ValidationEntry(
            id="orch_or_tau",
            label="Orch-OR Collapse Time",
            category="QUANTUM",
            theory_formula="œÑ = ‚Ñè/E_G where E_G from G2",
            wolfram_query="hbar / (1e-32 * c^2 / (6.67e-11)) in seconds",
            pm_value=25e-3,
            notes="Penrose-Hameroff criterion"
        ),

        # === MASTER ACTION COMPONENTS ===
        ValidationEntry(
            id="einstein_hilbert_7d",
            label="7D Einstein-Hilbert",
            category="MASTER_ACTION",
            theory_formula="S_EH = ‚à´ d‚Å∑x ‚àög R‚Çá",
            wolfram_query="integral of Ricci scalar in 7 dimensions",
            pm_value=0,
            notes="Dimensional reduction to 4D"
        ),
        ValidationEntry(
            id="g2_volume",
            label="G2 Manifold Volume",
            category="MASTER_ACTION",
            theory_formula="Vol(X) = Vol(K3) √ó Vol(S¬≥/Œì)",
            wolfram_query="volume of K3 surface times volume of lens space L(24,1)",
            pm_value=1.0,
            notes="Normalized compact volume"
        ),
    ]


# =============================================================================
# MAIN EXECUTION
# =============================================================================

if __name__ == "__main__":
    print("=" * 70)
    print("PRINCIPIA METAPHYSICA v16.1 - WOLFRAM ALPHA VALIDATION")
    print("=" * 70)

    # Initialize validator
    try:
        validator = WolframValidator()
    except Exception as e:
        print(f"‚ùå Failed to initialize validator: {e}")
        print("   Creating mock validation manifest instead...")

        # Create mock manifest for testing
        registry = get_validation_registry()
        manifest = {
            "version": "16.1",
            "generated": datetime.now().isoformat(),
            "note": "Mock manifest - Wolfram API not available",
            "entries": [asdict(e) for e in registry]
        }
        with open("AutoGenerated/proof_manifest.json", 'w') as f:
            json.dump(manifest, f, indent=2)
        print("   Mock manifest saved to AutoGenerated/proof_manifest.json")
        exit(0)

    # Get validation registry
    registry = get_validation_registry()
    print(f"\nüìã Loaded {len(registry)} formulas for validation\n")

    # Validate all formulas
    results = validator.validate_batch(registry)

    # Generate proof manifest
    validator.generate_proof_manifest(results)

    # Summary
    print("\n" + "=" * 70)
    print("VALIDATION SUMMARY")
    print("=" * 70)

    status_counts = {}
    for r in results:
        status_counts[r.status] = status_counts.get(r.status, 0) + 1

    for status, count in sorted(status_counts.items()):
        emoji = {"VERIFIED": "‚úÖ", "CLOSE": "üî∂", "MISMATCH": "‚ùå", "ERROR": "‚ö†Ô∏è"}.get(status, "‚ùì")
        print(f"  {emoji} {status}: {count}")
