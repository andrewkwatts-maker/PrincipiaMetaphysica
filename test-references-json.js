#!/usr/bin/env node

/**
 * Test Local References JSON
 *
 * Validates the AutoGenerated/references.json file structure
 * and ensures it's compatible with the references.html page.
 */

const fs = require('fs');
const path = require('path');

console.log('Testing AutoGenerated/references.json...\n');

// Load the references file
const referencesPath = path.join(__dirname, 'AutoGenerated', 'references.json');

if (!fs.existsSync(referencesPath)) {
  console.error('❌ Error: references.json not found at:', referencesPath);
  process.exit(1);
}

// Read and parse JSON
let references;
try {
  const fileContent = fs.readFileSync(referencesPath, 'utf-8');
  references = JSON.parse(fileContent);
  console.log('✅ Successfully loaded and parsed references.json');
  console.log(`   File size: ${fileContent.length} bytes\n`);
} catch (error) {
  console.error('❌ Error parsing JSON:', error.message);
  process.exit(1);
}

// Validate structure
console.log('Validating structure...');

// Check if references is an object
if (typeof references !== 'object' || Array.isArray(references)) {
  console.error('❌ Error: Expected references to be an object, got:', typeof references);
  process.exit(1);
}

const refKeys = Object.keys(references);
console.log(`✅ Found ${refKeys.length} references\n`);

// Validate each reference
let validCount = 0;
let invalidCount = 0;
const requiredFields = ['id', 'authors', 'title', 'year', 'journal'];
const optionalFields = ['arxiv', 'doi', 'description', 'citedByFormulas', 'citedByParams'];

console.log('Checking individual references...');

refKeys.forEach((key, index) => {
  const ref = references[key];
  const missingFields = [];

  // Check required fields
  requiredFields.forEach(field => {
    if (!(field in ref)) {
      missingFields.push(field);
    }
  });

  // Check year is a number
  if (typeof ref.year !== 'number') {
    missingFields.push('year (not a number)');
  }

  // Check citedByFormulas and citedByParams are arrays if present
  if (ref.citedByFormulas && !Array.isArray(ref.citedByFormulas)) {
    missingFields.push('citedByFormulas (not an array)');
  }
  if (ref.citedByParams && !Array.isArray(ref.citedByParams)) {
    missingFields.push('citedByParams (not an array)');
  }

  if (missingFields.length > 0) {
    console.log(`  ⚠ ${ref.id || key}: Missing or invalid fields: ${missingFields.join(', ')}`);
    invalidCount++;
  } else {
    validCount++;
  }

  // Show first 3 valid references
  if (missingFields.length === 0 && validCount <= 3) {
    const citations = (ref.citedByFormulas?.length || 0) + (ref.citedByParams?.length || 0);
    console.log(`  ✅ ${ref.id}: ${ref.authors} (${ref.year}) - ${citations} citations`);
  }
});

console.log(`\n${'─'.repeat(60)}`);
console.log(`Valid references: ${validCount}`);
console.log(`Invalid references: ${invalidCount}`);

// Statistics
const withArxiv = refKeys.filter(k => references[k].arxiv && references[k].arxiv.length > 0).length;
const withDOI = refKeys.filter(k => references[k].doi && references[k].doi.length > 0).length;
const withDescription = refKeys.filter(k => references[k].description).length;
const withCitations = refKeys.filter(k => {
  const ref = references[k];
  return (ref.citedByFormulas?.length || 0) + (ref.citedByParams?.length || 0) > 0;
}).length;

console.log(`\nStatistics:`);
console.log(`  With arXiv: ${withArxiv} (${(withArxiv/refKeys.length*100).toFixed(1)}%)`);
console.log(`  With DOI: ${withDOI} (${(withDOI/refKeys.length*100).toFixed(1)}%)`);
console.log(`  With description: ${withDescription} (${(withDescription/refKeys.length*100).toFixed(1)}%)`);
console.log(`  With citations: ${withCitations} (${(withCitations/refKeys.length*100).toFixed(1)}%)`);

// Year distribution
const decades = {};
refKeys.forEach(k => {
  const year = references[k].year;
  if (typeof year === 'number') {
    const decade = Math.floor(year / 10) * 10;
    decades[decade] = (decades[decade] || 0) + 1;
  }
});

console.log(`\nReferences by decade:`);
Object.keys(decades).sort((a, b) => b - a).forEach(decade => {
  console.log(`  ${decade}s: ${decades[decade]}`);
});

console.log(`\n${'─'.repeat(60)}`);
if (invalidCount === 0) {
  console.log('✅ All references valid! File ready for use.');
} else {
  console.log('⚠ Some references need attention.');
}

process.exit(invalidCount > 0 ? 1 : 0);
