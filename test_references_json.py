#!/usr/bin/env python3
"""
Test Local References JSON

Validates the AutoGenerated/references.json file structure
and ensures it's compatible with the references.html page.
"""

import json
import os
from pathlib import Path

print('Testing AutoGenerated/references.json...\n')

# Load the references file
references_path = Path(__file__).parent / 'AutoGenerated' / 'references.json'

if not references_path.exists():
    print(f'❌ Error: references.json not found at: {references_path}')
    exit(1)

# Read and parse JSON
try:
    with open(references_path, 'r', encoding='utf-8') as f:
        file_content = f.read()
        references = json.loads(file_content)
    print('✅ Successfully loaded and parsed references.json')
    print(f'   File size: {len(file_content)} bytes\n')
except Exception as error:
    print(f'❌ Error parsing JSON: {error}')
    exit(1)

# Validate structure
print('Validating structure...')

# Check if references is a dict
if not isinstance(references, dict):
    print(f'❌ Error: Expected references to be a dict, got: {type(references).__name__}')
    exit(1)

ref_keys = list(references.keys())
print(f'✅ Found {len(ref_keys)} references\n')

# Validate each reference
valid_count = 0
invalid_count = 0
required_fields = ['id', 'authors', 'title', 'year', 'journal']
optional_fields = ['arxiv', 'doi', 'description', 'citedByFormulas', 'citedByParams']

print('Checking individual references...')

for key in ref_keys:
    ref = references[key]
    missing_fields = []

    # Check required fields
    for field in required_fields:
        if field not in ref:
            missing_fields.append(field)

    # Check year is a number
    if not isinstance(ref.get('year'), int):
        missing_fields.append('year (not a number)')

    # Check citedByFormulas and citedByParams are arrays if present
    if 'citedByFormulas' in ref and not isinstance(ref['citedByFormulas'], list):
        missing_fields.append('citedByFormulas (not an array)')
    if 'citedByParams' in ref and not isinstance(ref['citedByParams'], list):
        missing_fields.append('citedByParams (not an array)')

    if missing_fields:
        print(f"  ⚠ {ref.get('id', key)}: Missing or invalid fields: {', '.join(missing_fields)}")
        invalid_count += 1
    else:
        valid_count += 1

    # Show first 3 valid references
    if not missing_fields and valid_count <= 3:
        citations = len(ref.get('citedByFormulas', [])) + len(ref.get('citedByParams', []))
        print(f"  ✅ {ref['id']}: {ref['authors']} ({ref['year']}) - {citations} citations")

print(f"\n{'─' * 60}")
print(f'Valid references: {valid_count}')
print(f'Invalid references: {invalid_count}')

# Statistics
with_arxiv = sum(1 for k in ref_keys if references[k].get('arxiv'))
with_doi = sum(1 for k in ref_keys if references[k].get('doi'))
with_description = sum(1 for k in ref_keys if references[k].get('description'))
with_citations = sum(1 for k in ref_keys if (
    len(references[k].get('citedByFormulas', [])) + len(references[k].get('citedByParams', []))
) > 0)

print(f'\nStatistics:')
print(f'  With arXiv: {with_arxiv} ({with_arxiv/len(ref_keys)*100:.1f}%)')
print(f'  With DOI: {with_doi} ({with_doi/len(ref_keys)*100:.1f}%)')
print(f'  With description: {with_description} ({with_description/len(ref_keys)*100:.1f}%)')
print(f'  With citations: {with_citations} ({with_citations/len(ref_keys)*100:.1f}%)')

# Year distribution
decades = {}
for k in ref_keys:
    year = references[k].get('year')
    if isinstance(year, int):
        decade = (year // 10) * 10
        decades[decade] = decades.get(decade, 0) + 1

print(f'\nReferences by decade:')
for decade in sorted(decades.keys(), reverse=True):
    print(f'  {decade}s: {decades[decade]}')

print(f"\n{'─' * 60}")
if invalid_count == 0:
    print('✅ All references valid! File ready for use.')
else:
    print('⚠ Some references need attention.')

exit(1 if invalid_count > 0 else 0)
