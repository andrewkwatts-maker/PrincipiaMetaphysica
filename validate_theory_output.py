#!/usr/bin/env python3
"""
POLISH AGENT 12: Theory Output Validation and Deduplication
Validates theory_output.json for duplications, consistency, and integrity issues.
"""

import json
from collections import defaultdict
from pathlib import Path

def load_theory_output():
    """Load the theory_output.json file."""
    file_path = Path(__file__).parent / 'AutoGenerated' / 'theory_output.json'
    with open(file_path, 'r', encoding='utf-8') as f:
        return json.load(f)

def check_duplicate_parameters(data):
    """Check for duplicate parameter paths."""
    issues = []
    param_paths = {}

    # Parameters are stored as a flat dictionary with dotted keys
    if 'parameters' in data:
        for param_path, param_data in data['parameters'].items():
            if not isinstance(param_data, dict):
                continue

            # Store parameter information
            param_paths[param_path] = {
                'path': param_path,
                'value': param_data.get('value'),
                'values': param_data.get('values'),
                'status': param_data.get('status'),
                'classification': param_data.get('classification'),
                'description': param_data.get('description', ''),
                'formulaRef': param_data.get('formulaRef'),
                'derivedFrom': param_data.get('derivedFrom')
            }

    # Check if the same path appears multiple times (shouldn't happen in flat structure)
    # But we keep this for consistency
    path_counts = defaultdict(int)
    for path in param_paths.keys():
        path_counts[path] += 1

    for path, count in path_counts.items():
        if count > 1:
            issues.append({
                'type': 'DUPLICATE_PARAMETER',
                'path': path,
                'count': count
            })

    return issues, param_paths

def check_value_consistency(param_paths):
    """Check if same parameter has different values in different places."""
    # Since params are flat, no duplicates expected. This is a placeholder.
    # In the future, could check for logical inconsistencies.
    issues = []
    return issues

def check_formula_refs(data):
    """Verify all formulaRef IDs exist in formulas section."""
    issues = []

    # Collect all formula IDs (formulas are stored as flat dict with formula IDs as keys)
    formula_ids = set()
    if 'formulas' in data:
        formula_ids = set(data['formulas'].keys())

    # Check all formulaRef references in parameters
    if 'parameters' in data:
        for param_path, param_data in data['parameters'].items():
            if isinstance(param_data, dict) and 'formulaRef' in param_data:
                ref = param_data['formulaRef']
                if ref and ref not in formula_ids:
                    issues.append({
                        'type': 'MISSING_FORMULA_REF',
                        'location': f'parameters.{param_path}',
                        'missing_id': ref
                    })

    # Also check derivedFrom fields which may contain formula references
    if 'parameters' in data:
        for param_path, param_data in data['parameters'].items():
            if isinstance(param_data, dict) and 'derivedFrom' in param_data:
                derived = param_data['derivedFrom']
                if isinstance(derived, list):
                    for item in derived:
                        if isinstance(item, str) and item in formula_ids:
                            # This is valid
                            pass

    return issues, formula_ids

def check_param_refs(data, param_paths):
    """Verify all paramRef paths exist in parameters section."""
    issues = []

    # Get all valid parameter paths
    valid_paths = set(param_paths.keys())

    # Check input_params and output_params in formulas
    if 'formulas' in data:
        for formula_id, formula_data in data['formulas'].items():
            if not isinstance(formula_data, dict):
                continue

            # Check input_params
            input_params = formula_data.get('input_params', [])
            if isinstance(input_params, list):
                for param_ref in input_params:
                    if param_ref and param_ref not in valid_paths:
                        issues.append({
                            'type': 'MISSING_PARAM_REF',
                            'location': f'formulas.{formula_id}.input_params',
                            'missing_path': param_ref
                        })

            # Check output_params
            output_params = formula_data.get('output_params', [])
            if isinstance(output_params, list):
                for param_ref in output_params:
                    if param_ref and param_ref not in valid_paths:
                        issues.append({
                            'type': 'MISSING_PARAM_REF',
                            'location': f'formulas.{formula_id}.output_params',
                            'missing_path': param_ref
                        })

    # Check derivedFrom in parameters
    if 'parameters' in data:
        for param_path, param_data in data['parameters'].items():
            if isinstance(param_data, dict) and 'derivedFrom' in param_data:
                derived = param_data['derivedFrom']
                if isinstance(derived, list):
                    for item in derived:
                        # derivedFrom can contain both formula IDs and param paths
                        # We only check if they look like param paths (contain dots)
                        if isinstance(item, str) and '.' in item and item not in valid_paths:
                            # Check if it's not a formula ID
                            formula_ids = set(data.get('formulas', {}).keys())
                            if item not in formula_ids:
                                issues.append({
                                    'type': 'MISSING_PARAM_REF',
                                    'location': f'parameters.{param_path}.derivedFrom',
                                    'missing_path': item
                                })

    return issues

def check_status_classification_mismatch(param_paths):
    """Find parameters with 'ESTABLISHED' classification but 'DERIVED' status."""
    issues = []

    for path, param_data in param_paths.items():
        classification = param_data.get('classification')
        status = param_data.get('status')

        if classification == 'ESTABLISHED' and status == 'DERIVED':
            issues.append({
                'type': 'STATUS_CLASSIFICATION_MISMATCH',
                'path': path,
                'classification': classification,
                'status': status
            })

    return issues

def generate_report(all_issues, stats):
    """Generate a validation report."""
    report = []
    report.append("=" * 80)
    report.append("THEORY OUTPUT VALIDATION REPORT")
    report.append("=" * 80)
    report.append("")

    # Summary
    report.append("SUMMARY")
    report.append("-" * 80)
    report.append(f"Total Parameters: {stats['total_params']}")
    report.append(f"Total Formulas: {stats['total_formulas']}")
    report.append(f"Total Issues Found: {stats['total_issues']}")
    report.append("")

    # Issue breakdown
    issue_counts = defaultdict(int)
    for issue in all_issues:
        issue_counts[issue['type']] += 1

    if issue_counts:
        report.append("ISSUE BREAKDOWN")
        report.append("-" * 80)
        for issue_type, count in sorted(issue_counts.items()):
            report.append(f"{issue_type}: {count}")
        report.append("")

    # Detailed issues
    if all_issues:
        report.append("DETAILED ISSUES")
        report.append("=" * 80)
        report.append("")

        # Group by type
        issues_by_type = defaultdict(list)
        for issue in all_issues:
            issues_by_type[issue['type']].append(issue)

        # 1. Duplicate Parameters
        if 'DUPLICATE_PARAMETER' in issues_by_type:
            report.append("1. DUPLICATE PARAMETERS")
            report.append("-" * 80)
            for issue in issues_by_type['DUPLICATE_PARAMETER']:
                report.append(f"\nPath: {issue['path']}")
                report.append(f"Found {issue['count']} times (unexpected in flat structure)")
            report.append("")

        # 2. Inconsistent Values
        if 'INCONSISTENT_VALUES' in issues_by_type:
            report.append("2. INCONSISTENT VALUES")
            report.append("-" * 80)
            for issue in issues_by_type['INCONSISTENT_VALUES']:
                report.append(f"\nPath: {issue['path']}")
                report.append(f"Different values found: {issue['different_values']}")
                for i, occ in enumerate(issue['occurrences'], 1):
                    report.append(f"  {i}. Section: {occ['section']}")
                    report.append(f"     Value: {occ.get('value', occ.get('values'))}")
            report.append("")

        # 3. Missing Formula References
        if 'MISSING_FORMULA_REF' in issues_by_type:
            report.append("3. MISSING FORMULA REFERENCES")
            report.append("-" * 80)
            for issue in issues_by_type['MISSING_FORMULA_REF']:
                report.append(f"\nLocation: {issue['location']}")
                report.append(f"Missing Formula ID: {issue['missing_id']}")
            report.append("")

        # 4. Missing Parameter References
        if 'MISSING_PARAM_REF' in issues_by_type:
            report.append("4. MISSING PARAMETER REFERENCES")
            report.append("-" * 80)
            for issue in issues_by_type['MISSING_PARAM_REF']:
                report.append(f"\nLocation: {issue['location']}")
                report.append(f"Missing Parameter Path: {issue['missing_path']}")
            report.append("")

        # 5. Status/Classification Mismatches
        if 'STATUS_CLASSIFICATION_MISMATCH' in issues_by_type:
            report.append("5. STATUS/CLASSIFICATION MISMATCHES")
            report.append("-" * 80)
            report.append("Parameters marked as ESTABLISHED but with DERIVED status:")
            for issue in issues_by_type['STATUS_CLASSIFICATION_MISMATCH']:
                report.append(f"\n  Path: {issue['path']}")
                report.append(f"  Classification: {issue['classification']}")
                report.append(f"  Status: {issue['status']}")
            report.append("")
    else:
        report.append("NO ISSUES FOUND!")
        report.append("The theory_output.json file is valid and consistent.")
        report.append("")

    report.append("=" * 80)
    report.append("END OF REPORT")
    report.append("=" * 80)

    return "\n".join(report)

def analyze_missing_params(all_issues, data):
    """Analyze missing parameters to provide recommendations."""
    analysis = []

    missing_params = set()
    for issue in all_issues:
        if issue['type'] == 'MISSING_PARAM_REF':
            missing_params.add(issue['missing_path'])

    if missing_params:
        analysis.append("\n" + "=" * 80)
        analysis.append("MISSING PARAMETERS ANALYSIS")
        analysis.append("=" * 80)
        analysis.append(f"\nTotal unique missing parameters: {len(missing_params)}")
        analysis.append("\nMissing parameters by category:")

        # Group by prefix
        categories = defaultdict(list)
        for param in sorted(missing_params):
            prefix = param.split('.')[0] if '.' in param else 'other'
            categories[prefix].append(param)

        for category, params in sorted(categories.items()):
            analysis.append(f"\n{category}: ({len(params)} parameters)")
            for param in params:
                analysis.append(f"  - {param}")

        # Check if any are in parameter_classification
        if 'parameter_classification' in data:
            classified = set()
            for class_type, params in data['parameter_classification'].items():
                if isinstance(params, list):
                    classified.update(params)

            classified_but_missing = missing_params & classified
            if classified_but_missing:
                analysis.append("\n" + "-" * 80)
                analysis.append("PARAMETERS CLASSIFIED BUT NOT DEFINED:")
                analysis.append("(These are listed in parameter_classification but missing from parameters)")
                for param in sorted(classified_but_missing):
                    analysis.append(f"  - {param}")

    return "\n".join(analysis)

def main():
    """Main validation function."""
    print("Loading theory_output.json...")
    data = load_theory_output()

    all_issues = []

    print("Checking for duplicate parameters...")
    duplicate_issues, param_paths = check_duplicate_parameters(data)
    all_issues.extend(duplicate_issues)

    print("Checking for value consistency...")
    consistency_issues = check_value_consistency(param_paths)
    all_issues.extend(consistency_issues)

    print("Checking formula references...")
    formula_ref_issues, formula_ids = check_formula_refs(data)
    all_issues.extend(formula_ref_issues)

    print("Checking parameter references...")
    param_ref_issues = check_param_refs(data, param_paths)
    all_issues.extend(param_ref_issues)

    print("Checking status/classification mismatches...")
    mismatch_issues = check_status_classification_mismatch(param_paths)
    all_issues.extend(mismatch_issues)

    # Calculate stats
    stats = {
        'total_params': len(param_paths),
        'total_formulas': len(formula_ids),
        'total_issues': len(all_issues)
    }

    # Generate report
    print("\nGenerating validation report...")
    report = generate_report(all_issues, stats)

    # Add missing params analysis
    analysis = analyze_missing_params(all_issues, data)
    report += "\n" + analysis

    # Save report
    report_path = Path(__file__).parent / 'THEORY_OUTPUT_VALIDATION_REPORT.md'
    with open(report_path, 'w', encoding='utf-8') as f:
        f.write(report)

    print(f"\nReport saved to: {report_path}")
    print(f"\nTotal issues found: {stats['total_issues']}")

    # Print summary to console
    print("\n" + "=" * 80)
    print("VALIDATION SUMMARY")
    print("=" * 80)
    print(f"Total Parameters: {stats['total_params']}")
    print(f"Total Formulas: {stats['total_formulas']}")
    print(f"Total Issues: {stats['total_issues']}")

    if all_issues:
        print("\nIssues by type:")
        issue_counts = defaultdict(int)
        for issue in all_issues:
            issue_counts[issue['type']] += 1
        for issue_type, count in sorted(issue_counts.items()):
            print(f"  - {issue_type}: {count}")
    else:
        print("\nNo issues found! Theory output is valid.")

    return all_issues

if __name__ == '__main__':
    main()
