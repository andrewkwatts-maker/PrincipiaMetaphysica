"""
Global Validator for Principia Metaphysica Simulation Outputs
==============================================================

Automatically validates ALL PM simulation outputs against experimental constraints
from multiple authoritative sources:
- NuFIT 6.0 (2025) for neutrino parameters
- DESI DR2 (2025) for dark energy w0, wa
- Planck 2025 for Omega_m, H0, sum_m_nu
- Super-K for proton decay bounds
- PDG/LHC for particle masses (Higgs, top, etc.)

Handles conflicts between datasets and provides comprehensive validation reporting.

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
"""

import json
import sys
import os
from pathlib import Path
from typing import Dict, Any, List, Tuple, Optional
from dataclasses import dataclass, field
from datetime import datetime
import math


@dataclass
class ExperimentalConstraint:
    """Represents an experimental constraint with uncertainties."""
    parameter_path: str
    central_value: float
    uncertainty: float
    units: str
    source: str
    bound_type: str = "measured"  # measured, upper, lower
    notes: str = ""


@dataclass
class ValidationStatus:
    """Status of a parameter validation."""
    parameter_path: str
    computed_value: float
    experimental_value: float
    experimental_uncertainty: float
    sigma_deviation: float
    status: str  # PASS, TENSION, WARNING, FAIL
    source: str
    geometric_derivation: str = ""
    notes: str = ""


@dataclass
class ValidationReport:
    """Complete validation report."""
    timestamp: str
    theory_version: str
    overall_status: str
    total_chi_squared: float
    n_parameters: int
    n_pass: int = 0
    n_tension: int = 0
    n_warning: int = 0
    n_fail: int = 0
    parameter_validations: List[ValidationStatus] = field(default_factory=list)
    geometric_inconsistencies: List[str] = field(default_factory=list)
    dataset_conflicts: List[str] = field(default_factory=list)
    recommended_fixes: List[str] = field(default_factory=list)


class GlobalValidator:
    """
    Comprehensive validator for all PM simulation outputs.

    Validates computed parameters against experimental constraints from:
    - NuFIT 6.0 (2025)
    - DESI DR2 (2025)
    - Planck 2025
    - Super-K
    - PDG/LHC
    """

    def __init__(self, theory_output_path: Optional[str] = None):
        """
        Initialize the global validator.

        Args:
            theory_output_path: Path to theory_output.json (default: AutoGenerated/theory_output.json)
        """
        if theory_output_path is None:
            # Default path relative to this script
            base_dir = Path(__file__).parent.parent
            theory_output_path = base_dir / "AutoGenerated" / "theory_output.json"

        self.theory_output_path = Path(theory_output_path)
        self.theory_data: Dict[str, Any] = {}
        self.constraints: List[ExperimentalConstraint] = []

        # Initialize experimental constraints
        self._init_experimental_constraints()

    def _init_experimental_constraints(self) -> None:
        """Initialize all experimental constraints from authoritative sources."""

        # NuFIT 6.0 (2025) - Neutrino oscillation parameters
        self.constraints.extend([
            ExperimentalConstraint(
                parameter_path="nufit.theta_12",
                central_value=33.41,
                uncertainty=0.75,
                units="degrees",
                source="NuFIT 6.0 (2025)",
                notes="Solar mixing angle (3-sigma range: 31.27-35.86)"
            ),
            ExperimentalConstraint(
                parameter_path="nufit.theta_23",
                central_value=45.0,
                uncertainty=1.0,
                units="degrees",
                source="NuFIT 6.0 (2025)",
                notes="Atmospheric mixing angle (3-sigma range: 41.8-50.7)"
            ),
            ExperimentalConstraint(
                parameter_path="nufit.theta_13",
                central_value=8.54,
                uncertainty=0.12,
                units="degrees",
                source="NuFIT 6.0 (2025)",
                notes="Reactor mixing angle (3-sigma range: 8.20-8.91)"
            ),
            ExperimentalConstraint(
                parameter_path="nufit.delta_CP",
                central_value=194.0,
                uncertainty=25.0,
                units="degrees",
                source="NuFIT 6.0 (2025)",
                notes="CP-violating phase (3-sigma range: 120-360)"
            ),
            ExperimentalConstraint(
                parameter_path="nufit.delta_m21_sq",
                central_value=7.42e-5,
                uncertainty=0.21e-5,
                units="eV^2",
                source="NuFIT 6.0 (2025)",
                notes="Solar mass splitting (3-sigma range: 6.82-8.04 x10^-5)"
            ),
            ExperimentalConstraint(
                parameter_path="nufit.delta_m31_sq",
                central_value=2.515e-3,
                uncertainty=0.028e-3,
                units="eV^2",
                source="NuFIT 6.0 (2025)",
                notes="Atmospheric mass splitting (3-sigma range: 2.431-2.598 x10^-3)"
            ),
        ])

        # DESI DR2 (2025) - Dark energy parameters
        self.constraints.extend([
            ExperimentalConstraint(
                parameter_path="desi.w0",
                central_value=-0.827,
                uncertainty=0.063,
                units="dimensionless",
                source="DESI DR2 (2025)",
                notes="Dark energy EOS at z=0 (prefers dynamic DE over LambdaCDM)"
            ),
            ExperimentalConstraint(
                parameter_path="desi.wa",
                central_value=-0.75,
                uncertainty=0.30,
                units="dimensionless",
                source="DESI DR2 (2025)",
                notes="Dark energy evolution parameter"
            ),
        ])

        # Planck 2025 - Cosmological parameters
        self.constraints.extend([
            ExperimentalConstraint(
                parameter_path="desi.H0",
                central_value=67.4,
                uncertainty=0.5,
                units="km/s/Mpc",
                source="Planck 2025",
                notes="Hubble constant (CMB-based, in tension with local measurements ~73)"
            ),
            ExperimentalConstraint(
                parameter_path="desi.Omega_m",
                central_value=0.3111,
                uncertainty=0.0056,
                units="dimensionless",
                source="Planck 2025",
                notes="Matter density parameter"
            ),
            ExperimentalConstraint(
                parameter_path="bounds.sum_m_nu_upper",
                central_value=0.12,
                uncertainty=0.0,
                units="eV",
                source="Planck 2025 + BAO",
                bound_type="upper",
                notes="Upper bound on sum of neutrino masses (95% CL)"
            ),
        ])

        # Super-K - Proton decay
        self.constraints.append(
            ExperimentalConstraint(
                parameter_path="bounds.tau_proton_lower",
                central_value=1.67e34,
                uncertainty=0.03e34,
                units="years",
                source="Super-Kamiokande 2024",
                bound_type="lower",
                notes="Lower bound on p->e+ pi0 lifetime (90% CL)"
            )
        )

        # PDG/LHC - Particle masses
        self.constraints.extend([
            ExperimentalConstraint(
                parameter_path="pdg.m_higgs",
                central_value=125.10,
                uncertainty=0.14,
                units="GeV",
                source="PDG 2024 / LHC",
                notes="Higgs boson mass (combined ATLAS+CMS)"
            ),
            ExperimentalConstraint(
                parameter_path="pdg.m_top",
                central_value=172.76,
                uncertainty=0.30,
                units="GeV",
                source="PDG 2024 / LHC",
                notes="Top quark pole mass"
            ),
            ExperimentalConstraint(
                parameter_path="pdg.m_W",
                central_value=80.377,
                uncertainty=0.012,
                units="GeV",
                source="PDG 2024",
                notes="W boson mass"
            ),
            ExperimentalConstraint(
                parameter_path="pdg.m_Z",
                central_value=91.1876,
                uncertainty=0.0021,
                units="GeV",
                source="PDG 2024",
                notes="Z boson mass"
            ),
            ExperimentalConstraint(
                parameter_path="pdg.alpha_s_MZ",
                central_value=0.1180,
                uncertainty=0.0009,
                units="dimensionless",
                source="PDG 2024",
                notes="Strong coupling at M_Z"
            ),
        ])

        # Add predicted parameters (these should align with experiments)
        self.constraints.extend([
            ExperimentalConstraint(
                parameter_path="neutrino.theta_12_pred",
                central_value=33.41,
                uncertainty=0.75,
                units="degrees",
                source="NuFIT 6.0 (target)",
                notes="PM prediction should match NuFIT"
            ),
            ExperimentalConstraint(
                parameter_path="neutrino.theta_23_pred",
                central_value=45.0,
                uncertainty=1.0,
                units="degrees",
                source="NuFIT 6.0 (target)",
                notes="PM prediction should match NuFIT"
            ),
            ExperimentalConstraint(
                parameter_path="neutrino.theta_13_pred",
                central_value=8.54,
                uncertainty=0.12,
                units="degrees",
                source="NuFIT 6.0 (target)",
                notes="PM prediction should match NuFIT"
            ),
        ])

    def load_theory_output(self) -> bool:
        """
        Load theory_output.json.

        Returns:
            True if successful, False otherwise
        """
        try:
            with open(self.theory_output_path, 'r', encoding='utf-8') as f:
                self.theory_data = json.load(f)
            print(f"[OK] Loaded theory output from: {self.theory_output_path}")
            print(f"  Version: {self.theory_data.get('metadata', {}).get('version', 'unknown')}")
            print(f"  Parameters: {len(self.theory_data.get('parameters', {}))}")
            return True
        except FileNotFoundError:
            print(f"[ERROR] File not found: {self.theory_output_path}")
            return False
        except json.JSONDecodeError as e:
            print(f"[ERROR] Invalid JSON: {e}")
            return False
        except Exception as e:
            print(f"[ERROR] Failed to load theory output: {e}")
            return False

    def validate_all(self) -> ValidationReport:
        """
        Validate all parameters against experimental constraints.

        Returns:
            ValidationReport with detailed results
        """
        if not self.theory_data:
            raise ValueError("Theory data not loaded. Call load_theory_output() first.")

        report = ValidationReport(
            timestamp=datetime.now().isoformat(),
            theory_version=self.theory_data.get('metadata', {}).get('version', 'unknown'),
            overall_status="UNKNOWN",
            total_chi_squared=0.0,
            n_parameters=0
        )

        parameters = self.theory_data.get('parameters', {})

        # Validate each constraint
        chi_squared_sum = 0.0
        n_valid = 0

        for constraint in self.constraints:
            param_path = constraint.parameter_path

            # Check if parameter exists in theory output
            if param_path not in parameters:
                # Check alternative paths (e.g., derived predictions)
                alt_paths = self._get_alternative_paths(param_path)
                found = False
                for alt_path in alt_paths:
                    if alt_path in parameters:
                        param_path = alt_path
                        found = True
                        break

                if not found:
                    report.geometric_inconsistencies.append(
                        f"Missing parameter: {constraint.parameter_path} (source: {constraint.source})"
                    )
                    continue

            param_data = parameters[param_path]
            computed_value = param_data.get('value')

            if computed_value is None or not isinstance(computed_value, (int, float)):
                report.geometric_inconsistencies.append(
                    f"Invalid value for {param_path}: {computed_value}"
                )
                continue

            # Calculate sigma deviation
            if constraint.uncertainty > 0:
                sigma = abs(computed_value - constraint.central_value) / constraint.uncertainty
            else:
                # For bounds without uncertainty
                if constraint.bound_type == "upper":
                    sigma = max(0, computed_value - constraint.central_value) / (0.01 * constraint.central_value)
                elif constraint.bound_type == "lower":
                    sigma = max(0, constraint.central_value - computed_value) / (0.01 * constraint.central_value)
                else:
                    sigma = 0.0

            # Determine status
            if sigma < 1.0:
                status = "PASS"
                report.n_pass += 1
            elif sigma < 2.0:
                status = "TENSION"
                report.n_tension += 1
            elif sigma < 3.0:
                status = "WARNING"
                report.n_warning += 1
            else:
                status = "FAIL"
                report.n_fail += 1

            # Get geometric derivation info
            geometric_derivation = param_data.get('source', '')
            if 'source_simulation' in param_data:
                geometric_derivation = param_data['source_simulation']

            # Create validation status
            validation = ValidationStatus(
                parameter_path=param_path,
                computed_value=computed_value,
                experimental_value=constraint.central_value,
                experimental_uncertainty=constraint.uncertainty,
                sigma_deviation=sigma,
                status=status,
                source=constraint.source,
                geometric_derivation=geometric_derivation,
                notes=constraint.notes
            )

            report.parameter_validations.append(validation)

            # Accumulate chi-squared
            if constraint.uncertainty > 0:
                chi_squared_sum += sigma ** 2
                n_valid += 1

        # Calculate overall chi-squared
        report.total_chi_squared = chi_squared_sum
        report.n_parameters = len(report.parameter_validations)

        # Determine overall status
        if report.n_fail > 0:
            report.overall_status = "FAIL"
        elif report.n_warning > 0:
            report.overall_status = "WARNING"
        elif report.n_tension > 0:
            report.overall_status = "TENSION"
        else:
            report.overall_status = "PASS"

        # Analyze dataset conflicts
        self._analyze_conflicts(report)

        # Generate recommended fixes
        self._generate_recommendations(report)

        return report

    def _get_alternative_paths(self, param_path: str) -> List[str]:
        """Get alternative parameter paths to check."""
        alternatives = []

        # Map established to predicted
        if param_path.startswith("nufit."):
            pred_path = param_path.replace("nufit.", "neutrino.") + "_pred"
            alternatives.append(pred_path)

        # Map predicted to established
        if "_pred" in param_path:
            est_path = param_path.replace("_pred", "").replace("neutrino.", "nufit.")
            alternatives.append(est_path)

        return alternatives

    def _analyze_conflicts(self, report: ValidationReport) -> None:
        """Analyze conflicts between different experimental datasets."""

        # Check Hubble tension
        h0_validations = [v for v in report.parameter_validations if "H0" in v.parameter_path]
        for v in h0_validations:
            if v.computed_value > 70.0:
                report.dataset_conflicts.append(
                    f"Hubble tension detected: H0={v.computed_value:.2f} ± ? km/s/Mpc "
                    f"aligns with local measurements (~73) but conflicts with Planck CMB ({v.experimental_value:.2f})"
                )
            elif v.sigma_deviation < 1.0:
                report.dataset_conflicts.append(
                    f"H0={v.computed_value:.2f} aligns with Planck/CMB "
                    f"({v.experimental_value:.2f} ± {v.experimental_uncertainty:.2f}), "
                    f"but conflicts with local measurements (~73 km/s/Mpc)"
                )

        # Check neutrino mass sum vs individual measurements
        sum_nu = [v for v in report.parameter_validations if "sum_m_nu" in v.parameter_path]
        if sum_nu:
            for v in sum_nu:
                if v.status == "FAIL":
                    report.dataset_conflicts.append(
                        f"Sum of neutrino masses ({v.computed_value:.4f} eV) exceeds "
                        f"Planck+BAO bound ({v.experimental_value:.2f} eV) (95% CL)"
                    )

        # Check dark energy tensions
        w0_vals = [v for v in report.parameter_validations if v.parameter_path.endswith("w0")]
        for v in w0_vals:
            if abs(v.computed_value - (-1.0)) < 0.05:
                report.dataset_conflicts.append(
                    f"Dark energy w0={v.computed_value:.3f} close to LambdaCDM (w=-1.0), "
                    f"but DESI DR2 prefers dynamic DE (w0={v.experimental_value:.3f})"
                )

    def _generate_recommendations(self, report: ValidationReport) -> None:
        """Generate recommended fixes based on validation results."""

        # Group failures by category
        neutrino_fails = [v for v in report.parameter_validations if "neutrino" in v.parameter_path or "theta" in v.parameter_path and v.status in ["WARNING", "FAIL"]]
        cosmo_fails = [v for v in report.parameter_validations if any(x in v.parameter_path for x in ["w0", "wa", "H0", "Omega"]) and v.status in ["WARNING", "FAIL"]]
        particle_fails = [v for v in report.parameter_validations if any(x in v.parameter_path for x in ["m_higgs", "m_top", "m_W", "m_Z", "alpha_s"]) and v.status in ["WARNING", "FAIL"]]

        if neutrino_fails:
            report.recommended_fixes.append(
                f"Neutrino sector: {len(neutrino_fails)} parameter(s) show >1-sigma deviation. "
                f"Review geometric derivation in neutrino_mixing_v16_0.py or neutrino_seesaw_solver.py"
            )

        if cosmo_fails:
            report.recommended_fixes.append(
                f"Cosmology sector: {len(cosmo_fails)} parameter(s) show >1-sigma deviation. "
                f"Review dark_energy_v16_0.py and moduli stabilization parameters"
            )

        if particle_fails:
            report.recommended_fixes.append(
                f"Particle masses: {len(particle_fails)} parameter(s) show >1-sigma deviation. "
                f"Review gauge_unification_v16_0.py and RG running"
            )

        # Check for geometric inconsistencies
        if report.geometric_inconsistencies:
            report.recommended_fixes.append(
                f"Geometric inconsistencies found: {len(report.geometric_inconsistencies)} issue(s). "
                f"Ensure all required simulations have been run"
            )

        # Overall recommendations
        if report.overall_status == "PASS":
            report.recommended_fixes.append(
                "All parameters within 1-sigma of experimental values. Theory predictions validated!"
            )
        elif report.overall_status == "TENSION":
            report.recommended_fixes.append(
                "Some parameters show 1-2-sigma tension. Review geometric assumptions and RG evolution"
            )
        elif report.overall_status == "WARNING":
            report.recommended_fixes.append(
                "Some parameters show 2-3-sigma deviation. Significant review needed of derivation chain"
            )
        else:  # FAIL
            report.recommended_fixes.append(
                "Multiple parameters fail >3-sigma. Critical review required of fundamental geometric assumptions"
            )

    def print_summary(self, report: ValidationReport) -> None:
        """Print human-readable summary of validation results."""

        print("\n" + "=" * 80)
        print("PRINCIPIA METAPHYSICA - GLOBAL VALIDATION REPORT")
        print("=" * 80)
        print(f"\nTimestamp: {report.timestamp}")
        print(f"Theory Version: {report.theory_version}")
        print(f"Overall Status: {report.overall_status}")
        print(f"\nSummary:")
        print(f"  Total Parameters Validated: {report.n_parameters}")
        print(f"  PASS (<1-sigma):     {report.n_pass:3d}  ({100*report.n_pass/max(1,report.n_parameters):.1f}%)")
        print(f"  TENSION (1-2-sigma): {report.n_tension:3d}  ({100*report.n_tension/max(1,report.n_parameters):.1f}%)")
        print(f"  WARNING (2-3-sigma): {report.n_warning:3d}  ({100*report.n_warning/max(1,report.n_parameters):.1f}%)")
        print(f"  FAIL (>3-sigma):     {report.n_fail:3d}  ({100*report.n_fail/max(1,report.n_parameters):.1f}%)")
        print(f"\nTotal chi-squared: {report.total_chi_squared:.2f}")
        if report.n_parameters > 0:
            print(f"Reduced chi-squared: {report.total_chi_squared / report.n_parameters:.2f}")

        # Print parameter-by-parameter results
        print("\n" + "-" * 80)
        print("DETAILED PARAMETER VALIDATION")
        print("-" * 80)

        # Group by status
        for status in ["FAIL", "WARNING", "TENSION", "PASS"]:
            validations = [v for v in report.parameter_validations if v.status == status]
            if not validations:
                continue

            print(f"\n{status} ({len(validations)} parameters):")
            print("-" * 80)

            for v in validations:
                print(f"\n  {v.parameter_path}")
                print(f"    Computed:     {v.computed_value:.6g} {self._get_units(v.parameter_path)}")
                print(f"    Experimental: {v.experimental_value:.6g} +/- {v.experimental_uncertainty:.6g}")
                print(f"    Deviation:    {v.sigma_deviation:.2f}-sigma")
                print(f"    Source:       {v.source}")
                if v.geometric_derivation:
                    print(f"    Derivation:   {v.geometric_derivation}")
                if v.notes:
                    print(f"    Notes:        {v.notes}")

        # Print dataset conflicts
        if report.dataset_conflicts:
            print("\n" + "-" * 80)
            print("DATASET CONFLICTS")
            print("-" * 80)
            for conflict in report.dataset_conflicts:
                print(f"\n  * {conflict}")

        # Print geometric inconsistencies
        if report.geometric_inconsistencies:
            print("\n" + "-" * 80)
            print("GEOMETRIC INCONSISTENCIES")
            print("-" * 80)
            for issue in report.geometric_inconsistencies:
                print(f"\n  * {issue}")

        # Print recommendations
        if report.recommended_fixes:
            print("\n" + "-" * 80)
            print("RECOMMENDED FIXES")
            print("-" * 80)
            for i, fix in enumerate(report.recommended_fixes, 1):
                print(f"\n  {i}. {fix}")

        print("\n" + "=" * 80)

    def _get_units(self, param_path: str) -> str:
        """Get units for a parameter from constraints."""
        for constraint in self.constraints:
            if constraint.parameter_path == param_path:
                return constraint.units

        # Fallback: try to get from theory data
        if self.theory_data:
            params = self.theory_data.get('parameters', {})
            if param_path in params:
                metadata = params[param_path].get('metadata', {})
                return metadata.get('units', '')

        return ''

    def save_report(self, report: ValidationReport, output_path: Optional[str] = None) -> None:
        """
        Save validation report to JSON file.

        Args:
            report: ValidationReport to save
            output_path: Output file path (default: validation_report.json)
        """
        if output_path is None:
            output_path = Path(__file__).parent / "validation_report.json"

        # Convert report to dict
        report_dict = {
            "timestamp": report.timestamp,
            "theory_version": report.theory_version,
            "overall_status": report.overall_status,
            "total_chi_squared": report.total_chi_squared,
            "n_parameters": report.n_parameters,
            "summary": {
                "n_pass": report.n_pass,
                "n_tension": report.n_tension,
                "n_warning": report.n_warning,
                "n_fail": report.n_fail
            },
            "parameter_validations": [
                {
                    "parameter_path": v.parameter_path,
                    "computed_value": v.computed_value,
                    "experimental_value": v.experimental_value,
                    "experimental_uncertainty": v.experimental_uncertainty,
                    "sigma_deviation": v.sigma_deviation,
                    "status": v.status,
                    "source": v.source,
                    "geometric_derivation": v.geometric_derivation,
                    "notes": v.notes
                }
                for v in report.parameter_validations
            ],
            "geometric_inconsistencies": report.geometric_inconsistencies,
            "dataset_conflicts": report.dataset_conflicts,
            "recommended_fixes": report.recommended_fixes
        }

        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(report_dict, f, indent=2)

        print(f"\n[OK] Validation report saved to: {output_path}")


def main():
    """Main entry point for command-line usage."""
    print("Principia Metaphysica - Global Validator")
    print("=" * 80)

    # Parse command-line arguments
    theory_output_path = None
    save_json = False

    if len(sys.argv) > 1:
        for arg in sys.argv[1:]:
            if arg.endswith('.json') and 'theory_output' in arg:
                theory_output_path = arg
            elif arg == '--save' or arg == '-s':
                save_json = True
            elif arg == '--help' or arg == '-h':
                print("\nUsage: python global_validator.py [options]")
                print("\nOptions:")
                print("  --save, -s              Save validation report to JSON")
                print("  <path/to/theory_output.json>  Use custom theory output file")
                print("  --help, -h              Show this help message")
                print("\nDefault: Validates AutoGenerated/theory_output.json")
                return

    # Create validator
    try:
        validator = GlobalValidator(theory_output_path)
    except Exception as e:
        print(f"\n[ERROR] Failed to initialize validator: {e}")
        return 1

    # Load theory output
    if not validator.load_theory_output():
        return 1

    print("\nRunning validation against experimental constraints...")
    print("  - NuFIT 6.0 (2025)")
    print("  - DESI DR2 (2025)")
    print("  - Planck 2025")
    print("  - Super-Kamiokande 2024")
    print("  - PDG 2024 / LHC")
    print()

    # Run validation
    try:
        report = validator.validate_all()
    except Exception as e:
        print(f"\n[ERROR] Validation failed: {e}")
        import traceback
        traceback.print_exc()
        return 1

    # Print summary
    validator.print_summary(report)

    # Save report if requested
    if save_json:
        try:
            validator.save_report(report)
        except Exception as e:
            print(f"\n[WARNING] Failed to save report: {e}")

    # Return exit code based on overall status
    if report.overall_status == "PASS":
        return 0
    elif report.overall_status == "TENSION":
        return 0  # Still acceptable
    elif report.overall_status == "WARNING":
        return 1
    else:  # FAIL
        return 2


if __name__ == "__main__":
    sys.exit(main())
