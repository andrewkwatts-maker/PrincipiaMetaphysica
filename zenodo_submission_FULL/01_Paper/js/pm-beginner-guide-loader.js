/**
 * PM Beginner Guide Loader
 * =========================
 *
 * Loads beginner-friendly content from AutoGenerated/beginner-guide.json.
 * Renders concept cards with simple explanations, analogies, and expandable technical details.
 *
 * Usage:
 *   await PMBeginnerGuideLoader.load();
 *   PMBeginnerGuideLoader.renderAll('#beginner-concepts-container');
 *
 *   // Get specific concept
 *   const concept = PMBeginnerGuideLoader.getConcept('pneuma-field');
 *
 *   // Get predictions
 *   const predictions = PMBeginnerGuideLoader.getPredictions();
 *
 * Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
 */

class PMBeginnerGuideLoader {
    static _data = null;
    static _loaded = false;
    static _loading = null;

    // Cache configuration
    static CACHE_KEY = 'pm_beginner_guide_cache';
    static CACHE_VERSION = '16.2';
    static CACHE_TTL = 3600000; // 1 hour in ms

    /**
     * Get cached beginner guide data from localStorage
     */
    static _getCached() {
        try {
            const cached = localStorage.getItem(this.CACHE_KEY);
            if (!cached) return null;

            const { data, timestamp, version } = JSON.parse(cached);
            if (version !== this.CACHE_VERSION) return null;
            if (Date.now() - timestamp > this.CACHE_TTL) return null;

            return data;
        } catch (e) {
            return null;
        }
    }

    /**
     * Cache beginner guide data to localStorage
     */
    static _setCache(data) {
        try {
            localStorage.setItem(this.CACHE_KEY, JSON.stringify({
                data,
                timestamp: Date.now(),
                version: this.CACHE_VERSION
            }));
        } catch (e) {
            console.warn('[PMBeginnerGuideLoader] Could not cache:', e.message);
        }
    }

    /**
     * Load beginner guide data from AutoGenerated/beginner-guide.json
     * @returns {Promise<boolean>} - True if loaded successfully
     */
    static async load() {
        if (this._loaded) return true;
        if (this._loading) return this._loading;

        this._loading = (async () => {
            // Check cache first
            const cached = this._getCached();
            if (cached) {
                this._data = cached;
                this._loaded = true;
                console.log('[PMBeginnerGuideLoader] Loaded from cache');
                return true;
            }

            // Determine base path based on current location
            const loc = window.location.pathname;
            let basePath = 'AutoGenerated/';
            if (loc.includes('/foundations/') || loc.includes('/sections/') ||
                loc.includes('/docs/') || loc.includes('/diagrams/')) {
                basePath = '../AutoGenerated/';
            }

            // Try multiple paths
            const paths = [
                `${basePath}beginner-guide.json`,
                'AutoGenerated/beginner-guide.json',
                '../AutoGenerated/beginner-guide.json',
                '../../AutoGenerated/beginner-guide.json'
            ];

            for (const path of paths) {
                try {
                    const response = await fetch(path);
                    if (response.ok) {
                        const data = await response.json();
                        this._data = data;
                        this._loaded = true;
                        this._setCache(data);

                        console.log(`%c[PMBeginnerGuideLoader] Loaded from ${path}`, 'color: green; font-weight: bold');
                        console.log(`  Concepts: ${data.concepts?.length || 0}`);
                        console.log(`  Predictions: ${data.predictions?.length || 0}`);

                        window.PM_BEGINNER_GUIDE = this._data;
                        return true;
                    }
                } catch (e) {
                    continue;
                }
            }

            console.error('%c[PMBeginnerGuideLoader] Failed to load beginner-guide.json!', 'color: red; font-weight: bold');
            console.error('  Expected location: AutoGenerated/beginner-guide.json');
            return false;
        })();

        return this._loading;
    }

    /**
     * Get a concept by ID
     * @param {string} id - Concept ID
     * @returns {Object|null} - Concept object or null
     */
    static getConcept(id) {
        if (!this._data || !this._data.concepts) return null;
        return this._data.concepts.find(c => c.id === id) || null;
    }

    /**
     * Get all concepts
     * @returns {Array} - Array of concept objects
     */
    static getConcepts() {
        return this._data?.concepts || [];
    }

    /**
     * Get all predictions
     * @returns {Array} - Array of prediction objects
     */
    static getPredictions() {
        return this._data?.predictions || [];
    }

    /**
     * Get concepts by section
     * @param {string} section - Section number (e.g., "2", "4")
     * @returns {Array} - Array of concepts in that section
     */
    static getConceptsBySection(section) {
        if (!this._data || !this._data.concepts) return [];
        return this._data.concepts.filter(c => c.section === section);
    }

    /**
     * Search concepts by title or content
     * @param {string} query - Search query
     * @returns {Array} - Matching concepts
     */
    static search(query) {
        if (!this._data || !this._data.concepts) return [];
        const q = query.toLowerCase();
        return this._data.concepts.filter(c =>
            (c.title && c.title.toLowerCase().includes(q)) ||
            (c.simpleExplanation && c.simpleExplanation.toLowerCase().includes(q)) ||
            (c.keyTakeaway && c.keyTakeaway.toLowerCase().includes(q))
        );
    }

    /**
     * Render all beginner guide content into a container
     * @param {string} containerSelector - CSS selector for container element
     */
    static async renderAll(containerSelector) {
        if (!this._loaded) {
            await this.load();
        }

        if (!this._data) {
            console.error('[PMBeginnerGuideLoader] No data loaded');
            return;
        }

        const container = document.querySelector(containerSelector);
        if (!container) {
            console.error(`[PMBeginnerGuideLoader] Container not found: ${containerSelector}`);
            return;
        }

        // Clear container
        container.innerHTML = '';

        // Render predictions first (evidence section)
        if (this._data.predictions && this._data.predictions.length > 0) {
            const evidenceCard = this.createEvidenceCard(this._data.predictions);
            container.appendChild(evidenceCard);
        }

        // Render concept cards
        if (this._data.concepts && this._data.concepts.length > 0) {
            this._data.concepts.forEach(concept => {
                container.appendChild(this.createConceptCard(concept));
            });
        }

        // Trigger MathJax if available
        this._triggerMathJax(container);

        console.log(`[PMBeginnerGuideLoader] Rendered ${this._data.concepts?.length || 0} concepts`);
    }

    /**
     * Create evidence/predictions card
     * @param {Array} predictions - Array of prediction objects
     * @returns {HTMLElement} - Evidence card element
     */
    static createEvidenceCard(predictions) {
        const card = document.createElement('div');
        card.className = 'concept-card evidence-card';
        card.setAttribute('data-card-type', 'evidence');

        const predictionsHTML = predictions.map(p => this.createPredictionBox(p)).join('');

        card.innerHTML = `
            <h2><span class="icon">üéØ</span> Why Should You Take This Theory Seriously?</h2>
            <p class="simple-explanation">
                Before explaining <em>how</em> this theory works, here's <em>why</em> it deserves your attention:
                <strong>It makes specific, testable predictions that can be proven right or wrong.</strong>
            </p>
            <div class="predictions-grid">
                ${predictionsHTML}
            </div>
        `;

        return card;
    }

    /**
     * Create a concept card from concept data
     * @param {Object} concept - Concept object from beginner-guide.json
     * @returns {HTMLElement} - Concept card element
     */
    static createConceptCard(concept) {
        const card = document.createElement('div');
        card.className = 'concept-card';
        card.setAttribute('data-concept-id', concept.id || concept.concept);
        if (concept.source) {
            card.setAttribute('data-source', concept.source);
        }
        if (concept.section) {
            card.setAttribute('data-section', concept.section);
        }

        let cardHTML = `
            <h2>
                <span class="icon">${concept.icon || 'üî¨'}</span>
                ${concept.title}
            </h2>
            <p class="simple-explanation">${concept.simpleExplanation}</p>
        `;

        // Add analogy box if present
        if (concept.analogy) {
            cardHTML += this.createAnalogyBox(concept.analogy);
        }

        // Add key takeaway if present
        if (concept.keyTakeaway) {
            cardHTML += `
                <div class="key-takeaway-box">
                    <strong>üí° Key Takeaway:</strong> ${concept.keyTakeaway}
                </div>
            `;
        }

        // Add expandable technical detail if present
        if (concept.technicalDetail) {
            cardHTML += this.createExpandable('The Technical Details', concept.technicalDetail, concept.relatedFormulas);
        }

        // Add prediction box if present
        if (concept.prediction) {
            cardHTML += this.createPredictionBox(concept.prediction);
        }

        // Add related content links if present
        if (concept.relatedFormulas || concept.relatedParams) {
            cardHTML += this.createRelatedLinks(concept.relatedFormulas, concept.relatedParams);
        }

        card.innerHTML = cardHTML;
        return card;
    }

    /**
     * Create an analogy box
     * @param {Object} analogy - Analogy object
     * @returns {string} - HTML string for analogy box
     */
    static createAnalogyBox(analogy) {
        if (typeof analogy === 'string') {
            return `
                <div class="analogy-box">
                    <h4>üí° Analogy:</h4>
                    <p>${analogy}</p>
                </div>
            `;
        }

        return `
            <div class="analogy-box">
                <h4>üí° ${analogy.title || 'Analogy'}</h4>
                <p>${analogy.description || analogy.content || ''}</p>
                ${analogy.items ? `
                    <ul>
                        ${analogy.items.map(item => `<li>${item}</li>`).join('')}
                    </ul>
                ` : ''}
            </div>
        `;
    }

    /**
     * Create an expandable section for technical details
     * @param {string} title - Section title
     * @param {string} content - Section content
     * @param {Array} relatedFormulas - Optional related formula IDs
     * @returns {string} - HTML string for expandable section
     */
    static createExpandable(title, content, relatedFormulas = []) {
        return `
            <div class="expandable">
                <div class="expand-header" onclick="this.parentElement.classList.toggle('expanded')">
                    <h4>üî¨ Dig Deeper: ${title}</h4>
                    <span class="expand-arrow">‚ñº</span>
                </div>
                <div class="expand-content">
                    <p>${content}</p>
                    ${relatedFormulas && relatedFormulas.length > 0 ? `
                        <div class="related-formulas">
                            <strong>Related Formulas:</strong>
                            ${relatedFormulas.map(fid => `
                                <a href="formulas.html#formula-${fid}" class="formula-link">${fid}</a>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    }

    /**
     * Create a prediction box
     * @param {Object} prediction - Prediction object
     * @returns {string} - HTML string for prediction box
     */
    static createPredictionBox(prediction) {
        const statusClass = this._getPredictionStatusClass(prediction);
        const statusIcon = this._getPredictionStatusIcon(prediction);

        return `
            <div class="prediction-box ${statusClass}" data-prediction-id="${prediction.id || prediction.observable}">
                <div class="prediction-header">
                    <span class="prediction-icon">${statusIcon}</span>
                    <h4>${prediction.observable || prediction.title}</h4>
                </div>
                <div class="prediction-values">
                    <div class="prediction-value">
                        <span class="label">PM Predicts:</span>
                        <span class="value">${prediction.predicted}</span>
                    </div>
                    ${prediction.experimental ? `
                        <div class="prediction-value">
                            <span class="label">Experiment:</span>
                            <span class="value">${prediction.experimental}</span>
                        </div>
                    ` : `
                        <div class="prediction-value testable">
                            <span class="label">Status:</span>
                            <span class="value">${prediction.status || 'Testable'}</span>
                        </div>
                    `}
                </div>
                ${prediction.agreement ? `
                    <div class="prediction-agreement">
                        Agreement: <strong>${prediction.agreement}</strong>
                    </div>
                ` : ''}
            </div>
        `;
    }

    /**
     * Get CSS class for prediction status
     */
    static _getPredictionStatusClass(prediction) {
        if (prediction.status === 'exact_match' || prediction.agreement === '1œÉ' || prediction.agreement === '<1œÉ') {
            return 'exact-match';
        }
        if (prediction.experimental) {
            return 'measured';
        }
        return 'testable';
    }

    /**
     * Get icon for prediction status
     */
    static _getPredictionStatusIcon(prediction) {
        if (prediction.status === 'exact_match' || prediction.agreement === '1œÉ' || prediction.agreement === '<1œÉ') {
            return '‚úì';
        }
        if (prediction.experimental) {
            return 'üìä';
        }
        return 'üîÆ';
    }

    /**
     * Create related links section
     * @param {Array} relatedFormulas - Formula IDs
     * @param {Array} relatedParams - Parameter IDs
     * @returns {string} - HTML string for related links
     */
    static createRelatedLinks(relatedFormulas = [], relatedParams = []) {
        if ((!relatedFormulas || relatedFormulas.length === 0) &&
            (!relatedParams || relatedParams.length === 0)) {
            return '';
        }

        return `
            <div class="related-links">
                ${relatedFormulas && relatedFormulas.length > 0 ? `
                    <div class="related-formulas">
                        <strong>üìê Related Formulas:</strong>
                        ${relatedFormulas.map(fid => `
                            <a href="formulas.html#formula-${fid}" class="formula-link">${fid}</a>
                        `).join('')}
                    </div>
                ` : ''}
                ${relatedParams && relatedParams.length > 0 ? `
                    <div class="related-params">
                        <strong>üî¢ Related Parameters:</strong>
                        ${relatedParams.map(pid => `
                            <a href="parameters.html#param-${pid}" class="param-link">${pid}</a>
                        `).join('')}
                    </div>
                ` : ''}
            </div>
        `;
    }

    /**
     * Trigger MathJax typesetting on an element
     * @private
     */
    static _triggerMathJax(element) {
        if (typeof window === 'undefined') return;

        // Check for MathJax v3
        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise([element]).catch(err => {
                console.warn('MathJax typesetting failed:', err);
            });
        }
        // Check for MathJax v2
        else if (window.MathJax && window.MathJax.Hub) {
            window.MathJax.Hub.Queue(['Typeset', window.MathJax.Hub, element]);
        }
    }

    /**
     * Get statistics about loaded beginner guide content
     * @returns {Object} - Statistics
     */
    static getStats() {
        if (!this._data) return { loaded: false };

        return {
            loaded: true,
            version: this._data.version || '1.0',
            totalConcepts: this._data.concepts?.length || 0,
            totalPredictions: this._data.predictions?.length || 0,
            conceptsBySection: this._getConceptsBySection(),
            generated: this._data.generated
        };
    }

    /**
     * Get concept count by section
     * @private
     */
    static _getConceptsBySection() {
        if (!this._data || !this._data.concepts) return {};

        const bySection = {};
        this._data.concepts.forEach(c => {
            const section = c.section || 'unknown';
            bySection[section] = (bySection[section] || 0) + 1;
        });
        return bySection;
    }
}

// Auto-load on page load
if (typeof window !== 'undefined') {
    window.PMBeginnerGuideLoader = PMBeginnerGuideLoader;

    // Load when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => PMBeginnerGuideLoader.load());
    } else {
        PMBeginnerGuideLoader.load();
    }
}

// Export for module use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { PMBeginnerGuideLoader };
}
