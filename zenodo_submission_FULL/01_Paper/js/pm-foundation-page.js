/**
 * PM Foundation Page Loader
 * Dynamically loads foundation page content from theory_output.json
 *
 * Copyright (c) 2025 Andrew Keith Watts. All rights reserved.
 */

class PMFoundationPageLoader {
    constructor() {
        this.foundationId = null;
        this.foundationData = null;
        this.theoryData = null;
    }

    /**
     * Extract foundation ID from URL query parameter or filename
     */
    extractFoundationId() {
        // First try URL query parameter: ?id=boltzmann-entropy
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('id')) {
            return urlParams.get('id');
        }

        // Fall back to filename: boltzmann-entropy.html -> boltzmann-entropy
        const filename = window.location.pathname.split('/').pop();
        if (filename && filename.endsWith('.html')) {
            const id = filename.replace('.html', '');
            // Don't use index or foundation-template as IDs
            if (id !== 'index' && id !== 'foundation-template') {
                return id;
            }
        }

        return null;
    }

    /**
     * Fetch theory_output.json
     */
    async fetchTheoryData() {
        const paths = [
            '/AutoGenerated/theory_output.json',   // Absolute path (for live site)
            '../AutoGenerated/theory_output.json', // From foundations/ subdirectory
            '../theory_output.json',               // Legacy path
            'AutoGenerated/theory_output.json',
            './AutoGenerated/theory_output.json'
        ];

        for (const path of paths) {
            try {
                const response = await fetch(path);
                if (response.ok) {
                    this.theoryData = await response.json();
                    console.log(`Loaded theory data from: ${path}`);
                    return this.theoryData;
                }
            } catch (error) {
                continue;
            }
        }

        throw new Error('Failed to fetch theory_output.json from any path');
    }

    /**
     * Find foundation data by ID
     */
    findFoundation(foundationId) {
        if (!this.theoryData || !this.theoryData.foundations) {
            console.warn('No foundations section in theory_output.json');
            return null;
        }

        // Foundations are stored as an array
        if (Array.isArray(this.theoryData.foundations)) {
            return this.theoryData.foundations.find(f => f.id === foundationId);
        } else {
            // Fallback: treat as object with IDs as keys
            return this.theoryData.foundations[foundationId];
        }
    }

    /**
     * Render the hero section with main equation
     */
    renderHero(foundation) {
        const heroSection = document.getElementById('foundation-hero');
        if (!heroSection) return;

        const statusBadge = foundation.status || 'established';
        const year = foundation.year || '';
        const gradient = foundation.gradient || 'linear-gradient(135deg, rgba(255, 126, 182, 0.15), rgba(255, 179, 71, 0.1))';
        const borderColor = foundation.borderColor || 'rgba(255, 126, 182, 0.3)';

        heroSection.style.background = gradient;
        heroSection.style.border = `2px solid ${borderColor}`;

        heroSection.innerHTML = `
            <span class="foundation-badge ${statusBadge}" style="margin-bottom: 1rem;">
                ${this.formatBadgeText(statusBadge, year)}
            </span>
            <h1 style="background: linear-gradient(135deg, #ff7eb6, #ffb347); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                ${foundation.name}
            </h1>
            <p style="color: var(--text-secondary); font-size: 1.1rem; max-width: 800px; margin: 0 auto 1.5rem;">
                ${foundation.description}
            </p>
            <div class="main-equation" style="background: rgba(255, 126, 182, 0.1);">
                ${foundation.equation}
            </div>
            ${foundation.attribution ? `
                <p style="color: var(--text-muted); font-size: 0.9rem; margin-top: 1rem;">
                    ${foundation.attribution}
                </p>
            ` : ''}
        `;
    }

    /**
     * Format badge text
     */
    formatBadgeText(status, year) {
        const statusMap = {
            'established': 'Established Physics',
            'theoretical': 'Theoretical Framework',
            'conjectural': 'Conjectural',
            'experimental': 'Experimental'
        };
        const statusText = statusMap[status] || status;
        return year ? `${statusText} (${year})` : statusText;
    }

    /**
     * Render key properties section
     */
    renderKeyProperties(foundation) {
        const propertiesSection = document.getElementById('key-properties');
        if (!propertiesSection || !foundation.properties) return;

        const properties = foundation.properties;
        let propertiesHtml = `
            <h2>What Does This Equation Mean?</h2>
            <p style="font-size: 1.1rem; color: var(--text-primary); margin-bottom: 1.5rem;">
                <strong>"${properties.meaning || foundation.description}"</strong>
            </p>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem; margin-top: 1.5rem;">
        `;

        if (properties.components && Array.isArray(properties.components)) {
            properties.components.forEach((comp, idx) => {
                const colors = [
                    { bg: 'rgba(255, 126, 182, 0.08)', border: '#ff7eb6', text: '#ff7eb6' },
                    { bg: 'rgba(255, 179, 71, 0.08)', border: '#ffb347', text: '#ffb347' },
                    { bg: 'rgba(81, 207, 102, 0.08)', border: '#51cf66', text: '#51cf66' },
                    { bg: 'rgba(79, 172, 254, 0.08)', border: '#4facfe', text: '#4facfe' }
                ];
                const color = colors[idx % colors.length];

                propertiesHtml += `
                    <div class="highlight-box" style="background: ${color.bg}; border-left: 4px solid ${color.border};">
                        <h4 style="color: ${color.text};">${comp.symbol}: ${comp.name}</h4>
                        <p>${comp.description}</p>
                    </div>
                `;
            });
        }

        propertiesHtml += '</div>';
        propertiesSection.innerHTML = propertiesHtml;
    }

    /**
     * Render PM connection section
     */
    renderPMConnection(foundation) {
        const connectionSection = document.getElementById('pm-connection');
        if (!connectionSection || !foundation.pmConnection) return;

        const conn = foundation.pmConnection;
        let html = `
            <h2>Connection to Principia Metaphysica</h2>
            <p>${conn.description || ''}</p>
        `;

        if (conn.applications && Array.isArray(conn.applications)) {
            conn.applications.forEach(app => {
                html += `
                    <div class="highlight-box" style="background: rgba(139, 127, 255, 0.08); border-left: 4px solid #8b7fff; margin-top: 1.5rem;">
                        <h4 style="color: #8b7fff;">${app.title}</h4>
                        <p style="color: var(--text-secondary);">
                            ${app.description}
                        </p>
                        ${app.equation ? `
                            <div class="equation-box" style="margin-top: 1rem;">
                                ${app.equation}
                                ${app.note ? `<span class="equation-label">${app.note}</span>` : ''}
                            </div>
                        ` : ''}
                        ${app.details ? `<p style="color: var(--text-secondary); margin-top: 1rem;">${app.details}</p>` : ''}
                        ${app.list ? `
                            <ul style="color: var(--text-secondary); margin-left: 1.5rem; line-height: 1.8; margin-top: 0.75rem;">
                                ${app.list.map(item => `<li>${item}</li>`).join('')}
                            </ul>
                        ` : ''}
                    </div>
                `;
            });
        }

        connectionSection.innerHTML = html;
    }

    /**
     * Render formula expansion list
     */
    renderFormulaList(foundation) {
        const formulaSection = document.getElementById('formula-list');
        if (!formulaSection || !foundation.formulas) return;

        let html = '';
        foundation.formulas.forEach(formula => {
            html += this.createExpandableFormula(formula);
        });

        formulaSection.innerHTML = html;
    }

    /**
     * Create expandable formula HTML
     */
    createExpandableFormula(formula) {
        return `
            <div class="expandable-formula">
                <div class="formula-header">
                    <div class="formula-main">${formula.equation}</div>
                    <div class="formula-controls">
                        ${formula.status ? `<span class="foundation-badge ${formula.status}">${formula.status}</span>` : ''}
                        <button class="expand-btn" title="Expand formula">&#x25BC;</button>
                    </div>
                </div>
                <div class="formula-expansion">
                    ${this.renderFormulaExpansion(formula)}
                </div>
            </div>
        `;
    }

    /**
     * Render formula expansion details
     */
    renderFormulaExpansion(formula) {
        let html = '<div class="sub-components">';

        if (formula.components && Array.isArray(formula.components)) {
            formula.components.forEach(comp => {
                html += `
                    <div class="sub-component">
                        <div class="component-symbol">${comp.symbol}</div>
                        <div class="component-name">${comp.name}</div>
                        <div class="component-desc">${comp.description}</div>
                        ${comp.link ? `<a href="${comp.link}" target="_blank" class="component-link">${comp.linkText || 'Learn more'} &rarr;</a>` : ''}
                        ${comp.badge ? `<span class="foundation-badge ${comp.badgeType || 'established'}" style="margin-top: 0.5rem;">${comp.badge}</span>` : ''}
                    </div>
                `;
            });
        }

        html += '</div>';

        // Add derivation chain if present
        if (formula.derivationChain && Array.isArray(formula.derivationChain)) {
            html += `
                <div class="derivation-chain">
                    <div class="chain-title">Foundation Chain</div>
                    ${formula.derivationChain.map(step => `
                        <div class="chain-step">
                            <span class="step-arrow">&rarr;</span>
                            <span>${step.text}</span>
                            <span class="foundation-badge ${step.type || 'established'}">${step.badge}</span>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        return html;
    }

    /**
     * Render usage in PM sections
     */
    renderUsageInPM(foundation) {
        const usageSection = document.getElementById('pm-usage');
        if (!usageSection || !foundation.usedInSections) return;

        let html = `
            <h2 style="color: #8b7fff;">Where ${foundation.name} Is Used in PM</h2>
            <p>This foundational physics appears in the following sections of Principia Metaphysica:</p>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin-top: 1.5rem;">
        `;

        foundation.usedInSections.forEach(section => {
            html += `
                <div class="resource-card" style="border-left: 4px solid #8b7fff;">
                    <h4 style="color: #8b7fff;">${section.title}</h4>
                    <p style="color: var(--text-secondary); font-size: 0.95rem; margin: 0.75rem 0;">
                        ${section.description || ''}
                    </p>
                    <a href="../sections/${section.link}" class="resource-link" style="color: var(--accent-primary);">
                        Read More &rarr;
                    </a>
                </div>
            `;
        });

        html += `
            </div>
            <div style="text-align: center; margin-top: 2rem;">
                <a href="../sections/index.html" style="display: inline-block; padding: 1rem 2rem; background: linear-gradient(135deg, #8b7fff, #ff7eb6); color: white; text-decoration: none; border-radius: 10px; font-weight: 700; font-size: 1.05rem;">
                    Browse All Theory Sections &rarr;
                </a>
            </div>
        `;

        usageSection.innerHTML = html;
    }

    /**
     * Render fallback content if data is missing
     */
    renderFallback(foundationId) {
        const mainContent = document.getElementById('foundation-content');
        if (!mainContent) return;

        mainContent.innerHTML = `
            <div class="subsection" style="background: rgba(255, 126, 182, 0.08); border-left: 4px solid #ff7eb6; padding: 2rem; text-align: center;">
                <h2>Foundation Not Found</h2>
                <p style="color: var(--text-secondary); font-size: 1.1rem; margin: 1.5rem 0;">
                    The foundation page "${foundationId}" could not be loaded from theory_output.json.
                </p>
                <p style="color: var(--text-muted);">
                    This page may not be configured yet, or there may be an error in the data file.
                </p>
                <div style="margin-top: 2rem;">
                    <a href="index.html" style="display: inline-block; padding: 1rem 2rem; background: linear-gradient(135deg, #8b7fff, #ff7eb6); color: white; text-decoration: none; border-radius: 10px; font-weight: 700;">
                        &larr; Back to All Foundations
                    </a>
                </div>
            </div>
        `;
    }

    /**
     * Update page title and breadcrumbs
     */
    updatePageMetadata(foundation) {
        // Update page title
        if (foundation.name) {
            document.title = `${foundation.name} - Foundational Physics`;
        }

        // Update meta description if element exists
        const metaDesc = document.querySelector('meta[name="description"]');
        if (metaDesc && foundation.description) {
            metaDesc.setAttribute('content', foundation.description);
        }
    }

    /**
     * Initialize and load foundation page
     */
    async init() {
        try {
            // Extract foundation ID
            this.foundationId = this.extractFoundationId();

            if (!this.foundationId) {
                console.warn('No foundation ID found in URL');
                return;
            }

            // Fetch theory data
            await this.fetchTheoryData();

            // Find foundation data
            this.foundationData = this.findFoundation(this.foundationId);

            if (!this.foundationData) {
                console.warn(`Foundation "${this.foundationId}" not found in theory_output.json`);
                this.renderFallback(this.foundationId);
                return;
            }

            // Render all sections
            this.updatePageMetadata(this.foundationData);
            this.renderHero(this.foundationData);
            this.renderKeyProperties(this.foundationData);
            this.renderPMConnection(this.foundationData);
            this.renderFormulaList(this.foundationData);
            this.renderUsageInPM(this.foundationData);

            console.log(`Foundation page loaded: ${this.foundationId}`);
        } catch (error) {
            console.error('Error initializing foundation page:', error);
            this.renderFallback(this.foundationId || 'unknown');
        }
    }
}

// Auto-initialize when DOM is ready
if (typeof window !== 'undefined') {
    window.PMFoundationPageLoader = PMFoundationPageLoader;

    // Auto-load if the page has the marker attribute
    document.addEventListener('DOMContentLoaded', () => {
        const shouldAutoLoad = document.body.hasAttribute('data-pm-foundation-auto-load');
        if (shouldAutoLoad) {
            const loader = new PMFoundationPageLoader();
            loader.init();
        }
    });
}

// Export for module usage
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PMFoundationPageLoader;
}
