/**
 * Principia Metaphysica - Enhanced Tooltip System
 * ================================================
 *
 * SOLID-principled tooltip system for Principia Metaphysica website.
 * Provides intelligent tooltips for:
 * - Parameters (with values, units, uncertainty from parameters.json)
 * - Formula terms (with definitions)
 * - Status badges (explains validation status)
 * - PM values (from theory constants)
 *
 * Features:
 * - Auto-loads parameter data from AutoGenerated/parameters.json
 * - Smart positioning (stays within viewport)
 * - Mobile-friendly touch support
 * - Accessible (ARIA labels, keyboard navigation)
 * - Performance optimized (debounced, cached)
 *
 * Usage in HTML:
 * <span class="pm-value"
 *       data-category="proton_decay"
 *       data-param="tau_p_median"
 *       data-format="scientific:2"></span>
 *
 * Copyright (c) 2025 Andrew Keith Watts. All rights reserved.
 */

(function() {
    'use strict';

    // Single Responsibility Principle: Each function has one clear purpose
    // Open/Closed Principle: Extensible through configuration
    // Liskov Substitution: Works with or without PM constants
    // Interface Segregation: Minimal API surface
    // Dependency Inversion: Depends on abstractions (data format), not concrete implementations

    // Parameter cache
    let parametersCache = null;
    let parametersLoaded = false;

    // ========================================================================
    // CONFIGURATION (Open/Closed Principle: Configure behavior)
    // ========================================================================

    const CONFIG = {
        HOVER_DELAY: 300,
        TOUCH_DELAY: 150,
        HIDE_DELAY: 200,
        MAX_WIDTH: 320,
        OFFSET_X: 10,
        OFFSET_Y: 10,
        Z_INDEX: 10000
    };

    const STATUS_DEFINITIONS = {
        'EXACT MATCH': {
            description: 'Formula prediction matches experimental value exactly within measurement uncertainty',
            icon: '‚úì',
            color: '#50c878'
        },
        'VALIDATED': {
            description: 'Formula has been validated against experimental data with good agreement',
            icon: '‚úì',
            color: '#a99aff'
        },
        'AGREEMENT': {
            description: 'Theory agrees with observations within acceptable error margins',
            icon: '‚úì',
            color: '#a99aff'
        },
        'GEOMETRIC': {
            description: 'Derived from geometric principles of G2 manifold structure',
            icon: 'üìê',
            color: '#ffc107'
        },
        'PREDICTION': {
            description: 'Testable prediction that can be verified by future experiments',
            icon: 'üîÆ',
            color: '#ff7eb6'
        },
        'TESTABLE': {
            description: 'Prediction that can be tested with current or near-future technology',
            icon: 'üî¨',
            color: '#ff7eb6'
        },
        'ESTABLISHED': {
            description: 'Well-established value from standard physics (PDG, CODATA, etc.)',
            icon: 'üìö',
            color: '#4ade80'
        },
        'DERIVED': {
            description: 'Calculated from other formulas in the theory',
            icon: 'üîó',
            color: '#60a5fa'
        }
    };

    // ========================================================================
    // UTILITY FUNCTIONS (Single Responsibility Principle)
    // ========================================================================

    /**
     * Format a value according to specified format
     */
    function formatValue(value, format) {
        if (value === null || value === undefined) return '‚Äî';
        if (typeof value === 'string') return value;

        if (!format || typeof value !== 'number') {
            return value.toString();
        }

        const [type, precision] = format.split(':');
        const prec = parseInt(precision) || 2;

        switch(type) {
            case 'scientific':
                return value.toExponential(prec);
            case 'fixed':
                return value.toFixed(prec);
            case 'percent':
                return (value * 100).toFixed(prec) + '%';
            case 'display':
                return value; // Use pre-formatted display string
            default:
                // Smart formatting
                const abs = Math.abs(value);
                if (abs === 0) return '0';
                if (abs >= 1e10 || (abs < 0.001 && abs > 0)) {
                    return value.toExponential(3);
                } else if (Number.isInteger(value)) {
                    return value.toLocaleString();
                } else {
                    return value.toPrecision(4);
                }
        }
    }

    /**
     * Load parameters from JSON (Dependency Inversion: depends on data format, not source)
     */
    async function loadParameters() {
        if (parametersLoaded) return parametersCache;

        try {
            const paths = [
                '/AutoGenerated/parameters.json',
                'AutoGenerated/parameters.json',
                '../AutoGenerated/parameters.json',
                '../../AutoGenerated/parameters.json'
            ];

            for (const path of paths) {
                try {
                    const response = await fetch(path);
                    if (response.ok) {
                        const data = await response.json();
                        parametersCache = data.parameters || data;
                        parametersLoaded = true;
                        console.log(`[PM Tooltip] Loaded ${Object.keys(parametersCache).length} parameters from ${path}`);
                        return parametersCache;
                    }
                } catch (e) {
                    continue;
                }
            }

            console.warn('[PM Tooltip] Could not load parameters.json');
            parametersCache = {};
            parametersLoaded = true;
        } catch (error) {
            console.error('[PM Tooltip] Error loading parameters:', error);
            parametersCache = {};
            parametersLoaded = true;
        }

        return parametersCache;
    }

    /**
     * Resolve parameter ID from symbol or partial ID
     */
    function resolveParameterId(symbol) {
        if (!parametersCache) return symbol;

        // Direct match
        if (parametersCache[symbol]) return symbol;

        // Try common prefixes
        const prefixes = ['constants.', 'topology.', 'gauge.', 'fermions.', 'pmns.', 'ckm.'];
        for (const prefix of prefixes) {
            const fullId = prefix + symbol;
            if (parametersCache[fullId]) return fullId;
        }

        // Search by symbol in metadata
        for (const [id, param] of Object.entries(parametersCache)) {
            if (param.metadata?.symbol === symbol) return id;
        }

        return symbol;
    }

    /**
     * Populate all .pm-value elements with their values
     */
    function setupPMValues() {
        const elements = document.querySelectorAll('.pm-value, [data-category][data-param]');

        elements.forEach(el => {
            const category = el.dataset.category;
            const param = el.dataset.param;
            const format = el.dataset.format;
            const field = el.dataset.field; // Optional: access nested field like "experimental_value"

            if (!category || !param) {
                console.warn('Missing data-category or data-param on element:', el);
                return;
            }

            if (!PM[category]) {
                console.warn(`Category "${category}" not found in PM constants`);
                return;
            }

            const obj = PM[category][param];
            if (obj === undefined || obj === null) {
                console.warn(`Parameter "${param}" not found in PM.${category}`);
                return;
            }

            // Get the value - handle both object format (with .value) and direct primitives
            let value;
            if (field && typeof obj === 'object' && obj[field] !== undefined) {
                value = obj[field];
            } else if (typeof obj === 'object' && obj !== null && obj.value !== undefined) {
                value = obj.value;
            } else {
                // Direct primitive value (number, string, etc.)
                value = obj;
            }

            // Use display string if available, otherwise format value
            let displayValue;
            if (format === 'display' && obj.display) {
                displayValue = obj.display;
            } else if (typeof value === 'number') {
                displayValue = formatValue(value, format);
            } else {
                displayValue = value.toString();
            }

            // Set the text content
            el.textContent = displayValue;

            // Add unit if specified and not already in display
            // Don't add unit for nested fields unless explicitly requested
            if (!field && obj.unit && !el.dataset.noUnit && format !== 'display') {
                el.textContent += ' ' + obj.unit;
            }

            // Store object reference for tooltip
            el._pmObject = obj;
        });

        console.log(`[PM] Populated ${elements.length} constant values`);
    }

    // ========================================================================
    // TOOLTIP GENERATION (Single Responsibility: Generate content)
    // ========================================================================

    /**
     * Generate parameter tooltip content
     */
    function generateParameterTooltip(paramId) {
        if (!parametersCache) return null;

        const param = parametersCache[paramId];
        if (!param) return null;

        const metadata = param.metadata || {};
        const description = metadata.description || 'No description available';
        const units = metadata.units || '';
        const value = formatValue(param.value);
        const uncertainty = param.uncertainty ? `¬±${formatValue(param.uncertainty)}` : '';
        const source = param.source || '';

        return `
            <div class="pm-tooltip-header">
                <span class="pm-tooltip-icon">üìä</span>
                <span class="pm-tooltip-title">${paramId.split('.').pop()}</span>
            </div>
            <div class="pm-tooltip-value">
                ${value}${uncertainty ? ' ' + uncertainty : ''} ${units}
            </div>
            <div class="pm-tooltip-description">${description}</div>
            ${source || param.status ? `
                <div class="pm-tooltip-meta">
                    ${param.status ? `
                        <div class="pm-tooltip-meta-item">
                            <span class="pm-tooltip-meta-label">Status:</span>
                            <span class="pm-tooltip-meta-value">${param.status}</span>
                        </div>
                    ` : ''}
                    ${source ? `
                        <div class="pm-tooltip-meta-item">
                            <span class="pm-tooltip-meta-label">Source:</span>
                            <span class="pm-tooltip-meta-value">${source}</span>
                        </div>
                    ` : ''}
                </div>
            ` : ''}
        `;
    }

    /**
     * Generate status badge tooltip content
     */
    function generateStatusTooltip(status) {
        const def = STATUS_DEFINITIONS[status.toUpperCase()];
        if (!def) {
            return `
                <div class="pm-tooltip-header">
                    <span class="pm-tooltip-icon">‚ÑπÔ∏è</span>
                    <span class="pm-tooltip-title">${status}</span>
                </div>
                <div class="pm-tooltip-description">Status indicator</div>
            `;
        }

        return `
            <div class="pm-tooltip-header">
                <span class="pm-tooltip-icon">${def.icon}</span>
                <span class="pm-tooltip-title">${status}</span>
            </div>
            <div class="pm-tooltip-description">${def.description}</div>
        `;
    }

    /**
     * Generate term tooltip content
     */
    function generateTermTooltip(symbol, description) {
        return `
            <div class="pm-tooltip-header">
                <span class="pm-tooltip-icon">üìñ</span>
                <span class="pm-tooltip-title">${symbol}</span>
            </div>
            <div class="pm-tooltip-description">${description || 'Formula term'}</div>
        `;
    }

    // ========================================================================
    // TOOLTIP DISPLAY (Single Responsibility: Display management)
    // ========================================================================

    let activeTooltip = null;
    let hoverTimeout = null;
    let tooltipElement = null;

    /**
     * Create tooltip DOM element
     */
    function createTooltipElement() {
        if (tooltipElement) return;

        tooltipElement = document.createElement('div');
        tooltipElement.className = 'pm-tooltip-popup pm-enhanced-tooltip';
        tooltipElement.setAttribute('role', 'tooltip');
        tooltipElement.setAttribute('aria-live', 'polite');
        tooltipElement.style.position = 'fixed';
        tooltipElement.style.zIndex = CONFIG.Z_INDEX;
        tooltipElement.style.maxWidth = CONFIG.MAX_WIDTH + 'px';
        tooltipElement.style.opacity = '0';
        tooltipElement.style.transition = 'opacity 0.2s ease, transform 0.2s ease';
        tooltipElement.style.pointerEvents = 'none';

        document.body.appendChild(tooltipElement);
    }

    /**
     * Position tooltip intelligently within viewport
     */
    function positionTooltip(x, y) {
        if (!tooltipElement) return;

        const rect = tooltipElement.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        let left = x + CONFIG.OFFSET_X;
        let top = y + CONFIG.OFFSET_Y;

        // Prevent overflow on right
        if (left + rect.width > viewportWidth - 10) {
            left = x - rect.width - CONFIG.OFFSET_X;
        }

        // Prevent overflow on bottom
        if (top + rect.height > viewportHeight - 10) {
            top = y - rect.height - CONFIG.OFFSET_Y;
        }

        // Prevent overflow on left
        if (left < 10) left = 10;

        // Prevent overflow on top
        if (top < 10) top = 10;

        tooltipElement.style.left = `${left}px`;
        tooltipElement.style.top = `${top}px`;
    }

    /**
     * Create and show tooltip
     */
    function showTooltip(event, content) {
        // Remove any existing tooltips
        removeTooltip();

        if (!tooltipElement) createTooltipElement();

        tooltipElement.innerHTML = content;
        tooltipElement.style.opacity = '0';
        tooltipElement.style.display = 'block';

        // Position after render to get accurate dimensions
        requestAnimationFrame(() => {
            positionTooltip(event.clientX || event.pageX, event.clientY || event.pageY);
            tooltipElement.style.opacity = '1';
            tooltipElement.style.transform = 'translateY(0)';
        });

        activeTooltip = { event, content };
    }

    /**
     * Remove tooltip
     */
    function removeTooltip() {
        if (tooltipElement) {
            tooltipElement.style.opacity = '0';
            tooltipElement.style.transform = 'translateY(4px)';
            setTimeout(() => {
                if (tooltipElement) tooltipElement.style.display = 'none';
            }, 200);
        }
        activeTooltip = null;
    }

    // ========================================================================
    // EVENT HANDLING (Single Responsibility: Event management)
    // ========================================================================

    /**
     * Handle mouse enter with delay
     */
    function handleMouseEnter(e, element, generator) {
        clearTimeout(hoverTimeout);

        hoverTimeout = setTimeout(() => {
            const content = generator();
            if (content) {
                showTooltip(e, content);
            }
        }, CONFIG.HOVER_DELAY);
    }

    /**
     * Handle mouse leave with delay
     */
    function handleMouseLeave() {
        clearTimeout(hoverTimeout);
        setTimeout(() => removeTooltip(), CONFIG.HIDE_DELAY);
    }

    /**
     * Handle mouse move (update tooltip position)
     */
    function handleMouseMove(e) {
        if (activeTooltip && tooltipElement && tooltipElement.style.display !== 'none') {
            positionTooltip(e.clientX || e.pageX, e.clientY || e.pageY);
        }
    }

    /**
     * Enhanced element detection and tooltip attachment
     */
    function enhanceElements() {
        // Enhance parameter references
        document.querySelectorAll('.param-card, .param-chip, [data-param-id]').forEach(element => {
            if (element.dataset.tooltipEnhanced) return;

            const paramId = element.dataset.paramId ||
                          element.querySelector('.param-symbol')?.textContent?.trim() ||
                          element.textContent?.trim().split('=')[0]?.trim();

            if (paramId) {
                const resolvedId = resolveParameterId(paramId);
                element.dataset.tooltipEnhanced = 'true';
                element.style.cursor = 'help';

                element.addEventListener('mouseenter', (e) =>
                    handleMouseEnter(e, element, () => generateParameterTooltip(resolvedId))
                );
                element.addEventListener('mouseleave', handleMouseLeave);
                element.addEventListener('mousemove', handleMouseMove);
            }
        });

        // Enhance status badges
        document.querySelectorAll('.status-badge').forEach(element => {
            if (element.dataset.tooltipEnhanced) return;

            const status = element.textContent.trim();
            element.dataset.tooltipEnhanced = 'true';
            element.style.cursor = 'help';

            element.addEventListener('mouseenter', (e) =>
                handleMouseEnter(e, element, () => generateStatusTooltip(status))
            );
            element.addEventListener('mouseleave', handleMouseLeave);
            element.addEventListener('mousemove', handleMouseMove);
        });

        // Enhance formula terms
        document.querySelectorAll('.term-item, .formula-var').forEach(element => {
            if (element.dataset.tooltipEnhanced) return;

            const symbol = element.querySelector('.term-symbol')?.textContent?.trim() ||
                          element.textContent?.trim();
            const description = element.querySelector('.term-description')?.textContent?.trim() ||
                              element.dataset.description || '';

            if (symbol) {
                element.dataset.tooltipEnhanced = 'true';
                element.style.cursor = 'help';

                element.addEventListener('mouseenter', (e) =>
                    handleMouseEnter(e, element, () => generateTermTooltip(symbol, description))
                );
                element.addEventListener('mouseleave', handleMouseLeave);
                element.addEventListener('mousemove', handleMouseMove);
            }
        });
    }

    /**
     * Setup hover listeners (legacy PM value support)
     */
    function setupHoverListeners() {
        document.addEventListener('mouseover', (e) => {
            if (e.target.classList.contains('pm-value') && e.target._pmObject) {
                const content = typeof PM !== 'undefined' && PM.getTooltip
                    ? PM.getTooltip(e.target._pmObject)
                    : generateParameterTooltip(e.target.dataset.param);
                if (content) showTooltip(e, content);
            }
        });

        document.addEventListener('mouseout', (e) => {
            if (e.target.classList.contains('pm-value')) {
                removeTooltip();
            }
        });

        // Update tooltip position on mouse move
        document.addEventListener('mousemove', handleMouseMove);

        // Hide tooltip on scroll
        window.addEventListener('scroll', removeTooltip, { passive: true });

        // Hide tooltip on resize
        window.addEventListener('resize', removeTooltip);

        // Hide tooltip on ESC key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') removeTooltip();
        });
    }

    // ========================================================================
    // INITIALIZATION (Single Responsibility: Setup)
    // ========================================================================

    /**
     * Inject enhanced tooltip styles
     */
    function injectStyles() {
        if (document.getElementById('pm-enhanced-tooltip-styles')) return;

        const style = document.createElement('style');
        style.id = 'pm-enhanced-tooltip-styles';
        style.textContent = `
            /* Enhanced Tooltip Styles */
            .pm-enhanced-tooltip {
                padding: 0.875rem 1rem;
                background: rgba(17, 20, 38, 0.98);
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                border: 1px solid rgba(139, 127, 255, 0.4);
                border-radius: 10px;
                box-shadow:
                    0 8px 32px rgba(0, 0, 0, 0.6),
                    0 0 0 1px rgba(139, 127, 255, 0.2) inset;
                font-size: 0.875rem;
                line-height: 1.5;
                color: #f8f9fa;
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            }

            .pm-tooltip-header {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                margin-bottom: 0.5rem;
                padding-bottom: 0.5rem;
                border-bottom: 1px solid rgba(139, 127, 255, 0.2);
            }

            .pm-tooltip-icon {
                font-size: 1.2rem;
                flex-shrink: 0;
            }

            .pm-tooltip-title {
                font-weight: 600;
                color: #a99aff;
                font-size: 0.9rem;
                font-family: 'Fira Code', 'Courier New', monospace;
            }

            .pm-tooltip-value {
                font-size: 1.05rem;
                font-weight: 600;
                color: #50c878;
                margin: 0.5rem 0;
                font-family: 'Source Code Pro', 'Courier New', monospace;
            }

            .pm-tooltip-description {
                color: rgba(255, 255, 255, 0.85);
                margin: 0.5rem 0;
            }

            .pm-tooltip-meta {
                display: flex;
                flex-wrap: wrap;
                gap: 0.75rem;
                margin-top: 0.625rem;
                padding-top: 0.625rem;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                font-size: 0.8rem;
            }

            .pm-tooltip-meta-item {
                display: flex;
                align-items: center;
                gap: 0.35rem;
                color: rgba(255, 255, 255, 0.6);
            }

            .pm-tooltip-meta-label {
                font-weight: 500;
                color: rgba(255, 255, 255, 0.45);
            }

            .pm-tooltip-meta-value {
                color: #93c5fd;
                font-family: 'Source Code Pro', 'Courier New', monospace;
            }

            /* Mobile optimizations */
            @media (max-width: 768px) {
                .pm-enhanced-tooltip {
                    max-width: calc(100vw - 2rem) !important;
                    font-size: 0.8125rem;
                }
            }

            /* Accessibility */
            @media (prefers-reduced-motion: reduce) {
                .pm-enhanced-tooltip {
                    transition: none !important;
                }
            }
        `;
        document.head.appendChild(style);
    }

    /**
     * Initialize enhanced tooltip system
     */
    async function initializeEnhancedTooltips() {
        // Load parameters
        await loadParameters();

        // Inject styles
        injectStyles();

        // Create tooltip element
        createTooltipElement();

        // Enhance elements
        enhanceElements();

        // Setup legacy hover listeners
        setupHoverListeners();

        // Re-enhance on dynamic content changes
        const observer = new MutationObserver((mutations) => {
            let shouldRefresh = false;
            for (const mutation of mutations) {
                if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                    shouldRefresh = true;
                    break;
                }
            }
            if (shouldRefresh) {
                setTimeout(() => enhanceElements(), 100);
            }
        });

        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        console.log('[PM Tooltip] Enhanced tooltip system initialized');
    }

    /**
     * Modified PM.getTooltip to work with object directly (legacy support)
     */
    if (typeof PM !== 'undefined') {
        PM.getTooltip = (obj) => {
            let tooltip = `<div class="pm-tooltip-content">`;

        // Value and unit
        tooltip += `<div class="pm-tooltip-value"><strong>${obj.display || obj.value}</strong>`;
        if (obj.unit) {
            tooltip += ` ${obj.unit}`;
        }
        tooltip += `</div>`;

        // Description
        if (obj.description) {
            tooltip += `<div class="pm-tooltip-desc">${obj.description}</div>`;
        }

        // Formula
        if (obj.formula) {
            tooltip += `<div class="pm-tooltip-formula"><em>Formula:</em> ${obj.formula}</div>`;
        }

        // Derivation
        if (obj.derivation) {
            tooltip += `<div class="pm-tooltip-derivation"><em>Derivation:</em> ${obj.derivation}</div>`;
        }

        // Uncertainty
        if (obj.uncertainty !== undefined || obj.uncertainty_oom !== undefined) {
            const unc = obj.uncertainty_oom !== undefined
                ? `¬±${obj.uncertainty_oom.toFixed(2)} OOM`
                : obj.uncertainty_lower && obj.uncertainty_upper
                    ? `${obj.confidence_level || '68%'} CI: [${obj.uncertainty_lower.toExponential(2)}-${obj.uncertainty_upper.toExponential(2)}]`
                    : `¬±${obj.uncertainty}`;
            tooltip += `<div class="pm-tooltip-uncertainty"><em>Uncertainty:</em> ${unc}</div>`;
        }

        // Experimental comparison
        if (obj.experimental_value !== undefined) {
            tooltip += `<div class="pm-tooltip-experiment">`;
            tooltip += `<em>Experiment:</em> ${obj.experimental_value}`;
            if (obj.experimental_uncertainty) {
                tooltip += ` ¬± ${obj.experimental_uncertainty}`;
            }
            if (obj.experimental_source) {
                tooltip += ` (${obj.experimental_source})`;
            }
            tooltip += `</div>`;
        }

        // Agreement
        if (obj.agreement_sigma !== undefined || obj.agreement || obj.agreement_text) {
            const sigma = obj.agreement_sigma || 0;
            const color = sigma < 1 ? '#4caf50' : sigma < 3 ? '#ff9800' : '#f44336';
            tooltip += `<div class="pm-tooltip-agreement" style="color:${color}">`;
            tooltip += `<em>Agreement:</em> ${obj.agreement_text || obj.agreement || `${sigma.toFixed(2)}œÉ`}`;
            tooltip += `</div>`;
        }

        // Testability
        if (obj.testable) {
            tooltip += `<div class="pm-tooltip-testable"><em>Testable:</em> ${obj.testable}</div>`;
        }

        // Source
        if (obj.source) {
            tooltip += `<div class="pm-tooltip-source"><em>Source:</em> <code>${obj.source}</code></div>`;
        }

        // References
        if (obj.references && obj.references.length > 0) {
            tooltip += `<div class="pm-tooltip-refs"><em>References:</em> ${obj.references.join(', ')}</div>`;
        }

        tooltip += `</div>`;
        return tooltip;
    };

    // ========================================================================
    // AUTO-INITIALIZATION
    // ========================================================================

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', async () => {
            if (typeof PM !== 'undefined') {
                setupPMValues();
            }
            await initializeEnhancedTooltips();
        });
    } else {
        (async () => {
            if (typeof PM !== 'undefined') {
                setupPMValues();
            }
            await initializeEnhancedTooltips();
            })();
})();
    }

    // Expose API for manual refresh
    window.PMTooltipSystem = {
        refresh: enhanceElements,
        loadParameters: loadParameters
    };

    console.log('[PM] Enhanced tooltip system loaded');

})();
