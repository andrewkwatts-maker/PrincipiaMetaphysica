#!/usr/bin/env python3
"""
Formula Validator v16.2
========================

Validates formula definitions in the simulation output to catch errors like:
- Missing formula IDs
- Missing formula content/LaTeX
- Orphaned formula references
- Invalid formula syntax

This prevents website errors like:
"Formula block is missing both an ID and content. This formula cannot be displayed."

Usage:
    python formula_validator_v16_2.py [--fix] [--verbose]

Options:
    --fix       Attempt to fix missing IDs/content automatically
    --verbose   Print detailed validation results

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.
"""

import json
import os
import sys
import re
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, field

# Add project paths
_current_dir = os.path.dirname(os.path.abspath(__file__))
_simulations_root = os.path.dirname(_current_dir)
_project_root = os.path.dirname(_simulations_root)
sys.path.insert(0, _project_root)


@dataclass
class FormulaError:
    """Represents a formula validation error."""
    file_path: str
    formula_id: Optional[str]
    error_type: str  # 'missing_id', 'missing_content', 'invalid_latex', 'orphan_ref'
    description: str
    line_number: Optional[int] = None
    suggested_fix: Optional[str] = None


@dataclass
class ValidationReport:
    """Report of formula validation results."""
    total_formulas: int = 0
    valid_formulas: int = 0
    errors: List[FormulaError] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)

    @property
    def is_valid(self) -> bool:
        return len(self.errors) == 0

    def summary(self) -> str:
        status = "PASS" if self.is_valid else "FAIL"
        return (
            f"Formula Validation: {status}\n"
            f"  Total formulas: {self.total_formulas}\n"
            f"  Valid: {self.valid_formulas}\n"
            f"  Errors: {len(self.errors)}\n"
            f"  Warnings: {len(self.warnings)}"
        )


class FormulaValidator:
    """Validates formula definitions across PM codebase."""

    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.report = ValidationReport()

        # Paths to check
        self.json_paths = [
            self.project_root / "AutoGenerated" / "formulas.json",
            self.project_root / "AutoGenerated" / "theory_output.json",
            self.project_root / "AutoGenerated" / "sections.json",
        ]

        # HTML pages that use formulas
        self.html_paths = list((self.project_root / "Pages").glob("*.html"))

        # JS formula renderers
        self.js_paths = [
            self.project_root / "js" / "pm-formula-component.js",
            self.project_root / "js" / "pm-formula-renderer.js",
            self.project_root / "js" / "formula-registry.js",
        ]

    def validate_all(self, verbose: bool = False) -> ValidationReport:
        """Run all formula validations."""
        print("=" * 60)
        print(" FORMULA VALIDATION v16.2")
        print("=" * 60)

        # Validate JSON formula definitions
        self._validate_json_formulas(verbose)

        # Validate HTML formula references
        self._validate_html_references(verbose)

        # Validate JS registry
        self._validate_js_registry(verbose)

        # Check for orphan references
        self._check_orphan_references(verbose)

        print()
        print(self.report.summary())

        if self.report.errors:
            print("\nERRORS:")
            for err in self.report.errors:
                print(f"  [{err.error_type}] {err.file_path}")
                print(f"    {err.description}")
                if err.suggested_fix:
                    print(f"    FIX: {err.suggested_fix}")

        return self.report

    def _validate_json_formulas(self, verbose: bool) -> None:
        """Validate formula definitions in JSON files."""
        print("\n[1] Checking JSON formula definitions...")

        for json_path in self.json_paths:
            if not json_path.exists():
                if verbose:
                    print(f"  [SKIP] {json_path.name} - file not found")
                continue

            try:
                with open(json_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)

                self._check_formula_dict(data, str(json_path), verbose)

            except json.JSONDecodeError as e:
                self.report.errors.append(FormulaError(
                    file_path=str(json_path),
                    formula_id=None,
                    error_type="invalid_json",
                    description=f"JSON parse error: {e}"
                ))

    def _check_formula_dict(self, data: Any, file_path: str, verbose: bool, path: str = "") -> None:
        """Recursively check formula definitions in a dictionary."""
        if isinstance(data, dict):
            # Check if this looks like a formula definition
            if 'id' in data or 'latex' in data or 'formula' in data or 'content' in data:
                self._validate_formula_entry(data, file_path, path, verbose)

            # Recurse into nested dicts
            for key, value in data.items():
                self._check_formula_dict(value, file_path, verbose, f"{path}.{key}")

        elif isinstance(data, list):
            for i, item in enumerate(data):
                self._check_formula_dict(item, file_path, verbose, f"{path}[{i}]")

    def _validate_formula_entry(self, entry: Dict, file_path: str, path: str, verbose: bool) -> None:
        """Validate a single formula entry."""
        self.report.total_formulas += 1

        formula_id = entry.get('id') or entry.get('formula_id') or entry.get('name')
        content = entry.get('latex') or entry.get('content') or entry.get('formula') or entry.get('expression')

        has_error = False

        # Check for missing ID
        if not formula_id and ('latex' in entry or 'content' in entry or 'formula' in entry):
            self.report.errors.append(FormulaError(
                file_path=file_path,
                formula_id=None,
                error_type="missing_id",
                description=f"Formula at {path} has content but no ID",
                suggested_fix="Add 'id' field to the formula definition"
            ))
            has_error = True

        # Check for missing content
        if formula_id and not content:
            self.report.errors.append(FormulaError(
                file_path=file_path,
                formula_id=formula_id,
                error_type="missing_content",
                description=f"Formula '{formula_id}' has ID but no content/latex",
                suggested_fix=f"Add 'latex' or 'content' field to formula '{formula_id}'"
            ))
            has_error = True

        # Validate LaTeX content
        if content:
            latex_errors = self._validate_latex(content)
            for err in latex_errors:
                self.report.warnings.append(f"Formula '{formula_id}': {err}")

        if not has_error:
            self.report.valid_formulas += 1
            if verbose:
                print(f"  [OK] {formula_id}")

    def _validate_latex(self, latex: str) -> List[str]:
        """Basic LaTeX validation."""
        errors = []

        # Check for unbalanced braces
        if latex.count('{') != latex.count('}'):
            errors.append("Unbalanced braces in LaTeX")

        # Check for unbalanced dollar signs
        dollar_count = latex.count('$') - latex.count('\\$')
        if dollar_count % 2 != 0:
            errors.append("Unbalanced dollar signs in LaTeX")

        # Check for common LaTeX errors
        if '\\frac{' in latex and not re.search(r'\\frac\{[^}]+\}\{[^}]+\}', latex):
            errors.append("Possibly malformed \\frac command")

        return errors

    def _validate_html_references(self, verbose: bool) -> None:
        """Check HTML files for formula references."""
        print("\n[2] Checking HTML formula references...")

        formula_refs = []
        for html_path in self.html_paths:
            if not html_path.exists():
                continue

            try:
                with open(html_path, 'r', encoding='utf-8') as f:
                    content = f.read()

                # Find formula references in HTML
                # Look for pm-formula tags, data-formula attributes, formula-id patterns
                refs = re.findall(r'<pm-formula[^>]*id=["\']([^"\']+)["\']', content)
                refs += re.findall(r'data-formula-id=["\']([^"\']+)["\']', content)
                refs += re.findall(r'formula-ref=["\']([^"\']+)["\']', content)

                for ref in refs:
                    formula_refs.append((ref, str(html_path)))

                if verbose and refs:
                    print(f"  [OK] {html_path.name}: {len(refs)} formula references")

            except Exception as e:
                self.report.warnings.append(f"Could not parse {html_path}: {e}")

        self._formula_refs = formula_refs

    def _validate_js_registry(self, verbose: bool) -> None:
        """Validate JavaScript formula registry."""
        print("\n[3] Checking JS formula registry...")

        registry_path = self.project_root / "js" / "formula-registry.js"
        if not registry_path.exists():
            if verbose:
                print("  [SKIP] formula-registry.js not found")
            return

        try:
            with open(registry_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # Count formula definitions in registry
            formula_defs = re.findall(r'["\']([a-zA-Z0-9_-]+)["\']:\s*\{', content)

            if verbose:
                print(f"  [OK] {len(formula_defs)} formulas in registry")

        except Exception as e:
            self.report.warnings.append(f"Could not parse formula-registry.js: {e}")

    def _check_orphan_references(self, verbose: bool) -> None:
        """Check for formula references that don't have definitions."""
        print("\n[4] Checking for orphan references...")

        # This would require loading all formula definitions and comparing
        # For now, just report if there are any references
        if hasattr(self, '_formula_refs') and self._formula_refs:
            if verbose:
                print(f"  Found {len(self._formula_refs)} formula references in HTML")


def main():
    """Run formula validation."""
    import argparse

    parser = argparse.ArgumentParser(description="Validate formula definitions")
    parser.add_argument('--fix', action='store_true', help="Attempt to fix errors")
    parser.add_argument('--verbose', '-v', action='store_true', help="Verbose output")
    args = parser.parse_args()

    validator = FormulaValidator(_project_root)
    report = validator.validate_all(verbose=args.verbose)

    # Return exit code based on validation
    sys.exit(0 if report.is_valid else 1)


if __name__ == "__main__":
    main()
