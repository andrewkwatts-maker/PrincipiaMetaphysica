#!/usr/bin/env python3
"""
Simulation Link Validation Script
Principia Metaphysica - Bi-directional Linking System

This script validates that all simulation files have correct bi-directional links:
1. Checks that formula IDs referenced in simulation headers exist in theory_output.json
2. Checks that parameter paths referenced are valid
3. Reports broken or missing links
4. Verifies consistency between simulations and theory_output.json

Usage:
    python validate_simulation_links.py [--verbose] [--fix]

Copyright (c) 2025 Andrew Keith Watts. All rights reserved.

Copyright (c) 2025-2026 Andrew Keith Watts. All rights reserved.

Dedicated To:
    My Wife: Elizabeth May Watts
    Our Messiah: Jesus Of Nazareth
"""

import os
import sys
import re
import json
from pathlib import Path
from typing import Dict, List, Set, Tuple
from dataclasses import dataclass


@dataclass
class SimulationLinks:
    """Container for simulation file linkage information"""
    filepath: str
    implements: List[str]
    reads: List[str]
    writes: List[str]
    validates: List[str]


class LinkValidator:
    """Validates bi-directional links between simulations and theory data"""

    def __init__(self, repo_root: str = None):
        """
        Initialize validator

        Args:
            repo_root: Path to repository root (default: auto-detect)
        """
        if repo_root is None:
            # Auto-detect repo root (walk up from this file)
            current = Path(__file__).resolve().parent
            while current.parent != current:
                if (current / 'simulations').exists() and (current / 'AutoGenerated').exists():
                    repo_root = str(current)
                    break
                current = current.parent
            else:
                raise RuntimeError("Could not auto-detect repository root")

        self.repo_root = Path(repo_root)
        self.simulations_dir = self.repo_root / 'simulations'
        self.theory_json_path = self.repo_root / 'AutoGenerated' / 'theory_output.json'

        # Load theory data
        self.theory_data = self._load_theory_data()
        self.formula_ids = self._extract_formula_ids()

        # Validation results
        self.errors = []
        self.warnings = []
        self.info = []

    def _load_theory_data(self) -> Dict:
        """Load theory_output.json"""
        if not self.theory_json_path.exists():
            raise FileNotFoundError(f"Theory data not found: {self.theory_json_path}")

        with open(self.theory_json_path, 'r', encoding='utf-8') as f:
            return json.load(f)

    def _extract_formula_ids(self) -> Set[str]:
        """Extract all formula IDs from theory_output.json"""
        formula_ids = set()

        # Extract from simulations section
        if 'simulations' in self.theory_data:
            for sim_name, sim_data in self.theory_data['simulations'].items():
                if isinstance(sim_data, dict) and 'formula' in sim_data:
                    formula = sim_data['formula']
                    if isinstance(formula, dict) and 'id' in formula:
                        formula_ids.add(formula['id'])

        # Extract from formulas section if it exists
        # The structure is: formulas.formulas (dict of formula objects)
        if 'formulas' in self.theory_data:
            formulas_section = self.theory_data['formulas']
            if isinstance(formulas_section, dict) and 'formulas' in formulas_section:
                # formulas_section['formulas'] is a dict keyed by formula ID
                formula_ids.update(formulas_section['formulas'].keys())
            elif isinstance(formulas_section, list):
                # Legacy: list of formula objects
                for formula in formulas_section:
                    if isinstance(formula, dict) and 'id' in formula:
                        formula_ids.add(formula['id'])

        return formula_ids

    def _parse_simulation_header(self, filepath: Path) -> SimulationLinks:
        """
        Parse bi-directional linking header from simulation file

        Args:
            filepath: Path to simulation file

        Returns:
            SimulationLinks object with extracted information
        """
        implements = []
        reads = []
        writes = []
        validates = []

        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()

            # Find the bi-directional links section
            link_pattern = r'# Bi-directional Links.*?# ={50,}(.*?)(?:# ={50,}|"""|\'\'\')'
            match = re.search(link_pattern, content, re.DOTALL | re.IGNORECASE)

            if not match:
                # No links header found
                return SimulationLinks(str(filepath), [], [], [], [])

            links_section = match.group(1)

            # Parse IMPLEMENTS
            implements_match = re.search(r'# IMPLEMENTS:\s*(.+)', links_section)
            if implements_match:
                implements_str = implements_match.group(1).strip()
                implements = [f.strip() for f in implements_str.split(',')]

            # Parse READS (multi-line)
            reads_match = re.search(r'# READS:(.*?)(?=# WRITES:|# VALIDATES:|$)', links_section, re.DOTALL)
            if reads_match:
                reads_lines = reads_match.group(1).strip().split('\n')
                for line in reads_lines:
                    line = line.strip()
                    if line.startswith('#'):
                        line = line[1:].strip()
                    if line.startswith('-'):
                        # Extract parameter path (before colon)
                        param_match = re.match(r'-\s*([^:]+)', line)
                        if param_match:
                            reads.append(param_match.group(1).strip())

            # Parse WRITES (multi-line)
            writes_match = re.search(r'# WRITES:(.*?)(?=# VALIDATES:|$)', links_section, re.DOTALL)
            if writes_match:
                writes_lines = writes_match.group(1).strip().split('\n')
                for line in writes_lines:
                    line = line.strip()
                    if line.startswith('#'):
                        line = line[1:].strip()
                    if line.startswith('-'):
                        # Extract parameter path (before colon)
                        param_match = re.match(r'-\s*([^:]+)', line)
                        if param_match:
                            writes.append(param_match.group(1).strip())

            # Parse VALIDATES (multi-line)
            validates_match = re.search(r'# VALIDATES:(.*?)$', links_section, re.DOTALL)
            if validates_match:
                validates_lines = validates_match.group(1).strip().split('\n')
                for line in validates_lines:
                    line = line.strip()
                    if line.startswith('#'):
                        line = line[1:].strip()
                    if line.startswith('-'):
                        validates.append(line[1:].strip())

        except Exception as e:
            self.errors.append(f"Error parsing {filepath}: {e}")
            return SimulationLinks(str(filepath), [], [], [], [])

        return SimulationLinks(str(filepath), implements, reads, writes, validates)

    def validate_formula_ids(self, links: SimulationLinks) -> List[str]:
        """
        Validate that formula IDs in IMPLEMENTS exist in theory_output.json

        Args:
            links: SimulationLinks object

        Returns:
            List of error messages
        """
        errors = []

        for formula_id in links.implements:
            if formula_id not in self.formula_ids:
                errors.append(
                    f"BROKEN LINK: {Path(links.filepath).name} implements '{formula_id}' "
                    f"which does not exist in theory_output.json"
                )

        return errors

    def validate_parameter_paths(self, links: SimulationLinks) -> List[str]:
        """
        Validate that parameter paths in READS/WRITES are reasonable

        Args:
            links: SimulationLinks object

        Returns:
            List of warning messages (not errors, since we can't validate all paths)
        """
        warnings = []

        # Common valid prefixes
        valid_prefixes = [
            'config/', 'geometry/', 'gauge/', 'fermion/', 'neutrino/', 'higgs/',
            'yukawa/', 'moduli/', 'energy_scales/', 'topology/', 'compactification/',
            'simulations/'
        ]

        all_params = links.reads + links.writes

        for param in all_params:
            # Check if parameter has a valid prefix
            has_valid_prefix = any(param.startswith(prefix) for prefix in valid_prefixes)

            if not has_valid_prefix:
                warnings.append(
                    f"SUSPICIOUS PATH: {Path(links.filepath).name} references '{param}' "
                    f"which doesn't match standard prefixes"
                )

        return warnings

    def scan_all_simulations(self) -> List[SimulationLinks]:
        """
        Scan all Python simulation files for bi-directional links

        Returns:
            List of SimulationLinks objects
        """
        all_links = []

        # Find all .py files in simulations directory
        for py_file in self.simulations_dir.rglob('*.py'):
            # Skip __pycache__ and validation directory
            if '__pycache__' in str(py_file) or 'validation' in str(py_file):
                continue

            links = self._parse_simulation_header(py_file)

            # Only include files that have at least one link defined
            if links.implements or links.reads or links.writes or links.validates:
                all_links.append(links)

        return all_links

    def generate_report(self, all_links: List[SimulationLinks], verbose: bool = False) -> str:
        """
        Generate validation report

        Args:
            all_links: List of SimulationLinks objects
            verbose: Include detailed information

        Returns:
            Report string
        """
        lines = []
        lines.append("=" * 80)
        lines.append("SIMULATION LINK VALIDATION REPORT")
        lines.append("=" * 80)
        lines.append("")

        # Summary statistics
        total_files = len(all_links)
        total_formulas = sum(len(l.implements) for l in all_links)
        total_reads = sum(len(l.reads) for l in all_links)
        total_writes = sum(len(l.writes) for l in all_links)

        lines.append(f"Scanned {total_files} simulation files with bi-directional links")
        lines.append(f"Total formula implementations: {total_formulas}")
        lines.append(f"Total parameter reads: {total_reads}")
        lines.append(f"Total parameter writes: {total_writes}")
        lines.append("")

        # Known formula IDs
        lines.append(f"Known formula IDs in theory_output.json: {len(self.formula_ids)}")
        if verbose:
            for fid in sorted(self.formula_ids):
                lines.append(f"  - {fid}")
        lines.append("")

        # Validate each simulation
        all_errors = []
        all_warnings = []

        for links in all_links:
            errors = self.validate_formula_ids(links)
            warnings = self.validate_parameter_paths(links)

            all_errors.extend(errors)
            all_warnings.extend(warnings)

        # Report errors
        if all_errors:
            lines.append("ERRORS FOUND:")
            lines.append("-" * 80)
            for error in all_errors:
                lines.append(f"  [ERROR] {error}")
            lines.append("")
        else:
            lines.append("[PASS] No broken formula links found!")
            lines.append("")

        # Report warnings
        if all_warnings:
            lines.append("WARNINGS:")
            lines.append("-" * 80)
            for warning in all_warnings:
                lines.append(f"  [WARN] {warning}")
            lines.append("")
        else:
            lines.append("[PASS] No suspicious parameter paths found!")
            lines.append("")

        # Detailed file-by-file report
        if verbose:
            lines.append("DETAILED FILE REPORT:")
            lines.append("-" * 80)
            for links in sorted(all_links, key=lambda x: x.filepath):
                filename = Path(links.filepath).name
                lines.append(f"\n{filename}:")
                lines.append(f"  Implements: {', '.join(links.implements) if links.implements else 'none'}")
                lines.append(f"  Reads: {len(links.reads)} parameters")
                lines.append(f"  Writes: {len(links.writes)} parameters")
                lines.append(f"  Validates: {len(links.validates)} criteria")

        lines.append("")
        lines.append("=" * 80)

        return "\n".join(lines)

    def validate(self, verbose: bool = False) -> Tuple[bool, str]:
        """
        Run full validation

        Args:
            verbose: Include detailed information in report

        Returns:
            (success, report) tuple
        """
        all_links = self.scan_all_simulations()
        report = self.generate_report(all_links, verbose)

        # Check if any errors were found
        success = True
        for links in all_links:
            if self.validate_formula_ids(links):
                success = False
                break

        return success, report


def main():
    """Main entry point"""
    import argparse

    parser = argparse.ArgumentParser(
        description="Validate bi-directional links in simulation files"
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help="Show detailed file-by-file report"
    )
    parser.add_argument(
        '--repo-root',
        type=str,
        help="Path to repository root (default: auto-detect)"
    )

    args = parser.parse_args()

    try:
        validator = LinkValidator(repo_root=args.repo_root)
        success, report = validator.validate(verbose=args.verbose)

        print(report)

        if not success:
            sys.exit(1)
        else:
            print("\n[SUCCESS] All validation checks passed!")
            sys.exit(0)

    except Exception as e:
        print(f"[FATAL] Validation failed with error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(2)


if __name__ == '__main__':
    main()
